\n===== app/app/settings/SettingsClient.tsx =====
// app/app/settings/SettingsClient.tsx
'use client'

import { useState } from 'react'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

type Props = { initialEmail: string }

export default function SettingsClient({ initialEmail }: Props){
  const supabase = supabaseBrowser()
  const [tab, setTab] = useState<'profile'|'billing'>('profile')

  // Profile state
  const [email, setEmail] = useState(initialEmail)
  const [pass, setPass] = useState('')
  const [loading, setLoading] = useState(false)
  const [msg, setMsg] = useState<string>('')

  // Billing (placeholder for now)
  const [plan] = useState<'Free'|'Pro'>('Free')

  async function updateEmail(e: React.FormEvent){
    e.preventDefault()
    setMsg(''); setLoading(true)
    const { error } = await supabase.auth.updateUser({ email })
    setLoading(false)
    if (error) setMsg(`Kunde inte uppdatera e-post: ${error.message}`)
    else setMsg('E-post uppdaterad! Kolla din inbox om bekr√§ftelse kr√§vs.')
  }

  async function updatePassword(e: React.FormEvent){
    e.preventDefault()
    setMsg(''); setLoading(true)
    const { error } = await supabase.auth.updateUser({ password: pass })
    setLoading(false)
    if (error) setMsg(`Kunde inte byta l√∂senord: ${error.message}`)
    else { setMsg('L√∂senord uppdaterat!'); setPass('') }
  }

  function goUpgrade(){
    // Placeholder: koppla mot Stripe Checkout eller egen uppgraderingssida.
    alert('Upgrade flow not implemented yet. (Stripe/Checkout-l√§nk h√§r senare)')
  }

  return (
    <div className="max-w-[960px]">
      <h1 className="text-xl font-semibold mb-4">Settings</h1>

      <div className="flex gap-6">
        {/* Left menu */}
        <aside className="w-48">
          <nav className="flex flex-col gap-1">
            <button
              className={`text-left p-2 rounded ${tab==='profile'?'bg-blue-100 text-blue-700 font-medium':'hover:bg-gray-100'}`}
              onClick={()=>setTab('profile')}
            >
              Profile
            </button>
            <button
              className={`text-left p-2 rounded ${tab==='billing'?'bg-blue-100 text-blue-700 font-medium':'hover:bg-gray-100'}`}
              onClick={()=>setTab('billing')}
            >
              Billing
            </button>

            <form action="/auth/signout" method="post" className="mt-4">
              <button className="p-2 rounded bg-red-50 text-red-700 hover:bg-red-100 w-full text-left">
                Logga ut
              </button>
            </form>
          </nav>
        </aside>

        {/* Right panel */}
        <section className="flex-1">
          {msg && (
            <div className="mb-3 rounded border border-blue-200 bg-blue-50 text-blue-800 px-3 py-2 text-sm">
              {msg}
            </div>
          )}

          {tab === 'profile' && (
            <div className="space-y-6">
              <div className="border rounded p-4">
                <h2 className="font-medium mb-3">E-post</h2>
                <form onSubmit={updateEmail} className="grid gap-3 max-w-md">
                  <label className="text-sm">
                    Ny e-post
                    <input
                      className="w-full border rounded p-2"
                      type="email"
                      value={email}
                      onChange={e=>setEmail(e.target.value)}
                      required
                    />
                  </label>
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
                    disabled={loading}
                  >
                    Uppdatera e-post
                  </button>
                </form>
              </div>

              <div className="border rounded p-4">
                <h2 className="font-medium mb-3">Byt l√∂senord</h2>
                <form onSubmit={updatePassword} className="grid gap-3 max-w-md">
                  <label className="text-sm">
                    Nytt l√∂senord
                    <input
                      className="w-full border rounded p-2"
                      type="password"
                      value={pass}
                      onChange={e=>setPass(e.target.value)}
                      minLength={6}
                      required
                    />
                  </label>
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
                    disabled={loading}
                  >
                    Uppdatera l√∂senord
                  </button>
                </form>
              </div>
            </div>
          )}

          {tab === 'billing' && (
            <div className="space-y-6">
              <div className="border rounded p-4">
                <h2 className="font-medium mb-2">Prenumeration</h2>
                <p className="text-sm text-slate-600 mb-3">
                  Nuvarande plan: <b>{plan}</b>
                </p>
                <div className="flex gap-2">
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2"
                    onClick={goUpgrade}
                  >
                    Upgrade
                  </button>
                  <button
                    className="border rounded px-4 py-2"
                    onClick={()=>alert('Billing portal not implemented yet')}
                  >
                    Billing portal
                  </button>
                </div>
                <p className="text-xs text-slate-500 mt-3">
                  (H√§r kopplar vi mot Stripe Checkout/Customer Portal i n√§sta steg.)
                </p>
              </div>
            </div>
          )}
        </section>
      </div>
    </div>
  )
}
\n===== app/app/settings/page.tsx =====
'use client'
import { useEffect, useState } from 'react'
import { getLang, setLangCookie, t, type Lang } from '@/lib/i18n'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

type Tab = 'profile' | 'billing' | 'language'

export default function SettingsPage(){
  const [lang,setLang] = useState<Lang>('sv')
  const [tab,setTab] = useState<Tab>('profile')
  const [email,setEmail] = useState<string>('')

  useEffect(()=>{
    setLang(getLang())
    ;(async()=>{
      const supabase = supabaseBrowser()
      const { data } = await supabase.auth.getUser()
      setEmail(data.user?.email || '')
    })()
  },[])

  function changeLang(next: Lang){
    setLangCookie(next)
    setLang(next)
  }

  async function signOut(){
    // POST so we clean cookies server-side
    await fetch('/auth/signout', { method:'POST' })
    window.location.href = '/auth'
  }

  return (
    <div className="min-h-screen">
      <h1 className="text-xl font-semibold mb-4">{t(lang,'settings.title')}</h1>

      <div className="grid grid-cols-1 md:grid-cols-[220px_1fr] gap-6">
        {/* Vertical menu */}
        <aside className="border rounded-lg p-3 bg-white">
          <nav className="flex md:flex-col gap-2">
            <button
              className={`text-left px-3 py-2 rounded ${tab==='profile' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('profile')}
            >
              {t(lang,'settings.menu.profile')}
            </button>
            <button
              className={`text-left px-3 py-2 rounded ${tab==='billing' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('billing')}
            >
              {t(lang,'settings.menu.billing')}
            </button>
            <button
              className={`text-left px-3 py-2 rounded ${tab==='language' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('language')}
            >
              {t(lang,'settings.menu.language')}
            </button>

            <hr className="my-3" />

            <button
              className="text-left px-3 py-2 rounded border border-red-200 text-red-600 hover:bg-red-50"
              onClick={signOut}
            >
              {t(lang,'settings.logout')}
            </button>
          </nav>
        </aside>

        {/* Content */}
        <section className="space-y-4">
          {tab==='profile' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="grid md:grid-cols-2 gap-3">
                <label className="text-sm">{t(lang,'settings.profile.email')}
                  <input className="border rounded p-2 w-full" value={email} readOnly />
                </label>
                <label className="text-sm">{t(lang,'settings.profile.password')}
                  <input className="border rounded p-2 w-full" value="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" readOnly />
                </label>
              </div>
              <div className="mt-3">
                <button className="px-4 py-2 rounded bg-[var(--brand)] text-white hover:opacity-90">
                  {t(lang,'settings.profile.change')}
                </button>
              </div>
            </div>
          )}

          {tab==='billing' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="grid md:grid-cols-2 gap-3">
                <label className="text-sm">{t(lang,'settings.billing.plan')}
                  <input className="border rounded p-2 w-full" value="Free" readOnly />
                </label>
                <div className="flex items-end">
                  <button className="px-4 py-2 rounded bg-[var(--brand)] text-white hover:opacity-90">
                    {t(lang,'settings.billing.upgrade')}
                  </button>
                </div>
              </div>
            </div>
          )}

          {tab==='language' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="text-sm mb-2">{t(lang,'settings.language.choose')}</div>
              <div className="flex gap-2">
                <button
                  className={`px-3 py-2 rounded border ${lang==='sv' ? 'bg-blue-100 border-blue-300' : 'hover:bg-slate-100'}`}
                  onClick={()=>changeLang('sv' as Lang)}
                >
                  Svenska
                </button>
                <button
                  className={`px-3 py-2 rounded border ${lang==='en' ? 'bg-blue-100 border-blue-300' : 'hover:bg-slate-100'}`}
                  onClick={()=>changeLang('en' as Lang)}
                >
                  English
                </button>
              </div>
            </div>
          )}
        </section>
      </div>
    </div>
  )
}
\n===== app/app/aicall/components/AnalyticsSummary.tsx =====
'use client'
export default function AnalyticsSummary({ summary }: { summary: any }) {
  return (
    <div className="p-4 border rounded-xl bg-white mt-6">
      <h3 className="font-semibold text-lg mb-2">üìä Conversation Analytics</h3>
      <p>Empathy Score: {summary.empathyScore}/10</p>
      <p>Talk Ratio: {summary.talkRatio}%</p>
      <p>Confidence: {summary.confidence}/10</p>
    </div>
  )
}
\n===== app/app/aicall/components/VoiceSimMVP.tsx =====
"use client";
import { useState } from "react";
import AnalyticsSummary from "./AnalyticsSummary";

export default function VoiceSimMVP({ personaId }: { personaId: string }) {
  const [conversation, setConversation] = useState<any[]>([]);
  const [report, setReport] = useState<any>(null);

  async function startListening() {
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    const rec = new SR();
    rec.lang = "en-US";
    rec.onresult = async (e: any) => {
      const userText = e.results[0][0].transcript;
      const res = await fetch("/api/voice-reply", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ text: userText, personaId }),
      });
      const data = await res.json();
      const audio = new Audio(`data:audio/mp3;base64,${data.audio}`);
      audio.play();
      setConversation((p) => [...p, { user: userText, ai: data.replyText }]);
    };
    rec.start();
  }

  async function endCall() {
    const res = await fetch("/api/analyze-conversation", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ conversation, personaId }),
    });
    const data = await res.json();
    setReport(data);
  }

  return (
    <div className="space-y-4">
      {!report ? (
        <>
          <button
            onClick={startListening}
            className="bg-green-600 text-white px-4 py-2 rounded-lg"
          >
            üéôÔ∏è Start Call
          </button>
          <button
            onClick={endCall}
            className="bg-red-600 text-white px-4 py-2 rounded-lg"
          >
            ‚õî End Call
          </button>
        </>
      ) : (
        <AnalyticsSummary report={report} />
      )}
    </div>
  );
}
\n===== app/app/aicall/[id]/page.tsx =====
'use client'
import { useParams, useRouter } from 'next/navigation'
import { useEffect, useRef, useState } from 'react'

export default function AICallSession() {
  const { id } = useParams()
  const router = useRouter()
  const [messages, setMessages] = useState<string[]>([])
  const [listening, setListening] = useState(false)
  const recognitionRef = useRef<any>(null)

  // Browser speech recognition (MVP)
  useEffect(() => {
    if (!('webkitSpeechRecognition' in window)) return
    const SpeechRecognition = (window as any).webkitSpeechRecognition
    const recog = new SpeechRecognition()
    recog.lang = 'en-US'
    recog.interimResults = false
    recog.onresult = (e: any) => {
      const transcript = e.results[0][0].transcript
      setMessages((m) => [...m, `üó£ You: ${transcript}`])
      setTimeout(() => {
        setMessages((m) => [
          ...m,
          `ü§ñ AI: "${generateAIResponse(transcript, id as string)}"`,
        ])
      }, 800)
    }
    recognitionRef.current = recog
  }, [id])

  function startListening() {
    recognitionRef.current?.start()
    setListening(true)
  }

  function stopListening() {
    recognitionRef.current?.stop()
    setListening(false)
  }

  function generateAIResponse(input: string, persona: string) {
    if (persona === 'price-sensitive') {
      if (input.includes('price') || input.includes('discount'))
        return 'I really need to know if this is the best deal possible.'
      return "Hmm... I'm not sure it's worth the cost."
    }
    if (persona === 'hard-to-sell') {
      return "I don't think this will fit our needs right now."
    }
    return "That sounds interesting, tell me more!"
  }

  return (
    <div className="p-6 space-y-4">
      <button onClick={() => router.push('/app/aicall')} className="text-blue-600 underline">
        ‚Üê Back to Personas
      </button>
      <h2 className="text-xl font-semibold capitalize">üß† AI Persona: {id}</h2>

      <div className="border rounded-xl p-4 h-64 overflow-y-auto bg-gray-50">
        {messages.length === 0 ? (
          <p className="text-gray-400 text-sm">Call not started yet.</p>
        ) : (
          messages.map((msg, i) => (
            <p key={i} className="text-sm text-gray-800 mb-1">
              {msg}
            </p>
          ))
        )}
      </div>

      <div className="flex gap-4">
        {!listening ? (
          <button
            onClick={startListening}
            className="bg-green-600 text-white px-4 py-2 rounded-lg"
          >
            üé§ Start Talking
          </button>
        ) : (
          <button
            onClick={stopListening}
            className="bg-red-600 text-white px-4 py-2 rounded-lg"
          >
            ‚èπ Stop
          </button>
        )}
      </div>
    </div>
  )
}
\n===== app/app/aicall/page.tsx =====
'use client'
import { useRouter } from 'next/navigation'

const personas = [
  {
    id: 'price-sensitive',
    name: 'Price Sensitive',
    description: 'Focuses heavily on discounts and cost justification.',
  },
  {
    id: 'hard-to-sell',
    name: 'Hard to Sell',
    description: 'Skeptical, slow to trust, often objects repeatedly.',
  },
  {
    id: 'friendly',
    name: 'Friendly & Curious',
    description: 'Open to dialogue but asks many questions.',
  },
]

export default function AICallPage() {
  const router = useRouter()
  return (
    <div className="p-6 space-y-6">
      <h1 className="text-2xl font-bold mb-4">üéß Start AI Call Simulation</h1>
      <p className="text-gray-600">
        Choose a customer type below to start a voice simulation. The AI will respond with tone,
        emotion, and objections based on this persona.
      </p>
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        {personas.map((p) => (
          <div
            key={p.id}
            onClick={() => router.push(`/app/aicall/${p.id}`)}
            className="border rounded-xl p-4 shadow-sm hover:shadow-md cursor-pointer bg-white transition"
          >
            <h3 className="font-semibold text-lg">{p.name}</h3>
            <p className="text-sm text-gray-500">{p.description}</p>
            <button className="mt-3 bg-blue-600 text-white px-3 py-1.5 rounded-lg">
              Start Call ‚Üí
            </button>
          </div>
        ))}
      </div>
    </div>
  )
}
\n===== app/app/kb/page.tsx =====
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type KB = {
  id?: string
  signal: string
  best_practice: string
  profile_name?: string
}

export default function KBPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<KB[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<KB | null>(null)
  const [form, setForm] = useState<KB>({ signal: '', best_practice: '', profile_name: '' })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load() {
    setLoading(true); setError(null)
    try{
      const r = await fetch('/api/kb', { headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load KB failed:', e)
      setError(t(lang,'common.error')); setRows([])
    }finally{ setLoading(false) }
  }

  useEffect(()=>{ load() },[]) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){ setEditing(null); setForm({ signal:'', best_practice:'', profile_name:'' }); setOpen(true) }
  function openEdit(k: KB){ setEditing(k); setForm({ id:k.id, signal:k.signal, best_practice:k.best_practice, profile_name:k.profile_name||'' }); setOpen(true) }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/kb/${editing.id}` : '/api/kb'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type':'application/json', accept:'application/json' },
        body: JSON.stringify(form),
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save KB failed:', e)
      alert(t(lang,'common.error'))
    }finally{ setSaving(false) }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/kb/${id}`, { method:'DELETE', headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete KB failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'kb.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'kb.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'kb.list.empty')}</div>}

      <div className="grid gap-3">
        {rows.map(k=>(
          <div key={k.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{k.signal||'‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={()=>openEdit(k)}>{t(lang,'common.edit')}</button>
                <ConfirmDialog onConfirm={()=>del(k.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm text-slate-700 whitespace-pre-wrap">{k.best_practice||'‚Äî'}</div>
            {k.profile_name && <div className="text-xs text-slate-500 mt-1">{t(lang,'kb.profile')}: {k.profile_name}</div>}
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'kb.edit') : t(lang,'kb.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'kb.form.signal')}
              <input
                className="border rounded p-2 w-full"
                value={form.signal}
                placeholder={t(lang,'kb.ph.signal')}
                onChange={e=>setForm({...form, signal:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'kb.form.best')}
              <textarea
                className="border rounded p-2 w-full min-h-[110px]"
                value={form.best_practice}
                placeholder={t(lang,'kb.ph.best')}
                onChange={e=>setForm({...form, best_practice:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'kb.form.profile')}
              <input
                className="border rounded p-2 w-full"
                value={form.profile_name||''}
                placeholder={t(lang,'kb.ph.profile')}
                onChange={e=>setForm({...form, profile_name:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}
\n===== app/app/geo/page.tsx =====
'use client'
import React, { useEffect, useMemo, useState } from 'react'
import GeoElectricityInfo from '@/components/GeoElectricityInfo'
import DemographicsCard, { DemoData } from '@/components/DemographicsCard'
import { GoogleMap, Marker, useLoadScript } from '@react-google-maps/api'

let KOMMUNER: Array<{ code: string; name_sv: string; name_en: string }> = []
try {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  KOMMUNER = require('../../../data/kommuner').KOMMUNER || []
} catch {}

/** Types */
type Lang = 'sv' | 'en';
type Poi = {
  name: string;
  type?: string;
  distance_m?: number;
  lat: number;
  lon: number;
  rating?: number;
  address?: string;
};
type GeoResp = {
  center?: { lat: number; lon: number };
  address?: string;
  radius_m?: number;
  pois?: Poi[];
  segment?: string;
  plan?: string[];
  hooks?: string[];
  demographics?: { median_income?: string; families?: string; students?: string };
  lang?: Lang;
};

/** Localized text */
const LTEXT = {
  sv: {
    title: 'Geos√∂k (adress + n√§romr√•de)',
    address: 'Adress',
    address_ph: 'Ex: S√∂dra F√∂rstadsgatan 56, Malm√∂',
    enter_hint: 'Tryck Enter f√∂r att s√∂ka',
    radius: 'Radie (m)',
    search: 'S√∂k',
    searching: 'S√∂ker‚Ä¶',
    segment: 'Segment',
    plan: 'Plan',
    hooks: 'Krokar',
    nearby: 'I n√§rheten (f√∂retag)',
    demog: 'SCB: Median disponibel inkomst per √•lder (tkr)',
    loading_map: 'Laddar karta‚Ä¶',
  },
  en: {
    title: 'Geo search (address + nearby)',
    address: 'Address',
    address_ph: 'e.g. S√∂dra F√∂rstadsgatan 56, Malm√∂',
    enter_hint: 'Press Enter to search',
    radius: 'Radius (m)',
    search: 'Search',
    searching: 'Searching‚Ä¶',
    segment: 'Segment',
    plan: 'Plan',
    hooks: 'Hooks',
    nearby: 'Nearby (businesses)',
    demog: 'SCB: Median disposable income by age (tkr)',
    loading_map: 'Loading map‚Ä¶',
  },
} as const;

export default function GeoPage() {
  const [lang, setLang] = useState<Lang>('sv')
  const [address, setAddress] = useState('')
  const [radius, setRadius] = useState(600)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | undefined>()
  const [data, setData] = useState<GeoResp | null>(null)
  const [scb, setScb] = useState<any | null>(null)

  const L = LTEXT[lang]

  const DEMO_MOCK: DemoData = {
    year: 2020,
    incomeByAge: [
      { age: '20‚Äì24', tkr: 190 },
      { age: '25‚Äì34', tkr: 260 },
      { age: '35‚Äì44', tkr: 310 },
      { age: '45‚Äì54', tkr: 330 },
      { age: '55‚Äì64', tkr: 300 },
      { age: '65‚Äì74', tkr: 260 },
    ],
    population: 347_000,
    densityPerKm2: 5100,
  }

  useEffect(() => {
    const ql = new URLSearchParams(window.location.search).get('lang')
    if (ql === 'en') setLang('en')
  }, [])

  const { isLoaded } = useLoadScript({
    googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!,
    libraries: ['places'],
  })

  function onKeyDownSubmit(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      search()
    }
  }

  async function search() {
    try {
      setLoading(true)
      setError(undefined)
      setData(null)
      setScb(null)

      const r = await fetch(
        `/api/geo/pois?address=${encodeURIComponent(address)}&radius_m=${radius}&lang=${lang}`,
        { cache: 'no-store' }
      )
      if (!r.ok) {
        const tx = await r.text().catch(() => '')
        throw new Error(tx || `HTTP ${r.status}`)
      }
      const json: GeoResp = await r.json()
      setData(json)

      const kommunCode = guessKommunCodeFromAddress(json?.address, lang) || ''
      if (kommunCode) {
        const sr = await fetch(
          `/api/geo/scb?region=${encodeURIComponent(kommunCode)}&year=2020&lang=${lang}`,
          { cache: 'no-store' }
        )
        if (sr.ok) {
          const sj = await sr.json()
          setScb(sj)
        }
      }
    } catch (e: any) {
      setError(e?.message || 'Failed to fetch')
    } finally {
      setLoading(false)
    }
  }

  const center = data?.center
  const hasPois = Array.isArray(data?.pois) && data!.pois!.length > 0

  const greenIcon = {
    url: 'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',
    scaledSize: { width: 32, height: 32 } as unknown as google.maps.Size,
  }

  const map = useMemo(() => {
    if (!center || !isLoaded) return null
    const centerLatLng = { lat: center.lat, lng: center.lon }
    return (
      <div className="rounded-lg overflow-hidden border" style={{ height: 420 }}>
        <GoogleMap
          center={centerLatLng}
          zoom={16}
          mapContainerStyle={{ width: '100%', height: '100%' }}
          options={{ streetViewControl: false, mapTypeControl: false }}
        >
          <Marker position={centerLatLng} icon={greenIcon} title={address} />
          {hasPois &&
            data!.pois!.slice(0, 30).map((p, i) => (
              <Marker
                key={i}
                position={{ lat: p.lat, lng: p.lon }}
                title={p.name}
              />
            ))}
        </GoogleMap>
      </div>
    )
  }, [center?.lat, center?.lon, isLoaded, hasPois, data, address])

  return (
    <div className="space-y-4">
      <h1 className="text-xl font-semibold">{L.title}</h1>

      <form
        className="grid md:grid-cols-3 gap-3"
        onSubmit={(e) => { e.preventDefault(); search() }}
      >
        <label className="text-sm md:col-span-2">
          {L.address}
          <input
            className="border rounded p-2 w-full"
            value={address}
            onChange={(e) => setAddress(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            placeholder={L.address_ph}
            aria-label={L.enter_hint}
          />
          <GeoElectricityInfo
            address={address}
            center={data?.center ? { lat: data.center.lat, lon: data.center.lon } : undefined}
          />
        </label>
        <label className="text-sm">
          {L.radius}
          <input
            className="border rounded p-2 w-full"
            type="number"
            min={100}
            max={3000}
            step={50}
            value={radius}
            onChange={(e) => setRadius(Number(e.target.value))}
            onKeyDown={onKeyDownSubmit}
          />
        </label>

        <div className="md:col-span-3 flex gap-2">
          <button
            onClick={(e) => { e.preventDefault(); search() }}
            className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
            disabled={loading}
          >
            {loading ? L.searching : L.search}
          </button>
        </div>
      </form>

      {error && <div className="text-red-600 text-sm">{error}</div>}

      <div className="grid md:grid-cols-2 gap-4">
        <div className="space-y-3">
          {data?.segment && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.segment}</div>
              <div className="font-medium">{data.segment}</div>
            </div>
          )}

          {Array.isArray(data?.plan) && data!.plan!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.plan}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.plan!.slice(0, 3).map((p, i) => <li key={i}>{p}</li>)}
              </ul>
            </div>
          )}

          {Array.isArray(data?.hooks) && data!.hooks!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.hooks}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.hooks!.slice(0, 3).map((h, i) => <li key={i}>{h}</li>)}
              </ul>
            </div>
          )}

          {data?.center && (<DemographicsCard data={DEMO_MOCK} title={L.demog} />)}

          {scb &&
            Array.isArray(scb.median_income_by_age) &&
            scb.median_income_by_age.length > 0 && (
              <div className="border rounded p-3 bg-slate-50">
                <div className="text-sm text-slate-600">{L.demog} ‚Äî {scb.year}</div>
                <ul className="list-disc pl-5 text-sm">
                  {scb.median_income_by_age.map((row: any, i: number) => (
                    <li key={i}>{row.age}: {row.tkr}</li>
                  ))}
                </ul>
              </div>
            )}

          {Array.isArray(data?.pois) && data!.pois!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.nearby}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.pois!.slice(0, 12).map((p, i) => {
                  const dist = typeof p.distance_m === 'number' ? `${Math.round(p.distance_m)} m` : ''
                  const rating = typeof p.rating === 'number' ? ` ‚Ä¢ ‚òÖ ${p.rating}` : ''
                  return (
                    <li key={i}>
                      <span className="font-medium">{p.name || '‚Äî'}</span>
                      {p.type ? <> ‚Ä¢ {p.type}</> : null}
                      {dist ? <> ‚Ä¢ {dist}</> : null}
                      {rating ? <>{rating}</> : null}
                    </li>
                  )
                })}
              </ul>
            </div>
          )}
        </div>

        <div>{map || (
          <div className="h-[420px] border rounded bg-slate-50 grid place-items-center text-slate-500">
            {L.loading_map}
          </div>
        )}</div>
      </div>
    </div>
  )
}

function guessKommunCodeFromAddress(addr?: string | null, lang: Lang = 'sv'): string | undefined {
  if (!addr) return undefined
  const txt = addr.toLowerCase()
  const matches = KOMMUNER.filter(
    (k) =>
      k.name_sv.toLowerCase() === txt ||
      txt.includes(k.name_sv.toLowerCase()) ||
      txt.includes(k.name_en.toLowerCase())
  )
  if (matches.length > 0) return matches[0].code
  if (/malm/.test(txt)) return '1280'
  if (/stockholm/.test(txt)) return '0180'
  if (/g√∂teborg|goteborg|gothenburg/.test(txt)) return '1480'
  return undefined
}
\n===== app/app/qa/QAClient.tsx =====
// app/app/qa/QAClient.tsx
'use client'

import { useState } from 'react'

export default function QAClient() {
  const [question, setQuestion] = useState('')
  const [loading, setLoading] = useState(false)
  const [answer, setAnswer] = useState<string | null>(null)

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!question.trim()) return
    setLoading(true)
    setAnswer(null)

    try {
      const res = await fetch('/api/qa', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question }),
      })
      const data = await res.json()
      setAnswer(data.answer || 'No answer received.')
    } catch (err) {
      console.error(err)
      setAnswer('Error fetching answer.')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto space-y-6">
      <form onSubmit={handleSubmit} className="space-y-3">
        <label className="block text-sm font-medium text-gray-700">
          Question / Signal
        </label>
        <input
          type="text"
          placeholder="Ask your question..."
          className="w-full border rounded p-3"
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
        />

        <button
          type="submit"
          disabled={loading}
          className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
        >
          {loading ? 'Loading...' : 'Get Answer'}
        </button>
      </form>

      {answer && (
        <div className="p-4 border rounded bg-slate-50">
          <h2 className="font-medium mb-2">Answer:</h2>
          <p>{answer}</p>
        </div>
      )}
    </div>
  )
}
\n===== app/app/qa/page.tsx =====
"use client";

import React, { useEffect, useMemo, useState, KeyboardEvent } from "react";
import GeoElectricityInfo from "@/components/GeoElectricityInfo";
import { GoogleMap, Marker, useLoadScript } from "@react-google-maps/api";

type Item = { id: string; name: string };

// ------- Geo types (same shape as /api/geo/pois) -------
type Lang = "sv" | "en";
type Poi = {
  name: string;
  type?: string;
  distance_m?: number;
  lat: number;
  lon: number;
  rating?: number;
  address?: string;
};
type GeoResp = {
  center?: { lat: number; lon: number };
  address?: string;
  radius_m?: number;
  pois?: Poi[];
  segment?: string;
  plan?: string[];
  hooks?: string[];
  demographics?: { median_income?: string; families?: string; students?: string };
  lang?: Lang;
};

// ---------- Little helpers ----------
function StarRating({
  value,
  onChange,
  onEnter,
}: {
  value: number;
  onChange: (v: number) => void;
  onEnter?: () => void;
}) {
  return (
    <div
      className="flex gap-1 items-center text-xl select-none"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === "Enter" && onEnter) onEnter();
        if (e.key === "ArrowRight") onChange(Math.min(5, (value || 0) + 1));
        if (e.key === "ArrowLeft") onChange(Math.max(1, (value || 0) - 1));
      }}
      aria-label="Betyg 1‚Äì5"
      role="radiogroup"
    >
      {[1, 2, 3, 4, 5].map((n) => (
        <button
          key={n}
          type="button"
          className="px-1"
          onClick={() => onChange(n)}
          aria-checked={value === n}
          role="radio"
          title={`${n}/5`}
        >
          {n <= value ? "‚òÖ" : "‚òÜ"}
        </button>
      ))}
    </div>
  );
}

function AnswerBlock({
  title,
  text,
  onCopy,
  liked,
  onLike,
  onDislike,
}: {
  title: string;
  text: string;
  onCopy: () => void;
  liked: "like" | "dislike" | "";
  onLike: () => void;
  onDislike: () => void;
}) {
  if (!text) return null;
  return (
    <div className="border rounded p-3 bg-white">
      <div className="font-medium mb-2">{title}</div>
      <div className="whitespace-pre-wrap text-sm leading-relaxed">{text}</div>
      <div className="flex gap-3 mt-3 text-sm">
        <button type="button" onClick={onCopy} className="px-2 py-1 border rounded">
          üìã Kopiera
        </button>
        <button
          type="button"
          onClick={onLike}
          className={`px-2 py-1 border rounded ${liked === "like" ? "bg-green-50" : ""}`}
        >
          üëç Gilla
        </button>
        <button
          type="button"
          onClick={onDislike}
          className={`px-2 py-1 border rounded ${liked === "dislike" ? "bg-red-50" : ""}`}
        >
          üëé Ogilla
        </button>
      </div>
    </div>
  );
}

export default function QAPage() {
  // Language toggle
  const [lang, setLang] = useState<"sv" | "en">("sv");

  // Select data
  const [companies, setCompanies] = useState<Item[]>([]);
  const [profiles, setProfiles] = useState<Item[]>([]);
  const [companyId, setCompanyId] = useState("");
  const [profileId, setProfileId] = useState("");

  // Inputs
  const GOAL_OPTS = useMemo(
    () => ["Kvalificera", "Boka samtal/tid senare", "S√§lj/Avslut"],
    []
  );
  const SEG_OPTS = useMemo(
    () => ["Enpersonshush√•ll", "Tv√•personshush√•ll", "Familjehush√•ll"],
    []
  );
  const CHANNEL_OPTS = useMemo(() => ["Telefon", "SMS", "E-post"], []);

  const [goal, setGoal] = useState("");
  const [segment, setSegment] = useState("");
  const [channel, setChannel] = useState("");

  const [valueLine, setValueLine] = useState(""); // ‚ÄúV√§rderad rad (valfritt)‚Äù
  const [address, setAddress] = useState("");
  const [question, setQuestion] = useState("");

  // Submit state
  const [submitting, setSubmitting] = useState(false);

  // Outputs
  const [oneLiner, setOneLiner] = useState("");
  const [why, setWhy] = useState("");
  const [ack, setAck] = useState("");
  const [shortScript, setShortScript] = useState("");
  const [fullScript, setFullScript] = useState("");
  const [math, setMath] = useState("");
  const [nextStep, setNextStep] = useState("");

  // Feedback state per block
  const [likes, setLikes] = useState<Record<string, "like" | "dislike" | "">>({
    one_liner: "",
    why: "",
    ack: "",
    short_script: "",
    full_script: "",
    math: "",
    next_step: "",
  });
  const [rating, setRating] = useState(0);

  // Companies & profiles
  useEffect(() => {
    (async () => {
      try {
        const [cRes, pRes] = await Promise.all([
          fetch("/api/qa/companies").then((r) => r.json()).catch(() => ({ items: [] })),
          fetch("/api/qa/profiles").then((r) => r.json()).catch(() => ({ items: [] })),
        ]);
        setCompanies(Array.isArray(cRes.items) ? cRes.items : []);
        setProfiles(Array.isArray(pRes.items) ? pRes.items : []);
      } catch {
        setCompanies([]);
        setProfiles([]);
      }
    })();
  }, []);

  const onKeyDownSubmit = (
    e: KeyboardEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      onSubmit();
    }
  };

  // --------- NEW: geo state + map loader ----------
  const [geo, setGeo] = useState<GeoResp | null>(null);
  const [geoLoading, setGeoLoading] = useState(false);
  const [geoError, setGeoError] = useState<string | undefined>(undefined);
  const { isLoaded: mapLoaded } = useLoadScript({
    googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!,
    libraries: ["places"],
  });

  async function fetchGeoIfAddress() {
    if (!address.trim()) {
      setGeo(null);
      setGeoError(undefined);
      return;
    }
    try {
      setGeoLoading(true);
      setGeoError(undefined);
      setGeo(null);
      const r = await fetch(
        `/api/geo/pois?address=${encodeURIComponent(address)}&radius_m=600&lang=${lang}`,
        { cache: "no-store" }
      );
      if (!r.ok) {
        const tx = await r.text().catch(() => "");
        throw new Error(tx || `HTTP ${r.status}`);
      }
      const json: GeoResp = await r.json();
      setGeo(json);
    } catch (e: any) {
      setGeoError(e?.message || "geo_failed");
    } finally {
      setGeoLoading(false);
    }
  }

  async function onSubmit() {
    if (submitting) return;
    if (!question.trim()) return;
    setSubmitting(true);

    // Kick off geo fetch in parallel (if address present)
    const geoPromise = fetchGeoIfAddress();

    try {
      const res = await fetch("/api/qa/ask", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          lang,
          companyId: companyId || undefined,
          profileId: profileId || undefined,
          goal: goal || undefined,
          segment: segment || undefined,
          channel: channel || undefined,
          valueLine: valueLine || undefined,
          address: address || undefined,
          question: question.trim(),
        }),
      });
      const j = await res.json().catch(() => null);
      if (!res.ok || !j?.ok) {
        console.error("ask failed", j);
        return;
      }
      setOneLiner(j.one_liner || "");
      setWhy(j.why || "");
      setAck(j.ack || "");
      setShortScript(j.short_script || "");
      setFullScript(j.full_script || "");
      setMath(j.math || "");
      setNextStep(j.next_step || "");
      // reset feedback
      setLikes({
        one_liner: "",
        why: "",
        ack: "",
        short_script: "",
        full_script: "",
        math: "",
        next_step: "",
      });
      setRating(0);
    } finally {
      // Ensure geo finished too (even if ask failed)
      await geoPromise.catch(() => {});
      setSubmitting(false);
    }
  }

  const copyText = async (t: string) => {
    try {
      await navigator.clipboard.writeText(t || "");
    } catch {}
  };

  const FieldLabel = ({ children }: { children: React.ReactNode }) => (
    <div className="text-sm font-medium text-slate-700 mb-1">{children}</div>
  );

  // ---- map helpers ----
  const center = geo?.center ? { lat: geo.center.lat, lng: geo.center.lon } : undefined;
  const hasPois = Array.isArray(geo?.pois) && (geo?.pois?.length || 0) > 0;
  const greenIcon = {
    url: "https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png",
    scaledSize: { width: 32, height: 32 } as unknown as google.maps.Size,
  };

  return (
    <div className="max-w-3xl mx-auto p-4 md:p-6">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-semibold">Q&amp;A</h1>
        <div className="flex gap-2">
          <button
            type="button"
            className={`px-3 py-1 rounded border ${lang === "sv" ? "bg-slate-900 text-white" : ""}`}
            onClick={() => setLang("sv")}
          >
            SV
          </button>
          <button
            type="button"
            className={`px-3 py-1 rounded border ${lang === "en" ? "bg-slate-900 text-white" : ""}`}
            onClick={() => setLang("en")}
          >
            EN
          </button>
        </div>
      </div>

      {/* Row 1: Company + Profile */}
      <div className="grid md:grid-cols-2 gap-3 mb-3">
        <div>
          <FieldLabel>F√∂retag</FieldLabel>
          <select
            className="w-full border rounded px-3 py-2"
            value={companyId}
            onChange={(e) => setCompanyId(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          >
            <option value="">{lang === "en" ? "Select company‚Ä¶" : "V√§lj f√∂retag‚Ä¶"}</option>
            {companies.map((c) => (
              <option key={c.id} value={c.id}>
                {c.name}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Profil</FieldLabel>
          <select
            className="w-full border rounded px-3 py-2"
            value={profileId}
            onChange={(e) => setProfileId(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          >
            <option value="">{lang === "en" ? "Select profile‚Ä¶" : "V√§lj profil‚Ä¶"}</option>
            {profiles.map((p) => (
              <option key={p.id} value={p.id}>
                {p.name}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Row 2: Goal + Segment + Channel */}
      <div className="grid md:grid-cols-3 gap-3 mb-3">
        <div>
          <FieldLabel>M√•l (valfritt)</FieldLabel>
          <select
            value={goal}
            onChange={(e) => setGoal(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select goal‚Ä¶" : "V√§lj m√•l‚Ä¶"}</option>
            {GOAL_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Segment (valfritt)</FieldLabel>
          <select
            value={segment}
            onChange={(e) => setSegment(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select segment‚Ä¶" : "V√§lj segment‚Ä¶"}</option>
            {SEG_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Kanal (valfritt)</FieldLabel>
          <select
            value={channel}
            onChange={(e) => setChannel(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select channel‚Ä¶" : "V√§lj kanal‚Ä¶"}</option>
            {CHANNEL_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Row 3: Value line + Address */}
      <div className="grid md:grid-cols-2 gap-3 mb-3">
        <div>
          <FieldLabel>V√§rderad rad (valfritt)</FieldLabel>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            placeholder={
              lang === "en"
                ? "Example: reduce your electricity bill up to 30 percent per month"
                : "Exempel: s√§nk din elr√§kning upp till 30 % per m√•nad"
            }
            value={valueLine}
            onChange={(e) => setValueLine(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          />
        </div>

        <div>
          <FieldLabel>Adress (valfritt)</FieldLabel>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            placeholder={
              lang === "en"
                ? "Example: S√∂dra F√∂rstadsgatan 1, Malm√∂"
                : "Exempel: S√∂dra F√∂rstadsgatan 1, Malm√∂"
            }
            value={address}
            onChange={(e) => setAddress(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          />
        </div>
      </div>

      {/* Row 4: Question full width */}
      <div className="mb-2">
        <FieldLabel>Fr√•ga / Signal</FieldLabel>
        <textarea
          className="w-full border rounded px-3 py-2 min-h-[90px]"
          placeholder={
            lang === "en"
              ? 'How do I handle "I don‚Äôt have time"?'
              : 'Hur hanterar jag ‚Äùjag har inte tid‚Äù?'
          }
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              onSubmit();
            }
          }}
        />
      </div>

      {/* Submit centered */}
      <div className="flex justify-center mb-6">
        <button
          type="button"
          onClick={onSubmit}
          disabled={submitting || !question.trim()}
          className="px-4 py-2 rounded bg-[var(--brand)] text-white disabled:opacity-50"
        >
          {lang === "en" ? "Get answer" : "H√§mta svar"}
        </button>
      </div>

      {/* NEW: Geo panel (shows only when address searched) */}
      {(address.trim() && (geo || geoLoading || geoError)) ? (
        <div className="mb-6 grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">
                {lang === "en" ? "Electricity info" : "El-info"}
              </div>
              <GeoElectricityInfo
                address={address}
                center={geo?.center ? { lat: geo.center.lat, lon: geo.center.lon } : undefined}
              />
            </div>

            {geoError && (
              <div className="text-red-600 text-sm">{geoError}</div>
            )}

            {Array.isArray(geo?.pois) && geo!.pois!.length > 0 && (
              <div className="border rounded p-3 bg-slate-50">
                <div className="text-sm text-slate-600">
                  {lang === "en" ? "Nearby (businesses)" : "I n√§rheten (f√∂retag)"}
                </div>
                <ul className="list-disc pl-5 text-sm">
                  {geo!.pois!.slice(0, 10).map((p, i) => {
                    const dist =
                      typeof p.distance_m === "number"
                        ? `${Math.round(p.distance_m)} m`
                        : "";
                    const rating =
                      typeof p.rating === "number" ? ` ‚Ä¢ ‚òÖ ${p.rating}` : "";
                    return (
                      <li key={i}>
                        <span className="font-medium">{p.name || "‚Äî"}</span>
                        {p.type ? <> ‚Ä¢ {p.type}</> : null}
                        {dist ? <> ‚Ä¢ {dist}</> : null}
                        {rating ? <>{rating}</> : null}
                      </li>
                    );
                  })}
                </ul>
              </div>
            )}
          </div>

          <div>
            <div className="rounded-lg overflow-hidden border" style={{ height: 320 }}>
              {mapLoaded && center ? (
                <GoogleMap
                  center={center}
                  zoom={16}
                  mapContainerStyle={{ width: "100%", height: "100%" }}
                  options={{ streetViewControl: false, mapTypeControl: false }}
                >
                  <Marker position={center} icon={greenIcon} title={address} />
                  {hasPois &&
                    geo!.pois!.slice(0, 30).map((p, i) => (
                      <Marker
                        key={i}
                        position={{ lat: p.lat, lng: p.lon }}
                        title={p.name}
                      />
                    ))}
                </GoogleMap>
              ) : (
                <div className="h-full grid place-items-center text-slate-500 bg-slate-50">
                  {geoLoading
                    ? (lang === "en" ? "Loading map‚Ä¶" : "Laddar karta‚Ä¶")
                    : (lang === "en" ? "No map" : "Ingen karta")}
                </div>
              )}
            </div>
          </div>
        </div>
      ) : null}

      {/* Answers */}
      {(oneLiner || why || ack || shortScript || fullScript || math || nextStep) && (
        <div className="space-y-3">
          <AnswerBlock
            title="One-liner"
            text={oneLiner}
            onCopy={() => copyText(oneLiner)}
            liked={likes.one_liner}
            onLike={() => setLikes((l) => ({ ...l, one_liner: l.one_liner === "like" ? "" : "like" }))}
            onDislike={() =>
              setLikes((l) => ({ ...l, one_liner: l.one_liner === "dislike" ? "" : "dislike" }))
            }
          />
          <AnswerBlock
            title="Varf√∂r"
            text={why}
            onCopy={() => copyText(why)}
            liked={likes.why}
            onLike={() => setLikes((l) => ({ ...l, why: l.why === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, why: l.why === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="Bekr√§fta"
            text={ack}
            onCopy={() => copyText(ack)}
            liked={likes.ack}
            onLike={() => setLikes((l) => ({ ...l, ack: l.ack === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, ack: l.ack === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="Kort manus"
            text={shortScript}
            onCopy={() => copyText(shortScript)}
            liked={likes.short_script}
            onLike={() =>
              setLikes((l) => ({ ...l, short_script: l.short_script === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({
                ...l,
                short_script: l.short_script === "dislike" ? "" : "dislike",
              }))
            }
          />
          <AnswerBlock
            title="Fullt manus"
            text={fullScript}
            onCopy={() => copyText(fullScript)}
            liked={likes.full_script}
            onLike={() =>
              setLikes((l) => ({ ...l, full_script: l.full_script === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({
                ...l,
                full_script: l.full_script === "dislike" ? "" : "dislike",
              }))
            }
          />
          <AnswerBlock
            title="Utr√§kning"
            text={math}
            onCopy={() => copyText(math)}
            liked={likes.math}
            onLike={() => setLikes((l) => ({ ...l, math: l.math === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, math: l.math === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="N√§sta steg"
            text={nextStep}
            onCopy={() => copyText(nextStep)}
            liked={likes.next_step}
            onLike={() =>
              setLikes((l) => ({ ...l, next_step: l.next_step === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({ ...l, next_step: l.next_step === "dislike" ? "" : "dislike" }))
            }
          />

          {/* Overall rating */}
          <div className="border rounded p-3 bg-white">
            <div className="font-medium mb-2">
              {lang === "en" ? "Rating (whole answer)" : "Betyg (hela svaret)"}
            </div>
            <StarRating value={rating} onChange={setRating} onEnter={() => {}} />
          </div>
        </div>
      )}
    </div>
  );
}
\n===== app/app/layout.tsx =====
// app/app/layout.tsx
import { ReactNode } from "react";
import { redirect } from "next/navigation";
import AppShell from "@/components/AppShell";
import { supabaseServer } from "@/lib/supabaseServer";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

export default async function AppLayout({ children }: { children: ReactNode }) {
  const supabase = supabaseServer; // ‚úÖ FIXED
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error || !user) redirect("/auth");

  return <AppShell>{children}</AppShell>;
}
\n===== app/app/error.tsx =====
"use client";

export default function AppError({ error, reset }: { error: unknown; reset: () => void }) {
  console.error("[/app] error boundary:", error);
  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">Something went wrong</h1>
      <p className="text-slate-600 text-sm">
        Please try again. If it keeps happening, sign out and back in.
      </p>
      <div className="flex gap-2">
        <button
          className="px-4 py-2 rounded bg-black text-white"
          onClick={() => reset()}
        >
          Try again
        </button>
        <a className="px-4 py-2 rounded border" href="/auth/signout">
          Sign out
        </a>
      </div>
    </div>
  );
}
\n===== app/app/profiles/page.tsx =====
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type Profile = {
  id?: string
  name: string
  language?: string
  tone?: string
  goals?: string
  persona_hints?: string
}

export default function ProfilesPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<Profile[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<Profile | null>(null)
  const [form, setForm] = useState<Profile>({
    name: '',
    language: '',
    tone: '',
    goals: '',
    persona_hints: '',
  })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load(){
    setLoading(true); setError(null)
    try{
      const r = await fetch('/api/profiles', { headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load profiles failed:', e)
      setError(t(lang,'common.error')); setRows([])
    }finally{ setLoading(false) }
  }

  useEffect(()=>{ load() },[]) // eslint-disable-line react-hooks/exhaustive-deps
  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){
    setEditing(null)
    setForm({ name:'', language:'', tone:'', goals:'', persona_hints:'' })
    setOpen(true)
  }
  function openEdit(p: Profile){
    setEditing(p)
    setForm({
      id: p.id,
      name: p.name || '',
      language: p.language || '',
      tone: p.tone || '',
      goals: p.goals || '',
      persona_hints: p.persona_hints || '',
    })
    setOpen(true)
  }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/profiles/${editing.id}` : '/api/profiles'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type':'application/json', accept:'application/json' },
        body: JSON.stringify(form)
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save profile failed:', e)
      alert(t(lang,'common.error'))
    }finally{ setSaving(false) }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/profiles/${id}`, { method:'DELETE', headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete profile failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'profiles.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'profiles.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'profiles.list.empty')}</div>}

      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {rows.map(p=>(
          <div key={p.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{p.name || '‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={()=>openEdit(p)}>{t(lang,'common.edit')}</button>
                <ConfirmDialog onConfirm={()=>del(p.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm space-y-1 text-slate-700">
              {p.language && <div><b>{t(lang,'profiles.form.language')}:</b> {p.language}</div>}
              {p.tone && <div><b>{t(lang,'profiles.form.tone')}:</b> {p.tone}</div>}
              {p.goals && <div><b>{t(lang,'profiles.form.goals')}:</b> {p.goals}</div>}
              {p.persona_hints && <div><b>{t(lang,'profiles.form.persona')}:</b> {p.persona_hints}</div>}
            </div>
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'profiles.edit') : t(lang,'profiles.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'profiles.form.name')}
              <input
                className="border rounded p-2 w-full"
                value={form.name}
                placeholder={t(lang,'profiles.ph.name')}
                onChange={e=>setForm({...form, name:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.language')}
              <input
                className="border rounded p-2 w-full"
                value={form.language}
                placeholder={t(lang,'profiles.ph.language')}
                onChange={e=>setForm({...form, language:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.tone')}
              <input
                className="border rounded p-2 w-full"
                value={form.tone}
                placeholder={t(lang,'profiles.ph.tone')}
                onChange={e=>setForm({...form, tone:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.goals')}
              <input
                className="border rounded p-2 w-full"
                value={form.goals}
                placeholder={t(lang,'profiles.ph.goals')}
                onChange={e=>setForm({...form, goals:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.persona')}
              <textarea
                className="border rounded p-2 w-full min-h-[90px]"
                value={form.persona_hints}
                placeholder={t(lang,'profiles.ph.persona')}
                onChange={e=>setForm({...form, persona_hints:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}
\n===== app/app/events/page.tsx =====
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type EventItem = {
  id?: string
  ts?: string        // ISO date-time
  title?: string
  type?: string
  notes?: string
  tags?: string
}

export default function EventsPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<EventItem[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<EventItem | null>(null)
  const [form, setForm] = useState<EventItem>({
    ts: new Date().toISOString().slice(0,16),
    title: '',
    type: '',
    notes: '',
    tags: ''
  })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load(){
    setLoading(true)
    setError(null)
    try{
      const r = await fetch('/api/events', { headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load events failed:', e)
      setRows([])
      setError(t(lang,'common.error'))
    }finally{
      setLoading(false)
    }
  }

  useEffect(()=>{ load() /* on mount */ },[]) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){
    setEditing(null)
    setForm({
      ts: new Date().toISOString().slice(0,16),
      title: '',
      type: '',
      notes: '',
      tags: ''
    })
    setOpen(true)
  }
  function openEdit(e: EventItem){
    setEditing(e)
    setForm({
      id: e.id,
      ts: (e.ts||'').slice(0,16),
      title: e.title||'',
      type: e.type||'',
      notes: e.notes||'',
      tags: e.tags||'',
    })
    setOpen(true)
  }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/events/${editing.id}` : '/api/events'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', accept: 'application/json' },
        body: JSON.stringify(form)
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save event failed:', e)
      alert(t(lang,'common.error'))
    }finally{
      setSaving(false)
    }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/events/${id}`, { method: 'DELETE', headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete event failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'events.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'events.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'events.list.empty')}</div>}

      <div className="border rounded overflow-x-auto">
        <table className="w-full text-sm">
          <thead className="bg-slate-50">
            <tr>
              <th className="p-2">{t(lang,'events.table.date')}</th>
              <th className="p-2">{t(lang,'events.table.title')}</th>
              <th className="p-2">{t(lang,'events.table.type')}</th>
              <th className="p-2">{t(lang,'events.table.notes')}</th>
              <th className="p-2">{t(lang,'events.table.tags')}</th>
              <th className="p-2"></th>
            </tr>
          </thead>
          <tbody>
            {rows.map(e=>(
              <tr key={e.id} className="border-t">
                <td className="p-2 whitespace-nowrap">{e.ts ? new Date(e.ts).toLocaleString() : '‚Äî'}</td>
                <td className="p-2">{e.title||'‚Äî'}</td>
                <td className="p-2">{e.type||'‚Äî'}</td>
                <td className="p-2">{e.notes||'‚Äî'}</td>
                <td className="p-2">{e.tags||'‚Äî'}</td>
                <td className="p-2 text-right whitespace-nowrap">
                  <button className="mr-2 underline" onClick={()=>openEdit(e)}>{t(lang,'common.edit')}</button>
                  <ConfirmDialog onConfirm={()=>del(e.id)}>
                    <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                  </ConfirmDialog>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'events.edit') : t(lang,'events.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'events.form.date')}
              <input
                type="datetime-local"
                className="border rounded p-2 w-full"
                value={form.ts}
                onChange={e=>setForm({...form, ts:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.title')}
              <input
                className="border rounded p-2 w-full"
                value={form.title}
                placeholder={t(lang,'events.ph.title')}
                onChange={e=>setForm({...form, title:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.type')}
              <input
                className="border rounded p-2 w-full"
                value={form.type}
                placeholder={t(lang,'events.ph.type')}
                onChange={e=>setForm({...form, type:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.notes')}
              <textarea
                className="border rounded p-2 w-full min-h-[90px]"
                value={form.notes}
                placeholder={t(lang,'events.ph.notes')}
                onChange={e=>setForm({...form, notes:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.tags')}
              <input
                className="border rounded p-2 w-full"
                value={form.tags}
                placeholder={t(lang,'events.ph.tags')}
                onChange={e=>setForm({...form, tags:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}
\n===== app/app/upload/components/PersonaList.tsx =====
'use client'
import { useEffect, useState } from 'react'
import { MoreVertical, Edit, Trash } from 'lucide-react'

export default function PersonaList() {
  const [personas, setPersonas] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [menuOpen, setMenuOpen] = useState<string | null>(null)

  async function fetchPersonas() {
    const res = await fetch('/api/get-personas')
    const data = await res.json()
    const unique = Array.from(new Map(data.personas.map(p => [p.name + p.type, p])).values())
    setPersonas(unique || [])
    setLoading(false)
  }

  async function handleDelete(id: string) {
    if (!confirm('Delete this persona?')) return
    const res = await fetch('/api/delete-persona', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id }),
    })
    const data = await res.json()
    if (data.success) setPersonas(personas.filter(p => p.id !== id))
    else alert('‚ùå Error: ' + data.error)
  }

  useEffect(() => {
    fetchPersonas()
    const handleClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement
      if (!target.closest('.persona-menu') && !target.closest('.persona-menu-btn')) {
        setMenuOpen(null)
      }
    }
    window.addEventListener('click', handleClick)
    return () => window.removeEventListener('click', handleClick)
  }, [])

  if (loading)
    return (
      <div className="grid grid-cols-2 gap-4 mt-6">
        {Array.from({ length: 4 }).map((_, i) => (
          <div
            key={i}
            className="h-40 bg-gray-100 rounded-lg animate-pulse border border-gray-200"
          ></div>
        ))}
      </div>
    )

  if (!personas.length)
    return <p className="text-gray-400 text-center">No personas yet.</p>

  const customers = personas.filter(p => p.type === 'customer')
  const salespeople = personas.filter(p => p.type === 'salesperson')

  const renderCard = (p: any) => (
    <div
      key={p.id}
      className="border border-gray-300 rounded-lg p-4 bg-white shadow-sm relative hover:shadow-md transition-all"
    >
      <div className="flex justify-between items-start">
        <div>
          <h4 className="font-semibold text-black text-base">{p.name}</h4>
          <p className="text-sm text-gray-700 mb-2">{p.description}</p>
          <p className="text-sm text-gray-600"><strong>Behavior:</strong> {p.behavior || 'N/A'}</p>
          <p className="text-sm text-gray-600"><strong>Tone:</strong> {p.tone || 'N/A'}</p>
          <p className="text-sm text-gray-600"><strong>Motivation:</strong> {p.motivation || 'N/A'}</p>
          <p className="text-sm text-gray-600"><strong>Communication Style:</strong> {p.communication_style || 'N/A'}</p>

          {p.pain_points?.length > 0 && (
            <>
              <p className="text-sm text-gray-700 mt-2"><strong>Pain Points:</strong></p>
              <ul className="list-disc pl-4 text-sm text-gray-600">
                {p.pain_points.map((o: string, i: number) => <li key={i}>{o}</li>)}
              </ul>
            </>
          )}

          {p.buying_triggers?.length > 0 && (
            <>
              <p className="text-sm text-gray-700 mt-2"><strong>Buying Triggers:</strong></p>
              <ul className="list-disc pl-4 text-sm text-gray-600">
                {p.buying_triggers.map((o: string, i: number) => <li key={i}>{o}</li>)}
              </ul>
            </>
          )}

          {p.objection_examples?.length > 0 && (
            <>
              <p className="text-sm text-gray-700 mt-2"><strong>Objection Examples:</strong></p>
              <ul className="list-disc pl-4 text-sm text-gray-600">
                {p.objection_examples.map((o: string, i: number) => <li key={i}>{o}</li>)}
              </ul>
            </>
          )}
        </div>

        {/* Menu */}
        <div className="relative persona-menu">
          <button
            onClick={e => {
              e.stopPropagation()
              setMenuOpen(menuOpen === p.id ? null : p.id)
            }}
            className="persona-menu-btn text-gray-800 hover:text-black p-1"
          >
            <MoreVertical size={18} />
          </button>
          {menuOpen === p.id && (
            <div
              className="absolute right-0 mt-2 w-36 bg-white border border-gray-200 rounded-lg shadow-lg z-10"
              onClick={e => e.stopPropagation()}
            >
              <button className="flex items-center gap-2 w-full text-left px-4 py-2 text-sm text-black hover:bg-gray-100">
                <Edit size={14} /> Edit
              </button>
              <button
                onClick={() => handleDelete(p.id)}
                className="flex items-center gap-2 w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-gray-100"
              >
                <Trash size={14} /> Delete
              </button>
            </div>
          )}
        </div>
      </div>
    </div>
  )

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
      <div>
        <h3 className="text-lg font-semibold text-black mb-3">Customers</h3>
        {customers.map(renderCard)}
      </div>
      <div>
        <h3 className="text-lg font-semibold text-black mb-3">Salespeople</h3>
        {salespeople.map(renderCard)}
      </div>
    </div>
  )
}
\n===== app/app/upload/components/UploadForm.tsx =====
'use client'

import { useState, DragEvent } from 'react'

export default function UploadForm() {
  const [file, setFile] = useState<File | null>(null)
  const [dragOver, setDragOver] = useState(false)
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState('')

  function handleFileSelect(e: React.ChangeEvent<HTMLInputElement>) {
    if (e.target.files?.[0]) setFile(e.target.files[0])
  }

  function handleDrop(e: DragEvent<HTMLDivElement>) {
    e.preventDefault()
    setDragOver(false)
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      setFile(e.dataTransfer.files[0])
    }
  }

  function handleDragOver(e: DragEvent<HTMLDivElement>) {
    e.preventDefault()
    setDragOver(true)
  }

  function handleDragLeave() {
    setDragOver(false)
  }

  async function handleUpload() {
    if (!file) return alert('Please choose a file first.')
    setLoading(true)
    setMessage('')
    try {
      const formData = new FormData()
      formData.append('file', file)
      const res = await fetch('/api/upload', { method: 'POST', body: formData })
      const data = await res.json()
      if (data.success) {
        setMessage('‚úÖ File uploaded successfully!')
        setFile(null)
      } else {
        setMessage('‚ùå ' + data.error)
      }
    } catch (err: any) {
      setMessage('‚ùå Upload failed: ' + err.message)
    } finally {
      setLoading(false)
    }
  }

  async function handleTranscribe() {
    setLoading(true)
    setMessage('')
    try {
      const res = await fetch('/api/transcribe', { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        setMessage('‚úÖ Transcription complete!')
      } else {
        setMessage('‚ùå ' + data.error)
      }
    } catch (err: any) {
      setMessage('‚ùå ' + err.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="flex flex-col items-center gap-4 p-6 border border-black rounded-xl bg-white shadow-sm">
      {/* Drag & Drop area */}
      <div
        onDrop={handleDrop}
        onDragOver={handleDragOver}
        onDragLeave={handleDragLeave}
        className={`w-full border-2 border-dashed rounded-xl p-10 text-center transition-all cursor-pointer ${
          dragOver ? 'border-blue-600 bg-blue-50' : 'border-black bg-white'
        }`}
        onClick={() => document.getElementById('fileInput')?.click()}
      >
        <p className="text-black">
          {file ? (
            <strong>{file.name}</strong>
          ) : (
            <>
              <span className="block text-lg font-semibold">
                Drag & drop your file here
              </span>
              <span className="text-sm text-black/60">
                or click below to choose a file
              </span>
            </>
          )}
        </p>
        <input
          id="fileInput"
          type="file"
          accept="audio/*"
          onChange={handleFileSelect}
          className="hidden"
        />
      </div>

      {/* Action buttons */}
      <div className="flex gap-4">
        <button
          onClick={handleUpload}
          disabled={loading || !file}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {loading ? 'Uploading...' : 'Upload'}
        </button>
        <button
          onClick={handleTranscribe}
          disabled={loading}
          className="bg-black text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {loading ? 'Working...' : 'Transcribe'}
        </button>
      </div>

      {message && <p className="text-sm mt-2 text-black">{message}</p>}
    </div>
  )
}
\n===== app/app/upload/components/CallList.tsx =====
'use client'

import { useEffect, useState, useRef } from 'react'
import { MoreVertical, Trash, Download, FileAudio, Rewind, FastForward } from 'lucide-react'

export default function CallList() {
  const [calls, setCalls] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [menuOpen, setMenuOpen] = useState<string | null>(null)
  const audioRefs = useRef<{ [key: string]: HTMLAudioElement | null }>({})
  const menuRef = useRef<HTMLDivElement | null>(null)

  async function fetchCalls() {
    const res = await fetch('/api/get-calls')
    const data = await res.json()
    setCalls(data.calls || [])
    setLoading(false)
  }

  async function handleTranscribe(id: string) {
    const res = await fetch(`/api/transcribe?id=${id}`, { method: 'POST' })
    const data = await res.json()
    if (data.success) alert('‚úÖ Transcription complete!')
    else alert('‚ùå Error: ' + data.error)
  }

  async function handleDelete(id: string, filePath: string) {
    if (!confirm('Are you sure you want to delete this call?')) return

    const res = await fetch('/api/delete-call', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ id, file_path: filePath }),
    })

    const data = await res.json()
    if (data.success) setCalls(calls.filter(c => c.id !== id))
    else alert('‚ùå Error: ' + data.error)
  }

  function skipTime(id: string, seconds: number) {
    const audio = audioRefs.current[id]
    if (audio) audio.currentTime += seconds
  }

  // Close menu when clicking outside
  useEffect(() => {
    function handleClickOutside(event: MouseEvent) {
      if (menuRef.current && !menuRef.current.contains(event.target as Node)) {
        setMenuOpen(null)
      }
    }
    document.addEventListener('mousedown', handleClickOutside)
    return () => document.removeEventListener('mousedown', handleClickOutside)
  }, [])

  useEffect(() => {
    fetchCalls()
  }, [])

  if (loading) return <p className="text-gray-500">Loading calls...</p>
  if (!calls.length) return <p className="text-gray-400">No calls found.</p>

  return (
    <div className="space-y-3">
      {calls.map(call => {
        const fileUrl = `https://${process.env.NEXT_PUBLIC_SUPABASE_URL!.replace(
          'https://',
          ''
        )}/storage/v1/object/public/calls/${call.file_path}`

        return (
          <div
            key={call.id}
            className="border p-3 rounded-lg bg-white shadow-sm relative hover:shadow-md transition-all"
          >
            <div className="flex justify-between items-center">
              <div>
                <p className="font-semibold text-gray-800 text-sm truncate w-64">
                  {call.file_path}
                </p>
                <p className="text-xs text-gray-500">{call.status}</p>
              </div>

              {/* ‚ãØ menu */}
              <div className="relative" ref={menuRef}>
                <button
                  onClick={() =>
                    setMenuOpen(menuOpen === call.id ? null : call.id)
                  }
                  className="text-gray-800 hover:text-black p-2"
                >
                  <MoreVertical size={18} />
                </button>

                {menuOpen === call.id && (
                  <div className="absolute right-0 mt-2 w-44 bg-white border border-gray-200 rounded-lg shadow-lg z-10">
                    <button
                      onClick={() => handleTranscribe(call.id)}
                      className="flex items-center gap-2 w-full text-left px-4 py-2 hover:bg-gray-100 text-sm text-black"
                    >
                      <FileAudio size={15} className="text-black" />
                      <span className="text-black">Transcribe</span>
                    </button>
                    <a
                      href={fileUrl}
                      download
                      className="flex items-center gap-2 w-full text-left px-4 py-2 hover:bg-gray-100 text-sm text-black"
                    >
                      <Download size={15} className="text-black" />
                      <span className="text-black">Download</span>
                    </a>
                    <button
                      onClick={() => handleDelete(call.id, call.file_path)}
                      className="flex items-center gap-2 w-full text-left px-4 py-2 hover:bg-gray-100 text-sm text-red-600"
                    >
                      <Trash size={15} />
                      <span>Delete</span>
                    </button>
                  </div>
                )}
              </div>
            </div>

            {/* üéß Audio controls with skip icons */}
            <div className="mt-3 flex items-center gap-3">
              <button
                onClick={() => skipTime(call.id, -5)}
                className="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm flex items-center gap-1 text-black"
              >
                <Rewind size={14} /> 5s
              </button>
              <audio
                controls
                className="flex-1"
                ref={el => (audioRefs.current[call.id] = el)}
                src={fileUrl}
              />
              <button
                onClick={() => skipTime(call.id, 5)}
                className="bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-sm flex items-center gap-1 text-black"
              >
                <FastForward size={14} /> 5s
              </button>
            </div>
          </div>
        )
      })}
    </div>
  )
}
\n===== app/app/upload/components/GeneratePersonas.tsx =====
'use client'
import { useState } from 'react'

export default function GeneratePersonas() {
  const [loading, setLoading] = useState(false)
  const [message, setMessage] = useState('')

  async function handleGenerate() {
    setLoading(true)
    setMessage('')
    try {
      const res = await fetch('/api/generate-behavior-personas', { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        setMessage('‚úÖ Personas generated successfully.')
      } else {
        setMessage('‚ùå ' + data.error)
      }
    } catch (err: any) {
      setMessage('‚ùå ' + err.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="flex flex-col items-center gap-3">
      <div className="flex gap-4">
        <button
          onClick={handleGenerate}
          disabled={loading}
          className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {loading ? 'Working...' : 'Generate / Update Personas'}
        </button>
      </div>
      {message && <p className="text-sm text-black">{message}</p>}
    </div>
  )
}
\n===== app/app/upload/components/PersonasPanel.tsx =====
'use client'
import { useState, useEffect } from 'react'
import { MoreVertical, Edit, Trash } from 'lucide-react'

export default function PersonasPanel() {
  const [personas, setPersonas] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [generating, setGenerating] = useState(false)
  const [message, setMessage] = useState('')
  const [menuOpen, setMenuOpen] = useState<string | null>(null)

  async function fetchPersonas() {
    try {
      const res = await fetch('/api/get-personas')
      const data = await res.json()
      setPersonas(data.personas || [])
    } catch (e) {
      console.error('Failed to fetch personas:', e)
    } finally {
      setLoading(false)
    }
  }

  async function handleGenerate() {
    setGenerating(true)
    setMessage('')
    try {
      const res = await fetch('/api/generate-behavior-personas', { method: 'POST' })
      const data = await res.json()
      if (data.success) {
        setMessage('‚úÖ Personas generated successfully!')
        fetchPersonas()
      } else {
        setMessage('‚ùå ' + data.error)
      }
    } catch (err: any) {
      setMessage('‚ùå ' + err.message)
    } finally {
      setGenerating(false)
    }
  }

  async function handleDelete(id: string) {
    if (!confirm('Are you sure you want to delete this persona?')) return
    try {
      const res = await fetch('/api/delete-persona', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ id }),
      })
      const data = await res.json()
      if (data.success) {
        setPersonas(personas.filter(p => p.id !== id))
      } else alert('‚ùå ' + data.error)
    } catch (e) {
      alert('‚ùå Delete failed')
    }
  }

  useEffect(() => {
    fetchPersonas()
  }, [])

  const customers = personas.filter(p => p.role === 'customer')
  const salespeople = personas.filter(p => p.role === 'salesperson')

  return (
    <section className="bg-white rounded-2xl p-6 shadow-sm border border-gray-200">
      {/* Centered Generate Button */}
      <div className="flex justify-center mb-6">
        <button
          onClick={handleGenerate}
          disabled={generating}
          className="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700 disabled:opacity-60"
        >
          {generating ? 'Generating...' : 'Generate Personas'}
        </button>
      </div>

      {message && (
        <p className={`text-center mb-4 ${message.startsWith('‚úÖ') ? 'text-green-600' : 'text-red-600'}`}>
          {message}
        </p>
      )}

      {/* Loading shimmer */}
      {loading ? (
        <div className="animate-pulse grid grid-cols-1 md:grid-cols-2 gap-6">
          {[...Array(4)].map((_, i) => (
            <div key={i} className="p-4 border border-gray-200 rounded-xl bg-gray-50">
              <div className="h-4 bg-gray-200 rounded w-1/3 mb-2"></div>
              <div className="h-3 bg-gray-200 rounded w-2/3 mb-1"></div>
              <div className="h-3 bg-gray-200 rounded w-1/2"></div>
            </div>
          ))}
        </div>
      ) : personas.length === 0 ? (
        <p className="text-center text-gray-500">No personas yet.</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Customer Personas */}
          <div>
            <h3 className="text-lg font-semibold text-blue-700 mb-2">Customer Personas</h3>
            {customers.length === 0 ? (
              <p className="text-sm text-gray-500">No customer personas yet.</p>
            ) : (
              customers.map((p) => (
                <div
                  key={p.id || p.name}
                  className="p-4 border border-gray-200 rounded-xl bg-white shadow-sm mb-3 relative"
                >
                  <div className="absolute top-2 right-2">
                    <button
                      onClick={() => setMenuOpen(menuOpen === p.id ? null : p.id)}
                      className="text-gray-600 hover:text-gray-900"
                    >
                      <MoreVertical size={18} />
                    </button>
                    {menuOpen === p.id && (
                      <div className="absolute right-0 mt-1 w-28 bg-white border border-gray-200 rounded-lg shadow-lg z-10">
                        <button
                          className="flex items-center gap-2 px-3 py-2 w-full text-left hover:bg-gray-100"
                        >
                          <Edit size={14} /> Edit
                        </button>
                        <button
                          onClick={() => handleDelete(p.id)}
                          className="flex items-center gap-2 px-3 py-2 w-full text-left text-red-600 hover:bg-gray-100"
                        >
                          <Trash size={14} /> Delete
                        </button>
                      </div>
                    )}
                  </div>

                  <h4 className="font-semibold text-black">{p.name}</h4>
                  <p className="text-gray-700 text-sm mt-1">{p.description}</p>
                  {p.behavior && (
                    <p className="text-sm text-gray-600 mt-2">
                      <strong>Behavior:</strong> {p.behavior}
                    </p>
                  )}
                </div>
              ))
            )}
          </div>

          {/* Salesperson Personas */}
          <div>
            <h3 className="text-lg font-semibold text-blue-700 mb-2">Salesperson Personas</h3>
            {salespeople.length === 0 ? (
              <p className="text-sm text-gray-500">No salesperson personas yet.</p>
            ) : (
              salespeople.map((p) => (
                <div
                  key={p.id || p.name}
                  className="p-4 border border-gray-200 rounded-xl bg-white shadow-sm mb-3 relative"
                >
                  <div className="absolute top-2 right-2">
                    <button
                      onClick={() => setMenuOpen(menuOpen === p.id ? null : p.id)}
                      className="text-gray-600 hover:text-gray-900"
                    >
                      <MoreVertical size={18} />
                    </button>
                    {menuOpen === p.id && (
                      <div className="absolute right-0 mt-1 w-28 bg-white border border-gray-200 rounded-lg shadow-lg z-10">
                        <button
                          className="flex items-center gap-2 px-3 py-2 w-full text-left hover:bg-gray-100"
                        >
                          <Edit size={14} /> Edit
                        </button>
                        <button
                          onClick={() => handleDelete(p.id)}
                          className="flex items-center gap-2 px-3 py-2 w-full text-left text-red-600 hover:bg-gray-100"
                        >
                          <Trash size={14} /> Delete
                        </button>
                      </div>
                    )}
                  </div>

                  <h4 className="font-semibold text-black">{p.name}</h4>
                  <p className="text-gray-700 text-sm mt-1">{p.description}</p>
                  {p.behavior && (
                    <p className="text-sm text-gray-600 mt-2">
                      <strong>Behavior:</strong> {p.behavior}
                    </p>
                  )}
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </section>
  )
}
\n===== app/app/upload/page.tsx =====
'use client'
import UploadForm from './components/UploadForm'
import CallList from './components/CallList'
import PersonasPanel from './components/PersonasPanel'

export default function UploadPage() {
  return (
    <main className="p-6 space-y-10 bg-white text-black">
      {/* Upload Section */}
      <section>
        <UploadForm />
      </section>

      {/* Uploaded Calls List */}
      <section>
        <h2 className="text-xl font-semibold text-blue-700 mb-3">Uploaded Calls</h2>
        <CallList />
      </section>

      {/* Personas Section */}
      <section>
        <PersonasPanel />
      </section>
    </main>
  )
}
\n===== app/app/company/page.tsx =====
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type Company = {
  id?: string
  company_name: string
  geo_notes?: string
  unique_features?: string
  compliance?: string
  proof_points?: string
  disclaimer?: string
}

export default function CompanyPage() {
  const [lang, setLang] = useState<Lang>('sv')
  const [items, setItems] = useState<Company[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<Company | null>(null)
  const [form, setForm] = useState<Company>({
    company_name: '',
    geo_notes: '',
    unique_features: '',
    compliance: '',
    proof_points: '',
    disclaimer: '',
  })

  useEffect(() => { setLang(getLang()) }, [])

  async function fetchCompanies() {
    setLoading(true)
    setError(null)
    try {
      const r = await fetch('/api/company', { headers: { accept: 'application/json' } })
      if (r.status === 401) {
        // not authenticated (avoid crashing on .json())
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      const data = await r.json().catch(() => [])
      setItems(Array.isArray(data) ? data : [])
    } catch (e: any) {
      console.error('Load companies failed:', e)
      setError(t(lang, 'common.error'))
      setItems([])
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchCompanies()
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  useEffect(() => {
    // lock background scroll while modal open
    document.body.style.overflow = open ? 'hidden' : ''
    return () => { document.body.style.overflow = '' }
  }, [open])

  async function save() {
    if (saving) return
    setSaving(true)
    try {
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/company/${editing.id}` : '/api/company'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', accept: 'application/json' },
        body: JSON.stringify(form),
      })
      if (r.status === 401) {
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      setOpen(false)
      setEditing(null)
      await fetchCompanies()
    } catch (e) {
      console.error('Save company failed:', e)
      alert(t(lang, 'common.error'))
    } finally {
      setSaving(false)
    }
  }

  async function del(id?: string) {
    if (!id) return
    try {
      const r = await fetch(`/api/company/${id}`, { method: 'DELETE', headers: { accept: 'application/json' } })
      if (r.status === 401) {
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      setItems(prev => prev.filter(i => i.id !== id))
    } catch (e) {
      console.error('Delete company failed:', e)
      alert(t(lang, 'common.error'))
    }
  }

  function openNew() {
    setEditing(null)
    setForm({
      company_name: '',
      geo_notes: '',
      unique_features: '',
      compliance: '',
      proof_points: '',
      disclaimer: '',
    })
    setOpen(true)
  }

  function openEdit(c: Company) {
    setEditing(c)
    setForm({
      company_name: c.company_name || '',
      geo_notes: c.geo_notes || '',
      unique_features: c.unique_features || '',
      compliance: c.compliance || '',
      proof_points: c.proof_points || '',
      disclaimer: c.disclaimer || '',
      id: c.id,
    })
    setOpen(true)
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'company.title')}</h1>
        <button
          className="bg-[var(--brand)] text-white rounded px-4 py-2"
          onClick={openNew}
        >
          {t(lang,'company.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && items.length === 0 && (
        <div className="text-slate-500">{t(lang,'company.list.empty')}</div>
      )}

      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {items.map(c => (
          <div key={c.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{c.company_name || '‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={() => openEdit(c)}>{t(lang,'company.edit')}</button>
                <ConfirmDialog onConfirm={() => del(c.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm space-y-1 text-slate-700">
              {c.geo_notes && <div><b>{t(lang,'company.card.geo')}:</b> {c.geo_notes}</div>}
              {c.unique_features && <div><b>{t(lang,'company.card.unique')}:</b> {c.unique_features}</div>}
              {c.compliance && <div><b>{t(lang,'company.form.compliance')}:</b> {c.compliance}</div>}
              {c.proof_points && <div><b>{t(lang,'company.form.proof')}:</b> {c.proof_points}</div>}
              {c.disclaimer && <div><b>{t(lang,'company.card.disclaimer')}:</b> {c.disclaimer}</div>}
            </div>
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'company.edit') : t(lang,'company.new')}
          onClose={() => setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'company.form.name')}
              <input
                className="border rounded p-2 w-full"
                value={form.company_name}
                placeholder={t(lang,'company.ph.name')}
                onChange={e=>setForm({...form, company_name:e.target.value})}
              />
            </label>

            <label className="text-sm">{t(lang,'company.form.geo')}
              <input
                className="border rounded p-2 w-full"
                value={form.geo_notes}
                placeholder={t(lang,'company.ph.geo')}
                onChange={e=>setForm({...form, geo_notes:e.target.value})}
              />
            </label>

            <label className="text-sm">{t(lang,'company.form.unique')}
              <input
                className="border rounded p-2 w-full"
                value={form.unique_features}
                placeholder={t(lang,'company.ph.unique')}
                onChange={e=>setForm({...form, unique_features:e.target.value})}
              />
            </label>

            <div className="grid md:grid-cols-2 gap-3">
              <label className="text-sm">{t(lang,'company.form.compliance')}
                <input
                  className="border rounded p-2 w-full"
                  value={form.compliance}
                  placeholder={t(lang,'company.ph.compliance')}
                  onChange={e=>setForm({...form, compliance:e.target.value})}
                />
              </label>
              <label className="text-sm">{t(lang,'company.form.proof')}
                <input
                  className="border rounded p-2 w-full"
                  value={form.proof_points}
                  placeholder={t(lang,'company.ph.proof')}
                  onChange={e=>setForm({...form, proof_points:e.target.value})}
                />
              </label>
            </div>

            <label className="text-sm">{t(lang,'company.form.disclaimer')}
              <textarea
                className="border rounded p-2 w-full min-h-[110px]"
                value={form.disclaimer}
                placeholder={t(lang,'company.ph.disclaimer')}
                onChange={e=>setForm({...form, disclaimer:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}
\n===== app/auth/whoami/route.ts =====
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";
export const runtime = "nodejs"; export const dynamic = "force-dynamic";
function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies:{ getAll(){return req.cookies.getAll()}, setAll(c){c.forEach(({name,value,options})=>{res.cookies.set(name,value,options as CookieOptions)})} } }
  );
}
export async function GET(req: NextRequest){
  const res = NextResponse.json({});
  const supabase = makeClient(req,res);
  const { data:{ user }, error } = await supabase.auth.getUser();
  return NextResponse.json({ ok:!!user && !error, error:error?.message||null, user:user?{id:user.id,email:user.email}:null, cookies:req.cookies.getAll().map(c=>c.name) });
}
\n===== app/auth/signup/route.ts =====
// app/auth/signup/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

function makeSupabaseServer() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  return createClient(url, anon, { auth: { persistSession: false } })
}

// Read either JSON or multipart form
async function readSignupPayload(req: NextRequest) {
  const ct = req.headers.get('content-type') || ''
  if (ct.includes('application/json')) {
    const j = await req.json().catch(() => ({}))
    return {
      email: String(j.email || '').trim(),
      password: String(j.password || '').trim(),
      name: String(j.name || j.fullName || '').trim(),
    }
  }
  if (ct.includes('multipart/form-data') || ct.includes('application/x-www-form-urlencoded')) {
    const f = await req.formData()
    return {
      email: String(f.get('email') || '').trim(),
      password: String(f.get('password') || '').trim(),
      name: String(f.get('name') || f.get('fullName') || '').trim(),
    }
  }
  throw new Error('unsupported_content_type')
}
export async function POST(req: NextRequest) {
  try {
    const { email, password, name } = await readSignupPayload(req)
    if (!email || !password) {
      return NextResponse.json({ error: 'missing_email_or_password' }, { status: 400 })
    }

    const sb = makeSupabaseServer()
    // Where to send magic-link/email-confirm redirects (optional)
    const origin = req.headers.get('origin') || process.env.NEXT_PUBLIC_SITE_URL || ''
    const emailRedirectTo = origin ? `${origin}/auth/callback` : undefined

    const { data, error } = await sb.auth.signUp({
      email,
      password,
      options: {
        data: name ? { name } : undefined,
        emailRedirectTo,
      }
    })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    // Note: depending on Supabase settings, user may need to confirm email first
    return NextResponse.json({ ok: true, user: data.user }, { status: 200 })
  } catch (e:any) {
    if (e?.message === 'unsupported_content_type') {
      return NextResponse.json(
        { error: 'Content-Type must be application/json or multipart/form-data' },
        { status: 415 }
      )
    }
    return NextResponse.json({ error: e?.message || 'signup_failed' }, { status: 500 })
  }
}
\n===== app/auth/signout/route.ts =====
// app/auth/signout/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function makeClient(req: NextRequest) {
  const res = NextResponse.redirect(new URL("/auth", req.url), 303);
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll(); },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
  return { supabase, res };
}

async function doSignOut(req: NextRequest) {
  const { supabase, res } = makeClient(req);
  await supabase.auth.signOut();
  return res;
}

export async function GET(req: NextRequest)  { return doSignOut(req); }
export async function POST(req: NextRequest) { return doSignOut(req); }
\n===== app/auth/layout.tsx =====
// app/auth/layout.tsx
import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { supabaseServer } from "@/lib/supabaseServer";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

export default async function AuthLayout({ children }: { children: ReactNode }) {
  const supabase = supabaseServer; // ‚úÖ FIX: call it as a function
  const {
    data: { user },
    error,
  } = await supabase.auth.getUser();

  if (!error && user) redirect("/app/qa");

  return <>{children}</>;
}
\n===== app/auth/callback/CallbackClient.tsx =====
'use client';

import { Suspense, useEffect } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { supabaseBrowser } from '@/lib/supabaseBrowser';

function CallbackInner() {
  const search = useSearchParams();
  const router = useRouter();

  useEffect(() => {
    const code = search.get('code');
    const err  = search.get('error_description') || search.get('error');

    (async () => {
      try {
        if (err) {
          router.replace('/auth?error=' + encodeURIComponent(err));
          return;
        }
        if (code) {
          const sb = supabaseBrowser();
          await sb.auth.exchangeCodeForSession(code);
          router.replace('/app/qa');
          return;
        }
        router.replace('/auth');
      } catch {
        router.replace('/auth?error=callback_failed');
      }
    })();
  }, [search, router]);

  return <div className="p-6 text-sm text-slate-600">Signing you in‚Ä¶</div>;
}

export default function CallbackClient() {
  return (
    <Suspense fallback={<div className="p-6 text-sm text-slate-600">Loading‚Ä¶</div>}>
      <CallbackInner />
    </Suspense>
  );
}
\n===== app/auth/callback/page.tsx =====
'use client'
import { useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

export default function AuthCallback(){
  const r = useRouter(); const q = useSearchParams();
  useEffect(()=>{(async()=>{
    const err = q.get('error') || q.get('error_description')
    if (err) return r.replace('/auth?error='+encodeURIComponent(err))
    const { data } = await supabaseBrowser().auth.getSession()
    const at = data.session?.access_token, rt = data.session?.refresh_token
    if(!at || !rt) return r.replace('/auth?error=no_session')
    const s = await fetch('/api/auth/sync',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({access_token:at,refresh_token:rt})})
    if(!s.ok) return r.replace('/auth?error=sync_failed')
    r.replace('/app/qa')
  })()},[q,r])
  return <div className="p-6">Completing sign-in‚Ä¶</div>
}
\n===== app/auth/page.tsx =====
// app/auth/page.tsx
'use client'
import { useState } from 'react'

export default function AuthPage() {
  const [mode, setMode] = useState<'login'|'signup'>('login')
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [pending, setPending] = useState(false)
  const [msg, setMsg] = useState<string>('')

  async function submit(e: React.FormEvent) {
    e.preventDefault()
    setMsg(''); setPending(true)
    try {
      if (mode === 'login') {
        const r = await fetch('/auth/login', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ email, password }),
        })
        if (!r.ok) {
          const j = await r.json().catch(()=>({}))
          throw new Error(j?.error || `Login failed (${r.status})`)
        }
        // We do NOT manually redirect here. The route already responded 303 to /app/qa.
        // Browser follows automatically; if JS intercepts, we can fallback:
        window.location.href = '/app/qa'
      } else {
        const r = await fetch('/auth/signup', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ email, password }),
        })
        const j = await r.json().catch(()=>({}))
        if (!r.ok) throw new Error(j?.error || `Signup failed (${r.status})`)
        setMsg(j?.needsEmailConfirm ? 'Check your email to confirm your account.' : 'Signed up!')
        if (!j?.needsEmailConfirm) window.location.href = '/app/qa'
      }
    } catch (e:any) {
      setMsg(e?.message || 'Auth failed')
    } finally {
      setPending(false)
    }
  }

  return (
    <div className="min-h-screen grid place-items-center p-6">
      <form onSubmit={submit} className="w-full max-w-sm border rounded-xl p-6">
        <h1 className="text-xl font-semibold mb-4">{mode==='login'?'Logga in':'Skapa konto'}</h1>
        <label className="block text-sm mb-2">E-post
          <input className="w-full border rounded p-2" type="email" value={email} onChange={e=>setEmail(e.target.value)} required autoComplete="email" />
        </label>
        <label className="block text-sm mb-4">L√∂senord
          <input className="w-full border rounded p-2" type="password" value={password} onChange={e=>setPassword(e.target.value)} required autoComplete={mode==='login'?'current-password':'new-password'} />
        </label>
        {msg && <p className="text-red-600 text-sm mb-3">{msg}</p>}
        <button className="w-full bg-[var(--brand)] text-white rounded p-2 disabled:opacity-60" disabled={pending}>
          {pending ? 'Arbetar‚Ä¶' : (mode==='login'?'Logga in':'Skapa konto')}
        </button>
        <button type="button" className="w-full mt-2 underline" onClick={()=>setMode(mode==='login'?'signup':'login')}>
          {mode==='login'?'Skapa nytt konto':'Har konto? Logga in'}
        </button>
      </form>
    </div>
  )
}
\n===== app/auth/login/route.ts =====
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/** Build an absolute URL on the current origin (works on local & prod www.salesmind.app) */
function urlOnSameOrigin(req: NextRequest, pathname: string) {
  const u = new URL(req.url);
  u.pathname = pathname;
  u.search = "";
  u.hash = "";
  return u.toString();
}

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll() },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            // Forward Supabase Auth cookies onto our redirect response
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
}

export async function POST(req: NextRequest) {
  // IMPORTANT: set the redirect response up-front so cookies can attach to it.
  const res = NextResponse.redirect(urlOnSameOrigin(req, "/app/qa"), 303);
  try {
    const { email, password } = await req.json();
    if (!email || !password) {
      return NextResponse.json({ error: "missing_credentials" }, { status: 400 });
    }
    const supabase = makeClient(req, res);
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) return NextResponse.json({ error: error.message }, { status: 401 });
    // Cookies are on 'res' now; the 303 ensures the browser re-requests /app/qa with fresh cookies.
    return res;
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "bad_request" }, { status: 400 });
  }
}
\n===== app/auth/debug/page.tsx =====
// app/auth/debug/page.tsx
import { supabaseServer } from '@/lib/supabaseServer'

export default async function DebugAuthPage(){
  const supabase = supabaseServer
  const { data: { user }, error } = await supabase.auth.getUser()
  return (
    <pre className="p-4 text-sm">
      {JSON.stringify({ user, error }, null, 2)}
    </pre>
  )
}
\n===== app/(site)/sections/HeroSection.tsx =====
// app/(site)/sections/HeroSection.tsx
'use client'

export default function HeroSection() {
  const base = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
  const heroSrc = `${base}/storage/v1/object/public/site/hero.jpg`

  return (
    <section className="max-w-6xl mx-auto px-4 py-16 grid md:grid-cols-2 items-center gap-8">
      <div className="text-center md:text-left">
        <h1 className="text-3xl md:text-5xl font-bold mb-2">
          üß† SalesMind ‚Äì AI Sales Coach for Real-Time Objection Handling
        </h1>
        <h2 className="text-xl mb-4">Turn every sales call into a sale.</h2>

        {/* Mobile-only image placement (between subtitle & paragraph) */}
        <div className="block md:hidden mb-4">
          <img
            src={heroSrc}
            alt="SalesMind AI Coach"
            className="rounded-2xl w-full object-contain"
          />
        </div>

        <p className="text-lg text-gray-700">
          SalesMind helps sales reps handle objections in real time and build trust with prospects
          using conversational AI and personal data insights ‚Äî boosting confidence, connection, and closing rates.
        </p>
      </div>

      {/* Desktop-only hero image on the right */}
      <div className="hidden md:block">
        <img
          src={heroSrc}
          alt="SalesMind AI Coach"
          className="rounded-2xl w-full object-contain"
        />
      </div>
    </section>
  )
}
\n===== app/(site)/contact/page.tsx =====
import { Mail, User, MessageSquare } from 'lucide-react'

function HIcon({ children }: { children: React.ReactNode }) {
  return (
    <span className="inline-flex items-center justify-center align-middle mr-2 text-black">
      {children}
    </span>
  )
}

export const dynamic = 'force-dynamic'

export default function ContactPage() {
  return (
    <div className="max-w-2xl mx-auto px-4 py-12 md:py-16 space-y-6">
      <h1 className="text-3xl md:text-4xl font-bold flex items-center">
        <HIcon><Mail size={32} /></HIcon> Contact
      </h1>

      <p className="text-slate-700">
        Email us at{' '}
        <a href="mailto:hello@salesmind.app" className="underline">
          hello@salesmind.app
        </a>.
      </p>

      <form
        action="https://formsubmit.co/hello@salesmind.app"
        method="POST"
        className="grid gap-3"
      >
        <input type="hidden" name="_subject" value="SalesMind website contact" />
        <input type="hidden" name="_captcha" value="false" />

        <label className="block">
          <span className="text-sm flex items-center">
            <HIcon><User size={18} /></HIcon>Your name
          </span>
          <input
            name="name"
            required
            className="mt-1 w-full border rounded px-3 py-2"
          />
        </label>

        <label className="block">
          <span className="text-sm flex items-center">
            <HIcon><Mail size={18} /></HIcon>Email
          </span>
          <input
            type="email"
            name="email"
            required
            className="mt-1 w-full border rounded px-3 py-2"
          />
        </label>

        <label className="block">
          <span className="text-sm flex items-center">
            <HIcon><MessageSquare size={18} /></HIcon>Message
          </span>
          <textarea
            name="message"
            rows={5}
            required
            className="mt-1 w-full border rounded px-3 py-2"
          />
        </label>

        <button className="px-4 py-2 rounded bg-black text-white w-fit">
          Send
        </button>
      </form>
    </div>
  )
}
\n===== app/(site)/features/page.tsx =====
import SiteImage from '@/components/SiteImage'
import HIcon from '@/components/HIcon'
import { Rocket, BrainCircuit, Mic2, Zap } from 'lucide-react'

export const dynamic = 'force-dynamic'

export default function FeaturesPage() {
  return (
    <div className="max-w-6xl mx-auto px-4 py-12 md:py-20 space-y-10">
      <header className="space-y-4 text-center">
        <h1 className="text-3xl md:text-5xl font-bold">
          <HIcon><Rocket className="h-8 w-8 text-black" /></HIcon>
          Key Features
        </h1>
        <p className="text-lg text-slate-700 max-w-2xl mx-auto">
          SalesMind gives every sales rep the confidence, tools, and insights to win more calls ‚Äî all powered by AI.
        </p>
      </header>

      <section className="space-y-10">
        {/* Personal Data Insights (image right) */}
        <div className="flex flex-col md:flex-row items-center gap-10">
          <div className="md:w-1/2 space-y-4">
            <h2 className="text-2xl font-semibold">
              <HIcon><BrainCircuit className="h-6 w-6 text-black" /></HIcon>
              Personal Data Insights
            </h2>
            <p className="text-slate-700">
              Instantly surface public information about prospects ‚Äî like interests, company background, or tone hints ‚Äî so you can build trust and relatability from the very first seconds of a call.
            </p>
          </div>
          <div className="md:w-1/2">
            <SiteImage src="sections/three-icons.jpg" alt="Three feature icons layout" />
          </div>
        </div>

        {/* Simulation Training (image left) */}
        <div className="flex flex-col md:flex-row-reverse items-center gap-10">
          <div className="md:w-1/2 space-y-4">
            <h2 className="text-2xl font-semibold">
              <HIcon><Mic2 className="h-6 w-6 text-black" /></HIcon>
              Simulation Training
            </h2>
            <p className="text-slate-700">
              Practice live conversations with an AI-driven customer that reacts like a real person. Build confidence, sharpen objection handling, and train naturally ‚Äî anytime, anywhere.
            </p>
          </div>
          <div className="md:w-1/2">
            <SiteImage src="sections/three-icons.jpg" alt="Three feature icons layout" />
          </div>
        </div>

        {/* AI Coaching Q&A (image right) */}
        <div className="flex flex-col md:flex-row items-center gap-10">
          <div className="md:w-1/2 space-y-4">
            <h2 className="text-2xl font-semibold">
              <HIcon><Zap className="h-6 w-6 text-black" /></HIcon>
              AI Coaching Q&A
            </h2>
            <p className="text-slate-700">
              Get instant answers to any customer objection. Ask ‚ÄúWhat do I say if they say it‚Äôs too expensive?‚Äù and receive clear, personalized responses in your tone ‚Äî ready to use right away.
            </p>
          </div>
          <div className="md:w-1/2">
            <SiteImage src="sections/three-icons.jpg" alt="Three feature icons layout" />
          </div>
        </div>
      </section>
    </div>
  )
}

\n===== app/(site)/layout.tsx =====
// app/(site)/layout.tsx
import './site.css'
import MobileMenu from '@/components/MobileMenu'
import type { ReactNode } from 'react'
import Link from 'next/link'
import { siteImageUrl } from '@/lib/siteImages'

export default function SiteLayout({ children }: { children: ReactNode }) {
  const logo = siteImageUrl('logo.png') // upload to Supabase: bucket "site", path "logo.png"
  return (
    <div className="min-h-screen flex flex-col">
      <header className="max-w-6xl w-full mx-auto px-4 py-4 flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        {/* Logo */}
        <div className="flex items-center justify-center md:justify-center md:justify-start">
          <Link href="/" className="flex items-center">
            <img
              src={logo || '/placeholder.svg'}
              alt="SalesMind Logo"
              className="h-40 w-auto md:h-40"
            />
          </Link>
        </div>

        {/* Navigation (stacks on mobile, inline on desktop) */}
        <nav className="hidden md:flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-4 text-sm">
          <Link href="/features">Features</Link>
          <Link href="/pricing">Pricing</Link>
          <Link href="/contact">Contact</Link>
          <Link href="/auth" className="px-3 py-1 rounded border">Log In</Link>
          <Link href="/auth" className="px-3 py-1 rounded bg-black text-white">Sign Up</Link>
        </nav>
        <MobileMenu />
</header>


      <main className="flex-1">{children}</main>

      <footer className="border-t">
        <div className="max-w-6xl mx-auto px-4 py-8 text-sm text-slate-600 text-center md:text-left">
          ¬© {new Date().getFullYear()} SalesMind
        </div>
      </footer>
    </div>
  )
}
\n===== app/(site)/page.tsx =====
// app/(site)/page.tsx
import Link from 'next/link'
import SiteImage from '@/components/SiteImage'
import HIcon from '@/components/HIcon'
import {
  BrainCircuit,
  Target,
  Cog,
  Lightbulb,
  Zap,
  DollarSign,
  BarChart3,
  Globe,
  CheckCircle2,
  Clock,
  Briefcase,
  GraduationCap,
  Mic2
} from 'lucide-react'

export const dynamic = 'force-dynamic'

export default function HomePage() {
  return (
    <>
      {/* Hero */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-10 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-8">
            {/* Text */}
            <div className="md:w-1/2 space-y-4 text-center md:text-left">
              <h1 className="text-3xl md:text-5xl font-bold">
                <HIcon><BrainCircuit className="h-16 w-16 text-black" /></HIcon>
                SalesMind ‚Äì AI Sales Coach for Real-Time Objection Handling
              </h1>
              <h3 className="text-xl md:text-2xl text-slate-800">
                Turn every sales call into a sale.
              </h3>

              {/* Mobile-only image (between subtitle and paragraph) */}
              <div className="block md:hidden mb-4">
                <SiteImage
                  src="hero.jpg"
                  alt="Sales rep using AI assistant during call"
                  priority
                />
              </div>

              <p className="text-lg text-slate-700">
                SalesMind helps sales reps handle objections in real time and build trust with prospects using conversational AI and personal data insights ‚Äî boosting confidence, connection, and closing rates.
              </p>

              <div className="flex gap-3 justify-center md:justify-start">
                <Link href="/auth" className="px-4 py-2 rounded border">Log In</Link>
                <Link href="/auth" className="px-4 py-2 rounded bg-black text-white">Sign Up</Link>
              </div>
            </div>

            {/* Desktop-only image */}
            <div className="hidden md:block md:w-1/2">
              <SiteImage
                src="hero.jpg"
                alt="Sales rep using AI assistant during call"
                priority
              />
            </div>
          </div>
        </div>
      </section>

      {/* Built for Sales Reps */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-10">
            <div className="md:w-1/2 space-y-4">
              <h2 className="text-2xl md:text-3xl font-semibold">
                <HIcon><Target className="h-6 w-6 text-black" /></HIcon>
                Built for Sales Reps Who Want to Win Every Call
              </h2>
              <p className="text-slate-700">
                <strong>Tired of freezing mid-call?</strong> SalesMind gives you the right words and insights exactly when you need them ‚Äî so you can handle any objection confidently.
              </p>
              <ul className="list-none space-y-2 text-slate-700">
                <li className="flex items-start"><CheckCircle2 className="h-5 w-5 mt-0.5 mr-2 text-black" /> <span>Personal intel to build trust and relatability</span></li>
                <li className="flex items-start"><Zap className="h-5 w-5 mt-0.5 mr-2 text-black" /> <span>Live AI feedback on tone and phrasing</span></li>
                <li className="flex items-start"><BrainCircuit className="h-5 w-5 mt-0.5 mr-2 text-black" /> <span>Continuous learning from your real calls</span></li>
              </ul>
              <blockquote className="p-4 bg-slate-50 rounded">
                ‚ÄúIt‚Äôs like having a coach next to you during every customer call.‚Äù<br/>‚Äî Sales Rep, Telecom Sector
              </blockquote>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/coaching.jpg"
                alt="Sales team collaboration or coaching scene"
              />
            </div>
          </div>
        </div>
      </section>

      {/* How It Works */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row-reverse items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><Cog className="h-6 w-6 text-black" /></HIcon>
                How It Works
              </h2>
              <ol className="space-y-2 text-slate-700">
                <li>1. <strong>Sign up</strong> ‚Äì self-serve or via your sales manager</li>
                <li>2. <strong>Ask for help mid-call</strong> ‚Äì get tailored objection scripts and customer insights instantly</li>
                <li>3. <strong>Review and learn</strong> ‚Äì your calls become personalized lessons with AI simulations</li>
              </ol>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/flow.jpg"
                alt="Step-by-step flow graphic"
              />
            </div>
          </div>
        </div>
      </section>

      {/* Why 10√ó Better */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><Lightbulb className="h-6 w-6 text-black" /></HIcon>
                Why SalesMind Is 10√ó Better
              </h2>
              <div className="overflow-x-auto border rounded">
                <table className="w-full text-left text-sm">
                  <thead className="bg-slate-50">
                    <tr>
                      <th className="p-3">Today‚Äôs Way</th>
                      <th className="p-3">With SalesMind</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr className="border-t"><td className="p-3">Managers spend hours repeating the same coaching</td><td className="p-3">AI simulations train reps automatically</td></tr>
                    <tr className="border-t"><td className="p-3">Scattered tools for research, notes, and training</td><td className="p-3">One unified platform</td></tr>
                    <tr className="border-t"><td className="p-3">Guesswork in customer connection</td><td className="p-3">Personal data insights build rapport instantly</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/comparison.jpg"
                alt="Comparison chart graphic"
              />
            </div>
          </div>
        </div>
      </section>

      {/* Key Features (icons added) */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row-reverse items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><Zap className="h-6 w-6 text-black" /></HIcon>
                Key Features
              </h2>
              <div className="grid md:grid-cols-3 gap-6">
                <div className="p-4 rounded border">
                  <h3 className="font-medium mb-2">
                    <HIcon><BrainCircuit className="h-5 w-5 text-black" /></HIcon>
                    Personal Data Insights
                  </h3>
                  <p className="text-slate-700">
                    Instantly surface public information about prospects ‚Äî like interests, company background, or tone hints ‚Äî so you can build trust and relatability from the very first seconds of a call.
                  </p>
                </div>
                <div className="p-4 rounded border">
                  <h3 className="font-medium mb-2">
                    <HIcon><Mic2 className="h-5 w-5 text-black" /></HIcon>
                    Simulation Training
                  </h3>
                  <p className="text-slate-700">
                    Practice live conversations with an AI-driven customer that reacts like a real person. Build confidence, sharpen objection handling, and train naturally ‚Äî anytime, anywhere.
                  </p>
                </div>
                <div className="p-4 rounded border">
                  <h3 className="font-medium mb-2">
                    <HIcon><Zap className="h-5 w-5 text-black" /></HIcon>
                    AI Coaching Q&A
                  </h3>
                  <p className="text-slate-700">
                    Get instant answers to any customer objection. Ask ‚ÄúWhat do I say if they say it‚Äôs too expensive?‚Äù and receive clear, personalized responses in your tone ‚Äî ready to use right away.
                  </p>
                </div>
              </div>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/three-icons.jpg"
                alt="Three feature icons layout"
              />
            </div>
          </div>
        </div>
      </section>

      {/* Pricing (removed VAT line) */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><DollarSign className="h-6 w-6 text-black" /></HIcon>
                Simple Pricing ‚Äì Subscription per Seat
              </h2>
              <div className="overflow-x-auto border rounded">
                <table className="w-full text-left text-sm">
                  <thead className="bg-slate-50">
                    <tr>
                      <th className="p-3">Plan</th>
                      <th className="p-3">Description</th>
                      <th className="p-3">Price</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr className="border-t"><td className="p-3 font-medium">Solo</td><td className="p-3">1 rep, unlimited Q&A, personal insights</td><td className="p-3">399 SEK / month</td></tr>
                    <tr className="border-t"><td className="p-3 font-medium">Team</td><td className="p-3">10+ reps, shared knowledge base, analytics</td><td className="p-3">from 2,990 SEK / month</td></tr>
                    <tr className="border-t"><td className="p-3 font-medium">Enterprise</td><td className="p-3">Custom setup, integrations, dedicated support</td></tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/pricing.jpg"
                alt="Pricing table graphic"
              />
            </div>
          </div>
        </div>
      </section>

      {/* Why It Works (icons fixed) */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row-reverse items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><BarChart3 className="h-6 w-6 text-black" /></HIcon>
                Why It Works
              </h2>
              <div className="overflow-x-auto border rounded">
                <table className="w-full text-left text-sm">
                  <thead className="bg-slate-50">
                    <tr>
                      <th className="p-3">Metric</th>
                      <th className="p-3">Impact</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr className="border-t"><td className="p-3"><HIcon><Clock className="h-5 w-5 text-black" /></HIcon> Time Saved</td><td className="p-3">30‚Äì60 seconds per objection</td></tr>
                    <tr className="border-t"><td className="p-3"><HIcon><Briefcase className="h-5 w-5 text-black" /></HIcon> Deal Conversion</td><td className="p-3">+15‚Äì25% more deals closed</td></tr>
                    <tr className="border-t"><td className="p-3"><HIcon><GraduationCap className="h-5 w-5 text-black" /></HIcon> Manager Efficiency</td><td className="p-3">5‚Äì8 hours saved weekly on coaching</td></tr>
                  </tbody>
                </table>
              </div>
              <p className="text-slate-700 mt-4">
                Each call becomes a training moment ‚Äî creating stronger, faster, and more confident sales teams.
              </p>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/chart.jpg"
                alt="Data visualization chart or graph"
              />
            </div>
          </div>
        </div>
      </section>

      {/* About Us */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-10">
            <div className="md:w-1/2">
              <h2 className="text-2xl md:text-3xl font-semibold mb-6">
                <HIcon><Globe className="h-6 w-6 text-black" /></HIcon>
                About Us
              </h2>
              <p className="text-slate-700">
                SalesMind started in Sweden, built by real sales professionals who‚Äôve lived the challenge of handling objections under pressure.
                Now expanding across the Nordics ‚Äî empowering every sales rep to sell smarter, faster, and more human.
              </p>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/team.jpg"
                alt="Founders portrait or team photo"
              />
            </div>
          </div>
        </div>
      </section>

      {/* CTA */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16 text-center space-y-4">
          <h2 className="text-2xl md:text-3xl font-semibold">
            <HIcon><CheckCircle2 className="h-6 w-6 text-black" /></HIcon>
            Start Free ‚Äì See Results in Minutes
          </h2>
          <p className="text-slate-700">No credit card. Just make calls. Start selling smarter.</p>
          <div className="flex gap-3 justify-center">
            <Link href="/auth" className="px-4 py-2 rounded bg-black text-white">Sign Up</Link>
            <Link href="/auth" className="px-4 py-2 rounded border">Log In</Link>
          </div>
        </div>
      </section>
    </>
  )
}
\n===== app/(site)/pricing/page.tsx =====
import HIcon from '@/components/HIcon'
import { DollarSign } from 'lucide-react'

export const dynamic = 'force-dynamic'

export default function PricingPage() {
  return (
    <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
      <h1 className="text-3xl md:text-5xl font-bold mb-6">
        <HIcon><DollarSign className="h-8 w-8 text-black" /></HIcon>
        Pricing
      </h1>

      <div className="overflow-x-auto border rounded">
        <table className="w-full text-left text-sm">
          <thead className="bg-slate-50">
            <tr>
              <th className="p-3">Plan</th>
              <th className="p-3">Description</th>
              <th className="p-3">Price</th>
            </tr>
          </thead>
          <tbody>
            <tr className="border-t">
              <td className="p-3 font-medium">Solo</td>
              <td className="p-3">1 rep, unlimited Q&A, personal insights</td>
              <td className="p-3">399 SEK / month</td>
            </tr>
            <tr className="border-t">
              <td className="p-3 font-medium">Team</td>
              <td className="p-3">10+ reps, shared knowledge base, analytics</td>
              <td className="p-3">from 2,990 SEK / month</td>
            </tr>
            <tr className="border-t">
              <td className="p-3 font-medium">Enterprise</td>
              <td className="p-3">Custom setup, integrations, dedicated support</td>
              <td className="p-3">Contact us</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p className="text-slate-700 mt-6">
        Prices shown exclude VAT. Need a custom plan? <a href="/contact" className="underline">Get in touch</a>.
      </p>
    </div>
  )
}
\n===== app/layout.tsx =====
// app/layout.tsx ‚Äî neutral root wrapper for *all* routes
import type { ReactNode } from 'react'
import './globals.css'   // ‚úÖ restore Tailwind/global styles

export const dynamic = 'force-dynamic'

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}
\n===== app/api/delete-call/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(req: Request) {
  try {
    const { id, file_path } = await req.json();
    if (!id || !file_path) throw new Error("Missing id or file_path");

    // 1Ô∏è‚É£ Delete file from storage
    const { error: storageError } = await supabase.storage.from("calls").remove([file_path]);
    if (storageError) console.warn("Storage delete error:", storageError);

    // 2Ô∏è‚É£ Delete record from table
    const { error: dbError } = await supabase.from("calls").delete().eq("id", id);
    if (dbError) throw dbError;

    return NextResponse.json({ success: true });
  } catch (err: any) {
    console.error("DELETE ERROR:", err);
    return NextResponse.json({ success: false, error: err.message }, { status: 500 });
  }
}
\n===== app/api/calls/list/route.ts =====
// app/api/calls/list/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

export async function GET(req: NextRequest){
  const res = NextResponse.json({ ok: true })
  try{
    const supabase = makeClient(req, res)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })
    const { data, error } = await supabase
      .from('calls')
      .select('*')
      .eq('owner', user.id)
      .order('created_at', { ascending: false })
    if (error) return NextResponse.json({ items: [] })
    return NextResponse.json({ items: data || [] })
  }catch{
    return NextResponse.json({ items: [] })
  }
}
\n===== app/api/calls/transcribe/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/calls/transcribe/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
export const maxDuration = 60

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { chunkText } from '@/lib/chunk'
import { embedText } from '@/lib/embedding'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

async function transcribeWithWhisper(buf: ArrayBuffer, mime: string){
  const apiKey = process.env.OPENAI_API_KEY
  if (!apiKey) throw new Error('OPENAI_API_KEY missing')
  const fd = new FormData()
  fd.append('file', new Blob([buf], { type: mime || 'application/octet-stream' }), 'audio')
  fd.append('model', 'whisper-1')
  // Optional: language hint ‚Äî uncomment if all calls are Swedish
  // fd.append('language', 'sv')

  const r = await fetch('https://api.openai.com/v1/audio/transcriptions', {
    method: 'POST',
    headers: { Authorization: `Bearer ${apiKey}` },
    body: fd
  })
  const j = await r.json().catch(()=> ({}))
  if (!r.ok) throw new Error(j?.error?.message || 'whisper_failed')
  const text: string = j.text || ''
  return text
}

export async function POST(req: NextRequest){
  const res = NextResponse.json({ ok: true })
  try{
    const supabase = makeClient(req, res)
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error || !user) return NextResponse.json({ error:'unauthorized' }, { status:401 })

    const { id } = await req.json()
    if (!id) return NextResponse.json({ error:'missing_id' }, { status:400 })

    // Load call row (owner scoped)
    const { data: call, error: e1 } = await supabase
      .from('calls').select('*').eq('id', id).eq('owner', user.id).single()
    if (e1 || !call) return NextResponse.json({ error:'not_found' }, { status:404 })

    // Get a signed URL to download the audio
    const key = call.filename as string
    const signed = await supabase.storage.from('calls').createSignedUrl(key, 60)
    if (signed.error || !signed.data?.signedUrl) {
      return NextResponse.json({ error: signed.error?.message || 'signed_url_failed' }, { status: 500 })
    }

    // Download audio file into memory
    const audioResp = await fetch(signed.data.signedUrl, { cache: 'no-store' })
    if (!audioResp.ok) {
      return NextResponse.json({ error: `download_failed (${audioResp.status})` }, { status: 502 })
    }
    const mime = audioResp.headers.get('content-type') || call.mime_type || 'application/octet-stream'
    const buf = await audioResp.arrayBuffer()

    // Transcribe with Whisper
    const text = await transcribeWithWhisper(buf, mime)

    // Save transcript on call
    await supabase.from('calls').update({ text }).eq('id', id).eq('owner', user.id)

    // Chunk + embed into call_chunks
    const chunks = chunkText(text, 1200)
    // Remove old chunks (re-run safe)
    await supabase.from('call_chunks').delete().eq('call_id', id)

    let idx = 0
    for (const c of chunks) {
      const emb = await embedText(c)
      const { error: insErr } = await supabase
        .from('call_chunks')
        .insert({ call_id: id, idx: idx++, content: c, embedding: emb as any })
      if (insErr) throw insErr
    }

    return NextResponse.json({ ok:true, id, chunks: chunks.length, chars: text.length })
  }catch(e:any){
    return NextResponse.json({ error: e?.message || 'transcribe_failed' }, { status: 500 })
  }
}
\n===== app/api/calls/upload/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/calls/upload/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

export async function POST(req: NextRequest) {
  const res = NextResponse.json({ ok: true })
  try {
    const supabase = makeClient(req, res)
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error || !user) return NextResponse.json({ error: 'unauthorized' }, { status: 401 })

    const form = await req.formData()
    const file = form.get('file') as File | null
    if (!file) return NextResponse.json({ error: 'missing_file' }, { status: 400 })

    const key = `${user.id}/${Date.now()}-${(file as any).name || 'call'}`

    // Upload to private bucket 'calls'
    const up = await supabase.storage.from('calls').upload(key, file, {
      contentType: file.type || 'application/octet-stream',
      upsert: false
    })
    if (up.error) return NextResponse.json({ error: up.error.message }, { status: 500 })

    // Insert DB row
    const { data, error: dberr } = await supabase
      .from('calls')
      .insert({
        owner: user.id,
        filename: key,
        mime_type: file.type || null,
        size_bytes: (file as any).size ?? null
      })
      .select()
      .single()

    if (dberr) return NextResponse.json({ error: dberr.message }, { status: 500 })

    return NextResponse.json({ ok: true, item: data })
  } catch (e:any) {
    return NextResponse.json({ error: e?.message || 'upload_failed' }, { status: 500 })
  }
}
\n===== app/api/kb/route.ts =====
// app/api/kb/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('kb_entries')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('kb_entries')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}
\n===== app/api/kb/[id]/route.ts =====
// app/api/kb/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('kb_entries')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('kb_entries')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}
\n===== app/api/kb/save/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

function s() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  return createClient(url, key, { auth: { persistSession: false } })
}

type SaveBody = {
  companyId?: string
  profileId?: string
  question: string
  outputs: {
    one_liner?: string
    why?: string
    ack?: string
    short_script?: string
    full_script?: string
    math?: string
    next_step?: string
  }
  like?: boolean              // üëç true / üëé false / undefined
  rating?: number | null      // 1..5
  tags?: string[] | null      // optional tags
  eventId?: string | null     // link to qa_events row
}

export async function POST(req: NextRequest) {
  try {
    const supabase = s()
    const body: SaveBody = await req.json()

    if (!body?.question) return NextResponse.json({ error: 'missing_question' }, { status: 400 })

    const tables = ['kb', 'knowledge_base', 'kb_items']
    let inserted: any = null
    let lastError: any = null

    for (const table of tables) {
      const payload: any = {
        company_id: body.companyId || null,
        profile_id: body.profileId || null,
        question: body.question,
        one_liner: body.outputs?.one_liner || null,
        why: body.outputs?.why || null,
        ack: body.outputs?.ack || null,
        short_script: body.outputs?.short_script || null,
        full_script: body.outputs?.full_script || null,
        math: body.outputs?.math || null,
        next_step: body.outputs?.next_step || null,
        liked: body.like ?? null,
        rating: body.rating ?? null,
        tags: body.tags ?? null,
        event_id: body.eventId ?? null
      }

      const { data, error } = await supabase.from(table).insert(payload).select().maybeSingle()
      if (!error && data) { inserted = data; break }
      lastError = error
    }

    if (!inserted) {
      return NextResponse.json({ error: 'insert_failed', detail: lastError?.message || 'kb insert failed' }, { status: 500 })
    }

    return NextResponse.json({ ok: true, item: inserted })
  } catch (e: any) {
    return NextResponse.json({ error: 'kb_save_error', detail: e?.message || String(e) }, { status: 500 })
  }
}
\n===== app/api/delete-persona/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(req: Request) {
  try {
    const { id } = await req.json();
    const { error } = await supabase.from("behavior_personas").delete().eq("id", id);
    if (error) throw error;
    return NextResponse.json({ success: true });
  } catch (err: any) {
    console.error("DELETE ERROR:", err);
    return NextResponse.json({ success: false, error: err.message }, { status: 500 });
  }
}
\n===== app/api/get-personas/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function GET() {
  const { data, error } = await supabase
    .from("behavior_personas")
    .select("*")
    .order("created_at", { ascending: false })
    .limit(10);

  if (error) return NextResponse.json({ personas: [], error: error.message });
  return NextResponse.json({ personas: data });
}
\n===== app/api/voice-reply/route.ts =====
import { NextResponse } from "next/server";
import OpenAI from "openai";
import { createClient } from "@supabase/supabase-js";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_KEY!
);

export async function POST(req: Request) {
  const { text, personaId } = await req.json();
  const { data: persona } = await supabase
    .from("behavior_personas")
    .select("*")
    .eq("id", personaId)
    .single();

  const systemPrompt = `
You are a ${persona.name} customer.
Description: ${persona.description}
Behavior: ${persona.behavior}
Objections: ${persona.objection_examples.join(", ")}
Keep answers short and natural.
`;

  const reply = await openai.chat.completions.create({
    model: "gpt-4o-mini",
    messages: [
      { role: "system", content: systemPrompt },
      { role: "user", content: text },
    ],
  });

  const replyText = reply.choices[0].message.content || "I‚Äôm not sure.";
  const speech = await openai.audio.speech.create({
    model: "gpt-4o-mini-tts",
    voice: "alloy",
    input: replyText,
  });

  const arrayBuffer = await speech.arrayBuffer();
  const base64Audio = Buffer.from(arrayBuffer).toString("base64");
  return NextResponse.json({ audio: base64Audio, replyText });
}
\n===== app/api/auth/sync/route.ts =====
// app/api/auth/sync/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll(); },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
}

export async function POST(req: NextRequest) {
  const res = NextResponse.json({ ok: true });
  try {
    const { access_token, refresh_token } = await req.json();
    if (!access_token || !refresh_token) {
      return NextResponse.json({ error: "missing tokens" }, { status: 400 });
    }
    const supabase = makeClient(req, res);
    const { error } = await supabase.auth.setSession({ access_token, refresh_token });
    if (error) return NextResponse.json({ error: error.message }, { status: 401 });
    return res;
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "bad request" }, { status: 400 });
  }
}
\n===== app/api/admin/kb/ingest/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/admin/kb/ingest/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { embedText } from '@/lib/embedding'
import { chunkText } from '@/lib/chunk'
import { sbAdmin } from '@/lib/sbAdmin'

function makeClient(req: NextRequest) {
  const res = NextResponse.next()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name) => req.cookies.get(name)?.value,
        set: () => {},
        remove: () => {},
      },
    }
  )
}

async function assertAdmin(req: NextRequest) {
  const supabase = makeClient(req)
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('unauthenticated')
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  const r = await fetch(`${url}/rest/v1/app_users?user_id=eq.${user.id}&select=role`, {
    headers: { apikey:key, Authorization:`Bearer ${key}` }
  })
  const rows = await r.json()
  if (!Array.isArray(rows) || rows[0]?.role !== 'admin') throw new Error('forbidden')
  return user
}

export async function POST(req: NextRequest) {
  try {
    await assertAdmin(req)
    const { title, url, text } = await req.json() as { title:string, url?:string, text:string }
    if (!title || !text) return NextResponse.json({ error:'title and text required' }, { status:400 })

    // upsert source
    const existing = await sbAdmin(`/kb_sources?title=eq.${encodeURIComponent(title)}&select=*`)
    const source_id = existing[0]?.id || (await sbAdmin('/kb_sources', {
      method:'POST',
      headers:{ Prefer:'return=representation' },
      body: JSON.stringify([{ title, kind:'internal', url: url||null }])
    }))[0].id

    // chunk + embed + insert
    const chunks = chunkText(text)
    const rows:any[] = []
    for (const c of chunks) {
      const emb = await embedText(c)
      rows.push({ source_id, content: c, token_count: Math.ceil(c.length/4), embedding: emb })
    }
    await sbAdmin('/kb_chunks', { method:'POST', body: JSON.stringify(rows) })

    return NextResponse.json({ ok:true, source_id, chunks: rows.length })
  } catch (e:any) {
    const msg = e?.message || 'ingest failed'
    const code = /unauthenticated|forbidden/.test(msg) ? 403 : 500
    return NextResponse.json({ error: msg }, { status: code })
  }
}
\n===== app/api/admin/company/list/route.ts =====
export const runtime = 'nodejs'
import { NextResponse } from 'next/server'

/**
 * Returns [{id,name}] from your DB if available,
 * otherwise [] (no hard failure).
 */
export async function GET() {
  try {
    // TODO: swap in your real DB/Supabase. For now, try env hints or return [].
    // If you already have a route, you can delete this file.
    return NextResponse.json({ companies: [] })
  } catch (e:any) {
    return NextResponse.json({ companies: [] })
  }
}
\n===== app/api/geo/demographics/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'
import { KOMMUN_CODE_BY_NAME } from '@/lib/kommuner'
import { pxwebFetch } from '@/lib/scb'

/**
 * ENV you can set (dev: .env.local, prod: Vercel envs)
 *
 * SCB_DATASET_URL=
 *   Full PXWeb endpoint URL to a dataset that has:
 *   - Region (kommun) variable
 *   - Age variable
 *   - A measure/indicator we can read (e.g., median income)
 *
 *   Example (NOTE: this is just an illustrative path ‚Äî pick the actual one you want from SCB):
 *   https://api.scb.se/OV0104/v1/doris/sv/ssd/HE/HE0110/HE0110A/DispInkKomMedianK
 *
 * SCB_REGION_CODE=     # e.g. "Region"
 * SCB_AGE_CODE=        # e.g. "Alder"
 * SCB_MEASURE_CODE=    # e.g. "ContentsCode" OR a fixed measure var you include in the query
 * SCB_MEASURE_VALUE=   # e.g. "HE0110KM"  (depends on dataset)
 *
 * AGE bucket mapping (we‚Äôll request a compact set like 20‚Äì29, 30‚Äì44, 45‚Äì64, 65+).
 * You must use values that exist in your chosen dataset.
 *
 * If env is NOT set, we return a clean mocked response so UI still works.
 */

function parseMunicipalityNameFromGoogle(components: any[]): string | null {
  // Try locality first; fallback to postal_town
  const get = (type: string) =>
    components.find((c: any) => (c.types || []).includes(type))?.long_name || null;
  return get('locality') || get('postal_town') || null;
}

// Translate Google lang to sv/en
function pickLocale(searchParams: URLSearchParams) {
  const l = (searchParams.get('lang') || 'sv').toLowerCase();
  return l === 'en' ? 'en' : 'sv';
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const lang = pickLocale(searchParams);
    const address = searchParams.get('address') || '';
    if (!address.trim()) {
      return NextResponse.json({ error: 'missing address' }, { status: 400 });
    }

    // 1) Geocode with Google to get municipality name
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) return NextResponse.json({ error: 'missing_google_key' }, { status: 500 });

    const geoURL = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
    const geo = await fetch(geoURL).then(r => r.json());
    if (geo.status !== 'OK' || !geo.results?.length) {
      return NextResponse.json({
        error: 'geocode_not_found',
        provider_status: geo.status,
        provider_error: geo.error_message || null
      }, { status: 404 });
    }
    const comp = geo.results[0]?.address_components || [];
    const municipalityName = parseMunicipalityNameFromGoogle(comp);
    const country = comp.find((c:any)=> (c.types||[]).includes('country'))?.short_name || null;

    // 2) If not Sweden, or we fail to detect municipality ‚Üí return mock (so UI still works)
    if (country !== 'SE' || !municipalityName) {
      const mock = lang === 'en'
        ? {
            source: 'mock',
            municipality: municipalityName || '‚Äî',
            demographics: {
              buckets: [
                { age: '20‚Äì29', median_income: '240 000 SEK' },
                { age: '30‚Äì44', median_income: '310 000 SEK' },
                { age: '45‚Äì64', median_income: '340 000 SEK' },
                { age: '65+',   median_income: '270 000 SEK' },
              ]
            }
          }
        : {
            k√§lla: 'mock',
            kommun: municipalityName || '‚Äî',
            demografi: {
              √•lder_inkomst: [
                { √•lder: '20‚Äì29', medianinkomst: '240 000 kr' },
                { √•lder: '30‚Äì44', medianinkomst: '310 000 kr' },
                { √•lder: '45‚Äì64', medianinkomst: '340 000 kr' },
                { √•lder: '65+',   medianinkomst: '270 000 kr' },
              ]
            }
          };
      return NextResponse.json(mock);
    }

    const kommunCode = KOMMUN_CODE_BY_NAME[municipalityName] || null;
    const datasetUrl = process.env.SCB_DATASET_URL;
    const REGION = process.env.SCB_REGION_CODE || 'Region';
    const AGE    = process.env.SCB_AGE_CODE    || 'Alder';
    const MEAS   = process.env.SCB_MEASURE_CODE || 'ContentsCode';
    const MEAS_V = process.env.SCB_MEASURE_VALUE || ''; // optional

    // 3) If no dataset configured or kommun code missing, return mock
    if (!datasetUrl || !kommunCode) {
      const mock = lang === 'en'
        ? {
            source: 'mock',
            municipality: municipalityName,
            demographics: {
              buckets: [
                { age: '20‚Äì29', median_income: '240 000 SEK' },
                { age: '30‚Äì44', median_income: '310 000 SEK' },
                { age: '45‚Äì64', median_income: '340 000 SEK' },
                { age: '65+',   median_income: '270 000 SEK' },
              ]
            }
          }
        : {
            k√§lla: 'mock',
            kommun: municipalityName,
            demografi: {
              √•lder_inkomst: [
                { √•lder: '20‚Äì29', medianinkomst: '240 000 kr' },
                { √•lder: '30‚Äì44', medianinkomst: '310 000 kr' },
                { √•lder: '45‚Äì64', medianinkomst: '340 000 kr' },
                { √•lder: '65+',   medianinkomst: '270 000 kr' },
              ]
            }
          };
      return NextResponse.json(mock);
    }

    // 4) Build a PXWeb query (example age buckets ‚Äî must exist in your chosen dataset)
    // Replace the AGE values with the dataset's actual codes/labels.
    const ageValues = ['20-29', '30-44', '45-64', '65+'];

    const query = {
      query: [
        { code: REGION, selection: { filter: 'item', values: [kommunCode] } },
        { code: AGE,    selection: { filter: 'item', values: ageValues } },
        ...(MEAS_V ? [{ code: MEAS, selection: { filter: 'item', values: [MEAS_V] } }] : []),
      ]
    };

    const json = await pxwebFetch(datasetUrl, query as any);

    // 5) Parse PXWeb JSON: values align with query order
    // We map them back to our 4 age buckets.
    const values: (number|string)[] = json?.data?.map((d: any) => d?.values?.[0]) || [];
    const parsed = ageValues.map((age, i) => {
      const v = values[i];
      const n = typeof v === 'string' ? Number(v.replace(/\s+/g, '')) : (typeof v === 'number' ? v : null);
      return { age, median_income_value: n };
    });

    const payload = lang === 'en'
      ? {
          source: 'scb',
          municipality: municipalityName,
          demographics: {
            buckets: parsed.map(b => ({
              age: b.age,
              median_income: (b.median_income_value != null)
                ? `${Math.round(b.median_income_value).toLocaleString('sv-SE')} SEK`
                : '‚Äî'
            }))
          }
        }
      : {
          k√§lla: 'scb',
          kommun: municipalityName,
          demografi: {
            √•lder_inkomst: parsed.map(b => ({
              √•lder: b.age.replace('-', '‚Äì'),
              medianinkomst: (b.median_income_value != null)
                ? `${Math.round(b.median_income_value).toLocaleString('sv-SE')} kr`
                : '‚Äî'
            }))
          }
        };

    return NextResponse.json(payload);

  } catch (e:any) {
    return NextResponse.json({ error: 'server_error', detail: e?.message }, { status: 500 })
  }
}
\n===== app/api/geo/scb/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'

/**
 * PXWeb v1 reader for SCB Tab4bDispInkN (Disposable income).
 * GET /api/geo/scb?region=1280&year=2020&lang=sv
 * Returns: { year, region, lang, source, median_income_by_age:[{age, tkr}] }
 */
export async function GET(req: NextRequest) {
  try {
    const url = new URL(req.url)
    const region = (url.searchParams.get('region') || '').trim()
    const year   = (url.searchParams.get('year') || '2020').trim()
    const lang   = (url.searchParams.get('lang') || 'sv').toLowerCase() === 'en' ? 'en' : 'sv'

    if (!region) {
      return NextResponse.json({ error: 'missing_region', detail: 'Provide ?region=kommunkod, e.g. 1280' }, { status: 400 })
    }

    const TABLE     = process.env.SCB_V1_TABLE
    const REGION    = process.env.SCB_REGION_CODE    || 'Region'
    const AGE       = process.env.SCB_AGE_CODE       || 'Alder'
    const TIME      = process.env.SCB_TIME_CODE      || 'Tid'
    const MEASURE   = process.env.SCB_MEASURE_CODE   || 'ContentsCode'
    const MEAS_VAL  = process.env.SCB_MEASURE_VALUE  || '000000KE'
    const HH_CODE   = process.env.SCB_HH_TYPE_CODE   || 'Hushallstyp'
    const HH_KEEP   = process.env.SCB_HH_TYPE_KEEP   || 'E90'

    if (!TABLE) {
      return NextResponse.json({ error: 'missing_env', detail: 'SCB_V1_TABLE not set' }, { status: 500 })
    }

    const endpoint = TABLE.endsWith('/') ? TABLE : TABLE + '/'

    const baseQuery = [
      { code: REGION,  selection: { filter: 'item', values: [region] } },
      { code: AGE,     selection: { filter: 'all',  values: ['*'] } },
      { code: TIME,    selection: { filter: 'item', values: [year] } },
      { code: MEASURE, selection: { filter: 'item', values: [MEAS_VAL] } },
    ]

    const withHH = [
      ...baseQuery,
      { code: HH_CODE, selection: { filter: 'item', values: [HH_KEEP] } },
    ]

    async function postPX(body: any) {
      const resp = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'User-Agent': 'sales-mind-pxweb-client',
          'Cache-Control': 'no-cache',
        },
        body: JSON.stringify({ query: body, response: { format: 'JSON' } }),
        cache: 'no-store',
      })
      const text = await resp.text()
      if (!resp.ok) return { ok: false as const, status: resp.status, text }
      try { return { ok: true as const, json: JSON.parse(text) } }
      catch { return { ok: false as const, status: 502, text } }
    }

    let res = await postPX(withHH)
    if (!res.ok && (res.status === 400 || res.status === 404)) {
      res = await postPX(baseQuery)
    }
    if (!res.ok) {
      return NextResponse.json({ error: 'scb_http', status: res.status, preview: res.text?.slice(0, 300) ?? '' }, { status: 502 })
    }

    const rows: any[] = Array.isArray(res.json?.data) ? res.json.data : Array.isArray(res.json) ? res.json : []
    if (!Array.isArray(rows) || rows.length === 0) {
      return NextResponse.json({ year, region, lang, source: 'SCB PXWeb v1 Tab4bDispInkN', median_income_by_age: [] })
    }

    const columns = res.json?.columns as Array<{ code: string }> | undefined
    let idxRegion = -1, idxAge = -1, idxTime = -1
    if (Array.isArray(columns)) {
      idxRegion = columns.findIndex(c => c.code === REGION)
      idxAge    = columns.findIndex(c => c.code === AGE)
      idxTime   = columns.findIndex(c => c.code === TIME)
    }

    const out: Array<{ age: string, tkr: number }> = []
    for (const row of rows) {
      if (Array.isArray(row.key) && Array.isArray(row.values)) {
        const key = row.key
        const vals = row.values
        const rRegion = idxRegion >= 0 ? key[idxRegion] : region
        const rAge    = idxAge    >= 0 ? key[idxAge]    : ''
        const rTime   = idxTime   >= 0 ? key[idxTime]   : year
        if (rRegion !== region || rTime !== year) continue
        const num = Number(vals[0]?.toString().replace(/\s/g,'').replace(',', '.'))
        if (Number.isFinite(num)) out.push({ age: rAge, tkr: num })
      } else {
        const rRegion = row[REGION] ?? region
        const rAge    = row[AGE]    ?? ''
        const rTime   = row[TIME]   ?? year
        const rawVal  = row.value ?? row.values?.[0]
        const num = Number(String(rawVal ?? '').replace(/\s/g,'').replace(',', '.'))
        if (rRegion === region && rTime === year && Number.isFinite(num)) {
          out.push({ age: String(rAge), tkr: num })
        }
      }
    }

    const order = ['18+', '18-29', '30-49', '50-64', '65-79', '65+', '66+', '80+']
    out.sort((a,b) => {
      const ia = order.indexOf(a.age); const ib = order.indexOf(b.age)
      return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib)
    })

    return NextResponse.json({
      year, region, lang,
      source: 'SCB PXWeb v1 Tab4bDispInkN',
      measure_code: MEAS_VAL,
      median_income_by_age: out,
    })
  } catch (e:any) {
    return NextResponse.json({ error: 'scb_route_error', detail: e?.message || String(e) }, { status: 500 })
  }
}
\n===== app/api/geo/electricity/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs/promises'
import path from 'path'

type Point = { lat: number, lon: number }

/** Rough SE bidding zones (SE1..SE4) by latitude */
function guessBiddingZone(lat: number): 'SE1'|'SE2'|'SE3'|'SE4' {
  if (lat >= 64.0) return 'SE1'
  if (lat >= 62.0) return 'SE2'
  if (lat >= 57.7) return 'SE3'
  return 'SE4'
}

/** GeoJSON types */
type Feature = {
  type: 'Feature',
  properties: Record<string, any>,
  geometry: { type: 'Polygon'|'MultiPolygon', coordinates: number[][][] | number[][][][] }
}
type FeatureCollection = { type: 'FeatureCollection', features: Feature[] }

let cachedGeo: FeatureCollection | null = null

/* --- basic point-in-(multi)polygon helpers --- */
function bboxOfCoords(coords: number[][]): [number,number,number,number] {
  let minLon=Infinity, minLat=Infinity, maxLon=-Infinity, maxLat=-Infinity
  for (const [lon,lat] of coords) {
    if (lon < minLon) minLon = lon
    if (lat < minLat) minLat = lat
    if (lon > maxLon) maxLon = lon
    if (lat > maxLat) maxLat = lat
  }
  return [minLon,minLat,maxLon,maxLat]
}
function pointInRing(point: [number,number], ring: number[][]): boolean {
  const [x,y] = point
  let inside = false
  for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
    const [xi, yi] = ring[i]
    const [xj, yj] = ring[j]
    const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi)
    if (intersect) inside = !inside
  }
  return inside
}
function pointInPolygon(lonLat: [number,number], poly: number[][][]): boolean {
  if (!poly.length) return false
  const outer = poly[0]
  const [minLon,minLat,maxLon,maxLat] = bboxOfCoords(outer)
  const [lon,lat] = lonLat
  if (lon<minLon || lon>maxLon || lat<minLat || lat>maxLat) return false
  if (!pointInRing(lonLat, outer)) return false
  for (let i=1;i<poly.length;i++) {
    if (pointInRing(lonLat, poly[i])) return false
  }
  return true
}
function pointInMultiPolygon(lonLat: [number,number], multi: number[][][][]): boolean {
  for (const poly of multi) if (pointInPolygon(lonLat, poly)) return true
  return false
}

async function loadGeo(): Promise<FeatureCollection | null> {
  if (cachedGeo) return cachedGeo
  try {
    const file = path.join(process.cwd(), 'data', 'elnat_areas.geojson')
    const txt = await fs.readFile(file, 'utf8')
    const json = JSON.parse(txt)
    if (json && json.type === 'FeatureCollection' && Array.isArray(json.features)) {
      cachedGeo = json
      return cachedGeo
    }
    return null
  } catch {
    return null // dataset is optional
  }
}

async function geocode(address: string): Promise<Point | null> {
  const url = new URL('https://nominatim.openstreetmap.org/search')
  url.searchParams.set('q', address)
  url.searchParams.set('format', 'json')
  url.searchParams.set('addressdetails', '0')
  url.searchParams.set('countrycodes', 'se')
  url.searchParams.set('limit', '1')

  const r = await fetch(url, {
    headers: { 'User-Agent': 'sales-mind/geo-electricity (contact: admin@example.com)' },
    cache: 'no-store',
  })
  if (!r.ok) return null
  const arr = await r.json().catch(()=>[])
  if (!Array.isArray(arr) || !arr.length) return null
  const lat = parseFloat(arr[0].lat), lon = parseFloat(arr[0].lon)
  if (!isFinite(lat) || !isFinite(lon)) return null
  return { lat, lon }
}

export async function GET(req: NextRequest) {
  try {
    const u = new URL(req.url)
    const address = (u.searchParams.get('address') || '').trim()
    const latStr = u.searchParams.get('lat')
    const lonStr = u.searchParams.get('lon')

    let pt: Point | null = null
    if (latStr && lonStr) {
      const lat = parseFloat(latStr), lon = parseFloat(lonStr)
      if (isFinite(lat) && isFinite(lon)) pt = { lat, lon }
    }
    if (!pt && address) pt = await geocode(address)

    if (!pt) {
      return NextResponse.json({ error: 'no_point', detail: 'Provide address or lat/lon.' }, { status: 400 })
    }

    const elomr√•de = guessBiddingZone(pt.lat)

    let elnat: null | { name?: string, orgnr?: string, area_id?: string } = null
    const coll = await loadGeo()
    if (coll && Array.isArray(coll.features)) {
      const p: [number,number] = [pt.lon, pt.lat]
      for (const f of coll.features) {
        try {
          if (f.geometry?.type === 'Polygon') {
            const coords = f.geometry.coordinates as number[][][]
            if (pointInPolygon(p, coords)) { elnat = { name: f.properties?.name, orgnr: f.properties?.orgnr, area_id: f.properties?.area_id }; break }
          } else if (f.geometry?.type === 'MultiPolygon') {
            const coords = f.geometry.coordinates as number[][][][]
            if (pointInMultiPolygon(p, coords)) { elnat = { name: f.properties?.name, orgnr: f.properties?.orgnr, area_id: f.properties?.area_id }; break }
          }
        } catch {}
      }
    }

    return NextResponse.json({
      ok: true,
      input: { address, ...pt },
      elomrade: elomr√•de,
      elnat: elnat,
      dataset_present: !!coll,
      source: {
        geocode: 'OSM Nominatim',
        net_areas: coll ? 'data/elnat_areas.geojson' : 'not-installed'
      }
    })
  } catch (e:any) {
    return NextResponse.json({ error: 'electricity_route_error', detail: e?.message || String(e) }, { status: 500 })
  }
}
\n===== app/api/geo/pois/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'

const BUSINESS_TYPES = [
  'restaurant','cafe','bar','bakery','meal_takeaway','meal_delivery',
  'supermarket','convenience_store','shopping_mall','department_store',
  'clothing_store','shoe_store','jewelry_store','furniture_store','electronics_store',
  'hardware_store','bicycle_store','book_store','florist','beauty_salon','hair_care',
  'pharmacy','doctor','dentist','veterinary_care',
  'bank','atm','car_rental','car_repair','car_dealer',
  'gas_station','electric_vehicle_charging_station','lodging'
];

function metersBetween(lat1:number, lon1:number, lat2:number, lon2:number){
  const toRad = (d:number)=>d*Math.PI/180;
  const R = 6371000;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

// Map Google type -> localized label (sv/en)
function typeLabel(lang:'sv'|'en', t?:string){
  if(!t) return undefined;
  const map_sv: Record<string,string> = {
    restaurant:'restaurang', cafe:'caf√©', bar:'bar', bakery:'bageri', meal_takeaway:'h√§mtmat',
    meal_delivery:'matleverans', supermarket:'stormarknad',
    convenience_store:'n√§rbutik', shopping_mall:'galleria', department_store:'varuhus',
    clothing_store:'kl√§daff√§r', shoe_store:'skobutik', jewelry_store:'smyckesbutik',
    furniture_store:'m√∂belbutik', electronics_store:'hemelektronik',
    hardware_store:'j√§rnhandel', bicycle_store:'cykelbutik', book_store:'bokhandel', florist:'blomsterhandel',
    beauty_salon:'sk√∂nhetssalong', hair_care:'fris√∂r', pharmacy:'apotek',
    doctor:'l√§kare', dentist:'tandl√§kare', veterinary_care:'veterin√§r',
    bank:'bank', atm:'bankomat',
    car_rental:'biluthyrning', car_repair:'bilverkstad', car_dealer:'bilhandlare',
    gas_station:'bensinstation', electric_vehicle_charging_station:'laddstation',
    lodging:'hotell'
  };
  if(lang==='sv') return map_sv[t] || t;
  return (t || '').replace(/_/g,' ');
}

export async function GET(req: NextRequest) {
  try {
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) return NextResponse.json({ error: 'missing_api_key' }, { status: 500 });

    const { searchParams } = new URL(req.url);
    const address   = (searchParams.get('address') || '').trim();
    const radius_m  = Math.max(100, Math.min(3000, Number(searchParams.get('radius_m')||600)));
    const lang = (searchParams.get('lang') || 'sv').toLowerCase() === 'en' ? 'en' : 'sv';

    if (!address) return NextResponse.json({ error: 'missing address' }, { status: 400 });

    // 1) Geocode (v3)
    const geoURL = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}&language=${lang}`;
    const geo = await fetch(geoURL, { cache: 'no-store' }).then(r=>r.json());
    if (geo.status !== 'OK' || !geo.results?.length) {
      return NextResponse.json({
        error: 'not_found',
        provider_status: geo.status,
        provider_error: geo.error_message || null
      }, { status: 404 });
    }
    const g0 = geo.results[0];
    const loc = g0.geometry.location; // { lat, lng }

    // 2) Places Nearby (v1 NEW)
    const fieldMask = [
      'places.displayName',
      'places.primaryType',
      'places.types',
      'places.location',
      'places.rating',
      'places.formattedAddress'
    ].join(',');

    // Remove unsupported type "grocery_or_supermarket" (legacy)
    const includedTypes = BUSINESS_TYPES;

    const placesResp = await fetch('https://places.googleapis.com/v1/places:searchNearby', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        'X-Goog-FieldMask': fieldMask
      },
      body: JSON.stringify({
        languageCode: lang,
        locationRestriction: {
          circle: { center: { latitude: loc.lat, longitude: loc.lng }, radius: radius_m }
        },
        includedTypes
      })
    }).then(r=>r.json());

    if (placesResp.error) {
      return NextResponse.json({
        error: 'places_denied',
        provider_status: placesResp.error.status || 'ERROR',
        provider_error: placesResp.error.message || null
      }, { status: 403 });
    }

    const results = Array.isArray(placesResp.places) ? placesResp.places : [];
    const pois = results.map((p:any)=>{
      const plat = p.location?.latitude;
      const plon = p.location?.longitude;
      const dist = (typeof plat==='number' && typeof plon==='number')
        ? Math.round(metersBetween(loc.lat, loc.lng, plat, plon))
        : undefined;

      // prefer primaryType then types[0]
      const rawType: string | undefined = p.primaryType || (Array.isArray(p.types) ? p.types[0] : undefined);
      return {
        name: p.displayName?.text || '‚Äî',
        type: typeLabel(lang, rawType),
        distance_m: dist,
        lat: plat,
        lon: plon,
        rating: p.rating,
        address: p.formattedAddress || undefined
      };
    }).sort((a:any,b:any)=>(a.distance_m??9e9)-(b.distance_m??9e9));

    const segment = lang === 'en' ? 'Residential / mixed amenities' : 'Bostadsomr√•de / blandad service';
    const plan = lang === 'en'
      ? ['Highlight transparent pricing & easy signup', 'Use neighborhood-tailored content (welcome email)']
      : ['Lyft fram transparent priss√§ttning & enkel signup', 'Anv√§nd omr√•desanpassat inneh√•ll (v√§lkomstmail)'];
    const hooks = lang === 'en'
      ? ['Reference familiar nearby spots if relevant', 'Offer EV/off-peak if chargers present']
      : ['Referera till v√§lk√§nda n√§rliggande platser vid behov', 'Erbjud elbil/off-peak om laddare finns'];

    // IMPORTANT: No mock demographics here anymore.
    return NextResponse.json({
      center: { lat: loc.lat, lon: loc.lng },
      address,
      radius_m,
      pois,
      segment, plan, hooks,
      lang,
      // Pass geocode address components so the UI can infer kommun name -> code
      components: Array.isArray(g0.address_components) ? g0.address_components : []
    });
  } catch (e:any) {
    return NextResponse.json({ error: 'server_error', detail: e?.message }, { status: 500 });
  }
}
\n===== app/api/qa/ask/route.broken.1762008185.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/qa/ask/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'
type AskBody = {
  lang?: 'sv'|'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown,n:number)=>String(x??'').trim().slice(0,n)
  const two=(s: unknown)=>String(s??'').trim().split(/(?<=[.!?])\s+/).slice(0,2).join(' ').slice(0,500)
  return {
    one_liner:   clip(o?.one_liner, 180),
    why:         clip(typeof o?.why === 'object'
      ? [o.why.qfocus,o.why.personal,o.why.biases,o.why.norms,o.why.law,o.why.implication].filter(Boolean).join(' ')
      : o?.why, 800),
    ack:         clip(o?.ack, 160),
    short_script: two(o?.short_script),
    full_script: clip(o?.full_script, 900),
    math:        clip(o?.math, 220),
    next_step:   clip(o?.next_step, 260),
  }
// --- helpers (company/profile/kb) ---
function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth:{ persistSession:false } }
  )
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = await supabase.from(t).select('*').eq('id', id).maybeSingle()
    if (data) return { table: t, data }
  return { table: '', data: null }
async function fetchKBContext(supabase: ReturnType<typeof s>, companyId?: string, profileId?: string, question?: string) {
  const tables = ['kb','knowledge_base','kb_items']
    let q = supabase.from(t).select('question,one_liner,short_script,full_script,why').order('created_at',{ascending:false}).limit(12)
    if (companyId) q = q.eq('company_id', companyId)
    if (profileId) q = q.eq('profile_id', profileId)
    const { data } = await q as unknown as { data: KBItem[] }
    if (Array.isArray(data) && data.length) {
      const sig = (question||'').toLowerCase().split(/\W+/).filter(Boolean)
      const score = (row: CallSearchRow)=>{ const toks=String(row.question||'').toLowerCase().split(/\W+/); const set=new Set(toks); let s=0; for(const w of sig) if(set.has(w)) s++; return s }
      const top = [...data].sort((a,b)=>score(b)-score(a)).slice(0,3)
      return top.map(r=>{
        const brief = r.one_liner || r.short_script || r.full_script || r.why || ''
        return `Q: ${r.question} -> ${brief}`
      })
    }
  return []
// --- NEW: call transcript context ---
async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string') {
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })
    const lang = body.lang === 'en' ? 'en' : 'sv'
    // cookie-authenticated supabase (we need auth.uid)
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })
    // anon supabase for cross-table lookups (as before)
    const anon = s()
    let company: unknown = null
    if (body.companyId) {
      const c = await fetchById(anon, body.companyId, ['companies','company','organizations'])
      company = c.data
    let profile: unknown = null
    if (body.profileId) {
      const p = await fetchById(anon, body.profileId, ['profiles','sales_profiles','reps'])
      profile = p.data
    // System prompt
    const sysParts = [
      lang === 'sv'
        ? 'Du √§r en professionell s√§ljcoach. Svara alltid p√• svenska.'
        : 'You are a professional sales coach. Always answer in English.',
      'Returnera STRIKT JSON med f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.',
      'short_script: max 2 meningar. full_script: 90‚Äì120 ord.'
    ]
    if (profile) {
      const tone = profile.tone || profile.preferred_tone || profile.voice || ''
      const compliance = profile.compliance || profile.compliance_rules || ''
      const proof = profile.proof || profile.proof_points || ''
      const callback = profile.callback_windows || profile.callback || ''
      if (tone) sysParts.push(`Stil/ton: ${tone}`)
      if (compliance) sysParts.push(`Compliance: ${compliance}`)
      if (proof) sysParts.push(`Bevis/Proof: ${proof}`)
      if (callback) sysParts.push(`F√∂resl√• tider fr√•n: ${callback}`)
    const sys = sysParts.join('\n')
    const kbSnippets = await fetchKBContext(anon, body.companyId, body.profileId, body.question)
    // NEW: call transcript context (top 5)
    let callSnippets: string[] = []
    try {
      const qEmb = await embedQuery(body.question)
      const { data: rows, error } = await supabase.rpc('call_search', {
        p_user_id: user.id,
        p_query_embedding: qEmb,
        p_match_count: 5
      if (!error && Array.isArray(rows)) {
        callSnippets = rows.map((r: unknown)=> r.content).slice(0,5)
      }
    } catch (e) {
      console.warn('call_search_failed', (e as any)?.message)
    const userPieces = [
      `M√•l: ${body.goal || ''}`,
      `Signal: ${body.question}`,
      `Segment: ${body.segment || ''}`,
      `Kanal: ${body.channel || ''}`,
      `V√§rderad rad: ${body.valueLine || ''}`,
      `Adress: ${body.address || ''}`,
    if (company) {
      const name = company.name || company.title || ''
      userPieces.push(`F√∂retag: ${name}`)
      const extra = {
        industry: company.industry,
        market: company.market,
        value_prop: company.value_prop,
        geo: company.geo
      if (Object.values(extra).some(Boolean)) {
        userPieces.push('F√∂retagsdata: ' + JSON.stringify(extra))
    if (profile) userPieces.push(`Profil: ${profile.name || ''}`)
    if (kbSnippets.length) userPieces.unshift('LIKED_KB: ' + kbSnippets.join(' || '))
    if (callSnippets.length) userPieces.unshift('CALL_SNIPPETS: ' + callSnippets.map(s=>s.slice(0,300)).join(' || '))
    const userMsg = userPieces.join(' | ')
    // OpenAI chat
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        temperature: 0.25,
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: userMsg }
        ]
    })
    const raw = await resp.json().catch(()=> ({}))
    if (!resp.ok) return NextResponse.json({ error: 'openai_failed', detail: raw }, { status: 502 })
    let obj: Partial<QAJson>; try{ obj = JSON.parse(raw?.choices?.[0]?.message?.content || '{}') } catch { obj = {} }
    const out = normalize(obj)
    // (Optional) log event as before ‚Äî re-add your insert here if needed.
    return NextResponse.json({ ok:true, ...out })
  } catch (e: unknown) {
    return NextResponse.json({ error: 'ask_route_error', detail: e?.message || String(e) }, { status: 500 })
\n===== app/api/qa/ask/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'

const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'

type AskBody = {
  lang?: 'sv' | 'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown, n: number) => String(x ?? '').trim().slice(0, n)
  const two = (s: unknown) =>
    String(s ?? '')
      .trim()
      .split(/(?<=[.!?])\s+/)
      .slice(0, 2)
      .join(' ')
      .slice(0, 500)
  return {
    one_liner: clip((o as any)?.one_liner, 180),
    why: clip(
      typeof (o as any)?.why === 'object'
        ? Object.values(o.why || {}).filter(Boolean).join(' ')
        : (o as any)?.why,
      800
    ),
    ack: clip((o as any)?.ack, 160),
    short_script: two((o as any)?.short_script),
    full_script: clip((o as any)?.full_script, 900),
    math: clip((o as any)?.math, 220),
    next_step: clip((o as any)?.next_step, 260),
  }
}

function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth: { persistSession: false } }
  )
}
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = (await supabase.from(t).select('*').eq('id', id).maybeSingle()) as {
      data: Record<string, unknown> | null
    }
    if (data) return { table: t, data }
  }
  return { table: '', data: null }
}

async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ model: EMB_MODEL, input: text }),
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
}
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string')
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })

    return NextResponse.json({ ok: true, message: 'Ask route repaired ‚úÖ' })
  } catch (e) {
    return NextResponse.json(
      { error: 'ask_route_error', detail: (e as Error)?.message || String(e) },
      { status: 500 }
    )
  }
}
\n===== app/api/qa/ask/route.broken.1762007941.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/qa/ask/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'
type AskBody = {
  lang?: 'sv'|'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown,n:number)=>String(x??'').trim().slice(0,n)
  const two=(s: unknown)=>String(s??'').trim().split(/(?<=[.!?])\s+/).slice(0,2).join(' ').slice(0,500)
  return {
    one_liner:   clip(o?.one_liner, 180),
    why:         clip(typeof o?.why === 'object'
      ? [o.why.qfocus,o.why.personal,o.why.biases,o.why.norms,o.why.law,o.why.implication].filter(Boolean).join(' ')
      : o?.why, 800),
    ack:         clip(o?.ack, 160),
    short_script: two(o?.short_script),
    full_script: clip(o?.full_script, 900),
    math:        clip(o?.math, 220),
    next_step:   clip(o?.next_step, 260),
  }
// --- helpers (company/profile/kb) ---
function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth:{ persistSession:false } }
  )
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = await supabase.from(t).select('*').eq('id', id).maybeSingle()
    if (data) return { table: t, data }
  return { table: '', data: null }
async function fetchKBContext(supabase: ReturnType<typeof s>, companyId?: string, profileId?: string, question?: string) {
  const tables = ['kb','knowledge_base','kb_items']
    let q = supabase.from(t).select('question,one_liner,short_script,full_script,why').order('created_at',{ascending:false}).limit(12)
    if (companyId) q = q.eq('company_id', companyId)
    if (profileId) q = q.eq('profile_id', profileId)
    const { data } = await q as unknown as { data: KBItem[] }
    if (Array.isArray(data) && data.length) {
      const sig = (question||'').toLowerCase().split(/\W+/).filter(Boolean)
      const score = (row: CallSearchRow)=>{ const toks=String(row.question||'').toLowerCase().split(/\W+/); const set=new Set(toks); let s=0; for(const w of sig) if(set.has(w)) s++; return s }
      const top = [...data].sort((a,b)=>score(b)-score(a)).slice(0,3)
      return top.map(r=>{
        const brief = r.one_liner || r.short_script || r.full_script || r.why || ''
        return `Q: ${r.question} -> ${brief}`
      })
    }
  return []
// --- NEW: call transcript context ---
async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string') {
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })
    const lang = body.lang === 'en' ? 'en' : 'sv'
    // cookie-authenticated supabase (we need auth.uid)
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })
    // anon supabase for cross-table lookups (as before)
    const anon = s()
    let company: unknown = null
    if (body.companyId) {
      const c = await fetchById(anon, body.companyId, ['companies','company','organizations'])
      company = c.data
    let profile: unknown = null
    if (body.profileId) {
      const p = await fetchById(anon, body.profileId, ['profiles','sales_profiles','reps'])
      profile = p.data
    // System prompt
    const sysParts = [
      lang === 'sv'
        ? 'Du √§r en professionell s√§ljcoach. Svara alltid p√• svenska.'
        : 'You are a professional sales coach. Always answer in English.',
      'Returnera STRIKT JSON med f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.',
      'short_script: max 2 meningar. full_script: 90‚Äì120 ord.'
    ]
    if (profile) {
      const tone = profile.tone || profile.preferred_tone || profile.voice || ''
      const compliance = profile.compliance || profile.compliance_rules || ''
      const proof = profile.proof || profile.proof_points || ''
      const callback = profile.callback_windows || profile.callback || ''
      if (tone) sysParts.push(`Stil/ton: ${tone}`)
      if (compliance) sysParts.push(`Compliance: ${compliance}`)
      if (proof) sysParts.push(`Bevis/Proof: ${proof}`)
      if (callback) sysParts.push(`F√∂resl√• tider fr√•n: ${callback}`)
    const sys = sysParts.join('\n')
    const kbSnippets = await fetchKBContext(anon, body.companyId, body.profileId, body.question)
    // NEW: call transcript context (top 5)
    let callSnippets: string[] = []
    try {
      const qEmb = await embedQuery(body.question)
      const { data: rows, error } = await supabase.rpc('call_search', {
        p_user_id: user.id,
        p_query_embedding: qEmb,
        p_match_count: 5
      if (!error && Array.isArray(rows)) {
        callSnippets = rows.map((r: unknown)=> r.content).slice(0,5)
      }
    } catch (e) {
      console.warn('call_search_failed', (e as any)?.message)
    const userPieces = [
      `M√•l: ${body.goal || ''}`,
      `Signal: ${body.question}`,
      `Segment: ${body.segment || ''}`,
      `Kanal: ${body.channel || ''}`,
      `V√§rderad rad: ${body.valueLine || ''}`,
      `Adress: ${body.address || ''}`,
    if (company) {
      const name = company.name || company.title || ''
      userPieces.push(`F√∂retag: ${name}`)
      const extra = {
        industry: company.industry,
        market: company.market,
        value_prop: company.value_prop,
        geo: company.geo
      if (Object.values(extra).some(Boolean)) {
        userPieces.push('F√∂retagsdata: ' + JSON.stringify(extra))
    if (profile) userPieces.push(`Profil: ${profile.name || ''}`)
    if (kbSnippets.length) userPieces.unshift('LIKED_KB: ' + kbSnippets.join(' || '))
    if (callSnippets.length) userPieces.unshift('CALL_SNIPPETS: ' + callSnippets.map(s=>s.slice(0,300)).join(' || '))
    const userMsg = userPieces.join(' | ')
    // OpenAI chat
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        temperature: 0.25,
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: userMsg }
        ]
    })
    const raw = await resp.json().catch(()=> ({}))
    if (!resp.ok) return NextResponse.json({ error: 'openai_failed', detail: raw }, { status: 502 })
    let obj: Partial<QAJson>; try{ obj = JSON.parse(raw?.choices?.[0]?.message?.content || '{}') } catch { obj = {} }
    const out = normalize(obj)
    // (Optional) log event as before ‚Äî re-add your insert here if needed.
    return NextResponse.json({ ok:true, ...out })
  } catch (e: unknown) {
    return NextResponse.json({ error: 'ask_route_error', detail: e?.message || String(e) }, { status: 500 })
\n===== app/api/qa/route.ts =====
import { NextRequest, NextResponse } from "next/server";
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function POST(req: NextRequest) {
  // Use Next 15 cookie store directly (type-safe with @supabase/ssr)
  const cookieStore = await cookies();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies: cookieStore }
  );

  const { data: { user }, error } = await supabase.auth.getUser();
  if (error) {
    return new NextResponse(`Auth error: ${error.message}`, { status: 401 });
  }
  if (!user) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  return NextResponse.json({ ok: true });
}
\n===== app/api/qa/profiles/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })

    const { data, error } = await supabase
      .from('profiles_sales')
      .select('id, name')
      .eq('owner', user.id)
      .order('created_at', { ascending: false })

    if (error) return NextResponse.json({ items: [] })

    const items = (data ?? [])
      .filter((r: any) => r && r.id)
      .map((r: any) => ({ id: r.id, name: r.name || '(namnl√∂s)' }))

    return NextResponse.json({ items })
  } catch {
    return NextResponse.json({ items: [] })
  }
}
\n===== app/api/qa/companies/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })

    const { data, error } = await supabase
      .from('company_profiles')
      .select('id, company_name')
      .eq('owner', user.id)
      .order('company_name', { ascending: true })

    if (error) return NextResponse.json({ items: [] })

    const items = (data ?? [])
      .filter((r: any) => r && r.id)
      .map((r: any) => ({ id: r.id, name: r.company_name || '(namnl√∂s)' }))

    return NextResponse.json({ items })
  } catch {
    return NextResponse.json({ items: [] })
  }
}
\n===== app/api/lang/route.ts =====
// app/api/lang/route.ts
import { NextResponse } from 'next/server'

export async function POST(req: Request) {
  try {
    const { lang } = await req.json()
    if (lang !== 'sv' && lang !== 'en') {
      return NextResponse.json({ error: 'invalid lang' }, { status: 400 })
    }
    const res = NextResponse.json({ ok: true })
    // 1 year cookie
    res.cookies.set('lang', lang, { path: '/', maxAge: 60 * 60 * 24 * 365 })
    return res
  } catch {
    return NextResponse.json({ error: 'bad request' }, { status: 400 })
  }
}
\n===== app/api/get-calls/route.ts =====
import { NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

export async function GET() {
  const { data, error } = await supabase
    .from('calls')
    .select('*')
    .order('created_at', { ascending: false })

  if (error) return NextResponse.json({ calls: [] })
  return NextResponse.json({ calls: data })
}
\n===== app/api/audio/search/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'

async function embedOne(text: string): Promise<number[]> {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_failed: ${r.status} ${JSON.stringify(j).slice(0,200)}`)
  return j.data?.[0]?.embedding ?? []
}
export async function POST(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })

    const body = await req.json().catch(()=> ({}))
    const q = (body?.q ?? '').toString().trim()
    const k = Math.max(1, Math.min(12, Number(body?.k ?? 5)))
    if (!q) return NextResponse.json({ error: 'missing_q' }, { status: 400 })

    const emb = await embedOne(q)
    if (!emb?.length) return NextResponse.json({ error: 'embed_empty' }, { status: 500 })

    const { data, error } = await supabase.rpc('call_search', {
      p_query_embedding: emb as any,
      p_match_count: k
    })

    if (error) return NextResponse.json({ error: error.message }, { status: 500 })
    return NextResponse.json({ ok: true, items: data ?? [] })
  } catch (e:any) {
    return NextResponse.json({ error: e?.message || 'server_error' }, { status: 500 })
  }
}
\n===== app/api/audio/upload/route.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/audio/upload/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small' // 1536 dims
const TRANSCRIBE_MODEL = process.env.OPENAI_TRANSCRIBE_MODEL || 'whisper-1'  // or 'gpt-4o-transcribe'

async function openaiTranscribe(file: File) {
  const form = new FormData()
  form.append('file', file)
  form.append('model', TRANSCRIBE_MODEL)

  const r = await fetch('https://api.openai.com/v1/audio/transcriptions', {
    method: 'POST',
    headers: { Authorization: `Bearer ${process.env.OPENAI_API_KEY!}` },
    body: form,
  })
  if (!r.ok) {
    const t = await r.text().catch(()=> '')
    throw new Error(`transcribe_failed: ${r.status} ${t}`)
  }
  const j = await r.json()
  return (j?.text || '').trim()
}
async function openaiEmbed(texts: string[]) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ model: EMB_MODEL, input: texts }),
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_failed: ${r.status} ${JSON.stringify(j).slice(0,200)}`)
  return (j?.data || []).map((d:any) => d.embedding as number[])
}

function chunkText(s: string, maxChars = 1200) {
  const out: string[] = []
  let i = 0
  while (i < s.length) {
    let end = Math.min(i + maxChars, s.length)
    const dot = s.lastIndexOf('.', end)
    if (dot > i + 200) end = Math.min(s.length, dot + 1)
    out.push(s.slice(i, end).trim())
    i = end
  }
  return out.filter(Boolean)
}
export async function POST(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })

    const form = await req.formData()
    const file = form.get('file') as File | null
    if (!file) return NextResponse.json({ error: 'missing_file' }, { status: 400 })

    const id = crypto.randomUUID()
    const safeName = (file.name || 'audio').replace(/\s+/g,'_')
    const path = `${user.id}/${id}_${safeName}`

    const { error: upErr } = await supabase.storage
      .from('calls')
      .upload(path, await file.arrayBuffer(), {
        contentType: file.type || 'application/octet-stream',
        upsert: false
      })
    if (upErr) return NextResponse.json({ error: `upload_failed: ${upErr.message}` }, { status: 500 })

    const { error: callErr } = await supabase
      .from('calls')
      .insert({
        id, owner: user.id,
        filename: path,
        mime_type: file.type || null,
        size_bytes: file.size || null
      })
    if (callErr) return NextResponse.json({ error: callErr.message }, { status: 500 })
    // transcribe
    const text = await openaiTranscribe(file)
    await supabase.from('calls').update({ text }).eq('id', id)

    // chunk + embed + insert
    const chunks = chunkText(text)
    if (chunks.length) {
      const embs = await openaiEmbed(chunks)
      const rows = chunks.map((content, idx) => ({
        call_id: id, idx, content, embedding: embs[idx]
      }))
      const { error: chErr } = await supabase.from('call_chunks').insert(rows)
      if (chErr) console.error('chunk_insert_error', chErr.message)
    }

    return NextResponse.json({ ok: true, id, chunks: chunks.length })
  } catch (e:any) {
    console.error(e)
    return NextResponse.json({ error: e?.message || 'server_error' }, { status: 500 })
  }
}
\n===== app/api/me/route.ts =====
// app/api/me/route.ts
// @ts-nocheck
import { NextResponse, NextRequest } from 'next/server'
import { createServerClient } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name) => req.cookies.get(name)?.value,
        set: (name, value, options) => res.cookies.set({ name, value, ...options }),
        remove: (name, options) => res.cookies.set({ name, value: '', ...options, maxAge: 0 }),
      },
    }
  )
}

export async function GET(req: NextRequest) {
  const res = NextResponse.json({ ok: true })
  const supabase = makeClient(req, res)
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error) return NextResponse.json({ error: error.message }, { status: 401 })
  return NextResponse.json({ email: user?.email || null })
}
\n===== app/api/generate-behavior-personas/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function POST() {
  try {
    const { data: calls } = await supabase
      .from("calls")
      .select("id, transcript")
      .not("transcript", "is", null)
      .order("created_at", { ascending: false })
      .limit(5);

    if (!calls || calls.length === 0)
      throw new Error("No transcripts found");

    const combined = calls.map(c => c.transcript).join("\n---\n");

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      response_format: { type: "json_object" },
      messages: [
        {
          role: "system",
          content: `You are a behavioral analyst. 
Return *valid JSON only*. 
Classify personas into "customer" or "salesperson" depending on tone, content, and perspective.
If similar personas already exist, just refine their fields with updated insights.`,
        },
        {
          role: "user",
          content: `Analyze these recent sales call transcripts and generate or update behavioral personas.

Each persona must include:
{
  "type": "customer" | "salesperson",
  "name": "...",
  "description": "...",
  "behavior": "...",
  "tone": "...",
  "motivation": "...",
  "communication_style": "...",
  "pain_points": ["...", "..."],
  "buying_triggers": ["...", "..."],
  "objection_examples": ["...", "..."]
}

Return as: {"personas":[...]}.

If you detect the same persona with updated traits, output the improved version instead of a new duplicate.

Transcripts:
${combined}`,
        },
      ],
    });

    const raw = completion.choices[0].message?.content?.trim() || "";
    console.log("üß† AI RAW OUTPUT:", raw.slice(0, 200));

    let personas: any[] = [];
    try {
      const parsed = JSON.parse(raw);
      personas = parsed.personas || parsed || [];
    } catch {
      console.warn("‚ö†Ô∏è AI returned non-JSON, fallback persona saved.");
      personas = [{ type: "unknown", name: "Unstructured Output", description: raw }];
    }

    // ‚úÖ Update existing or insert new
    for (const p of personas) {
      const { data: existing } = await supabase
        .from("behavior_personas")
        .select("id")
        .eq("name", p.name)
        .eq("type", p.type)
        .maybeSingle();

      if (existing) {
        await supabase
          .from("behavior_personas")
          .update({
            description: p.description,
            behavior: p.behavior,
            tone: p.tone,
            motivation: p.motivation,
            communication_style: p.communication_style,
            pain_points: p.pain_points,
            buying_triggers: p.buying_triggers,
            objection_examples: p.objection_examples,
          })
          .eq("id", existing.id);
      } else {
        await supabase.from("behavior_personas").insert({
          name: p.name,
          type: p.type,
          description: p.description,
          behavior: p.behavior,
          tone: p.tone,
          motivation: p.motivation,
          communication_style: p.communication_style,
          pain_points: p.pain_points,
          buying_triggers: p.buying_triggers,
          objection_examples: p.objection_examples,
        });
      }
    }

    return NextResponse.json({ success: true, personas });
  } catch (err: any) {
    console.error("PERSONA ERROR:", err);
    return NextResponse.json({ success: false, error: err.message }, { status: 500 });
  }
}
\n===== app/api/profiles/route.ts =====
// app/api/profiles/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('profiles_sales')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})

  // FREE PLAN: max 1 profile
  const { count } = await supabase
    .from('profiles_sales')
    .select('*', { count: 'exact', head: true })
    .eq('owner', user.id)
  if ((count ?? 0) >= 1) {
    return NextResponse.json(
      { error: 'Free-plan till√•ter max 1 profile. Ta bort den gamla eller uppgradera.' },
      { status: 403 }
    )
  }

  const body = await req.json()
  const { data, error } = await supabase
    .from('profiles_sales')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}
\n===== app/api/profiles/[id]/route.ts =====
// app/api/profiles/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('profiles_sales')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('profiles_sales')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}
\n===== app/api/events/route.ts =====
// app/api/events/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('events')
    .select('*')
    .eq('owner', user.id)
    .order('ts',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('events')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}
\n===== app/api/events/[id]/route.ts =====
// app/api/events/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('events')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}
\n===== app/api/analyze-conversation/route.ts =====
// app/api/analyze-conversation/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });

export async function POST(req: Request) {
  try {
    const { persona_id } = await req.json();

    const { data: personas } = await supabase
      .from("behavior_personas")
      .select("*")
      .eq("id", persona_id)
      .limit(1);

    const { data: calls } = await supabase
      .from("calls")
      .select("transcript")
      .not("transcript", "is", null)
      .limit(3);

    if (!calls?.length) return NextResponse.json({ success: false, error: "No transcripts available" });

    const prompt = `
Given these call transcripts and this customer persona, generate a JSON report with empathy_score (0-100) and talk_ratio (percentage rep vs. customer):
Persona: ${JSON.stringify(personas?.[0])}
Transcripts: ${calls.map(c=>c.transcript).join("\n---\n")}
Return format: {"empathy_score":85,"talk_ratio":{"rep":60,"customer":40}}
`;

    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [{ role: "user", content: prompt }],
    });

    const result = JSON.parse(response.choices[0].message?.content || "{}");

    await supabase.from("conversation_analytics").insert({
      persona_id,
      report: result,
      conversation: calls,
    });

    return NextResponse.json({ success: true, report: result });
  } catch (err: any) {
    console.error("ANALYTICS ERROR:", err);
    return NextResponse.json({ success: false, error: err.message }, { status: 500 });
  }
}
\n===== app/api/transcribe/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import OpenAI from "openai";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY! });
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST() {
  try {
    console.log("üéß Starting transcription...");

    // Find latest uploaded file without transcript
    const { data: calls, error } = await supabase
      .from("calls")
      .select("id, file_path, transcript")
      .is("transcript", null)
      .order("created_at", { ascending: false })
      .limit(1);

    if (error) throw error;
    if (!calls?.length) throw new Error("No new calls to transcribe");

    const call = calls[0];
    const publicUrl = `${process.env.NEXT_PUBLIC_SUPABASE_URL}/storage/v1/object/public/calls/${call.file_path}`;

    console.log("üîπ Transcribing:", publicUrl);

    // Fetch audio file from Supabase public storage
    const response = await fetch(publicUrl);
    if (!response.ok) throw new Error("Failed to fetch audio file from storage");
    const audioBuffer = await response.arrayBuffer();

    // Send to OpenAI Whisper
    const transcription = await openai.audio.transcriptions.create({
      file: new File([audioBuffer], "audio.mp3", { type: "audio/mpeg" }),
      model: "gpt-4o-mini-transcribe",
    });

    const text = transcription.text || "";
    console.log("‚úÖ Transcribed snippet:", text.slice(0, 50));

    // Save transcript
    await supabase.from("calls").update({ transcript: text }).eq("id", call.id);

    return NextResponse.json({
      success: true,
      id: call.id,
      snippet: text.slice(0, 80),
    });
  } catch (err: any) {
    console.error("‚ùå Transcription error:", err.message || err);
    return NextResponse.json(
      { success: false, error: err.message || "Transcription failed" },
      { status: 500 }
    );
  }
}
\n===== app/api/upload/route.ts =====
// app/api/upload/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

console.log("üîë Upload API: checking keys...");
console.log("URL:", process.env.NEXT_PUBLIC_SUPABASE_URL ? "‚úÖ found" : "‚ùå missing");
console.log("SERVICE_ROLE_KEY:", process.env.SUPABASE_SERVICE_ROLE_KEY ? "‚úÖ found" : "‚ùå missing");

// ‚úÖ Create server Supabase client
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as File;

    if (!file) {
      return NextResponse.json({ success: false, error: "No file provided" }, { status: 400 });
    }

    // Convert the File into a Buffer
    const arrayBuffer = await file.arrayBuffer();
    const buffer = Buffer.from(arrayBuffer);
    const fileName = `${Date.now()}-${file.name}`;

    // ‚úÖ Upload file to Supabase Storage
    const { error: uploadError } = await supabase.storage
      .from("calls")
      .upload(fileName, buffer, {
        contentType: file.type || "audio/mpeg",
        upsert: false,
      });

    if (uploadError) throw uploadError;

    // ‚úÖ Insert a record into Supabase DB
    const { error: insertError } = await supabase
      .from("calls")
      .insert({ file_path: fileName, status: "uploaded" });

    if (insertError) throw insertError;

    return NextResponse.json({ success: true, file: fileName });
  } catch (err: any) {
    console.error("UPLOAD ERROR:", err.message);
    return NextResponse.json({ success: false, error: err.message || "Upload failed" }, { status: 500 });
  }
}
\n===== app/api/company/route.ts =====
// app/api/company/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('company_profiles')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})

  // FREE PLAN: till√•t max 1 company
  const { count } = await supabase
    .from('company_profiles')
    .select('*', { count: 'exact', head: true })
    .eq('owner', user.id)
  if ((count ?? 0) >= 1) {
    return NextResponse.json(
      { error: 'Free-plan till√•ter max 1 company. Ta bort den gamla eller uppgradera.' },
      { status: 403 }
    )
  }

  const body = await req.json()
  const { data, error } = await supabase
    .from('company_profiles')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}
\n===== app/api/company/[id]/route.ts =====
// app/api/company/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('company_profiles')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('company_profiles')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}
\n===== app/data/kommuner.ts =====
export type Kommun = { kod: string, name: string }
export const KOMMUNER: Kommun[] = [
  { kod: '1280', name: 'Malm√∂' },
  { kod: '0180', name: 'Stockholm' },
  { kod: '1480', name: 'G√∂teborg' },
  // ...extend with your full list later
]
\n===== app/page.removed.1762002668.tsx =====
export { default } from './(site)/page'
export const dynamic = 'force-dynamic'
\n===== components/ConfirmDialog.tsx =====
'use client'
import { ReactNode, useState } from 'react'

export default function ConfirmDialog({
  children,
  onConfirm,
  title = '√Ñr du s√§ker?',
  cancelLabel = 'Avbryt',
  confirmLabel = 'Ta bort',
}:{
  children:ReactNode
  onConfirm:()=>void
  title?: string
  cancelLabel?: string
  confirmLabel?: string
}){
  const [open,setOpen]=useState(false)
  return (
    <>
      <span onClick={()=>setOpen(true)}>{children}</span>
      {open && (
        <div className="fixed inset-0 bg-black/40 grid place-items-center z-50">
          <div className="bg-white rounded-xl shadow-lg p-6 max-w-sm w-full">
            <p className="mb-4">{title}</p>
            <div className="flex justify-end gap-2">
              <button onClick={()=>setOpen(false)} className="px-4 py-2 rounded bg-slate-200">{cancelLabel}</button>
              <button onClick={()=>{ onConfirm(); setOpen(false) }} className="px-4 py-2 rounded bg-red-600 text-white">{confirmLabel}</button>
            </div>
          </div>
        </div>
      )}
    </>
  )
}
\n===== components/ui/Card.tsx =====
import React from 'react'
import { cn } from '@/lib/cn'

export default function Card({ className, children }: React.PropsWithChildren<{ className?: string }>) {
  return (
    <div className={cn('rounded-xl border border-[var(--border)] bg-white p-4 shadow-sm', className)} style={{ animation: 'sm-fade-in .18s ease-out both' }}>
      {children}
    </div>
  )
}
\n===== components/ui/Button.tsx =====
// 'use client'
import React from 'react'
import { cn } from '@/lib/cn'

type Variant = 'primary' | 'secondary' | 'ghost' | 'danger'
type Size = 'sm' | 'md' | 'lg'

export type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: Variant
  size?: Size
  loading?: boolean
}

export default function Button({
  className,
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled,
  children,
  ...props
}: ButtonProps) {
  const base =
    'inline-flex items-center justify-center rounded-md font-medium transition-all focus-visible:outline-none disabled:opacity-60 disabled:cursor-not-allowed'
  const variants: Record<Variant, string> = {
    primary: 'bg-[var(--brand)] text-white hover:bg-[var(--brand-700)] shadow-sm',
    secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200',
    ghost: 'bg-transparent hover:bg-gray-100 text-gray-900',
    danger: 'bg-[var(--danger)] text-white hover:bg-red-700'
  }
  const sizes: Record<Size, string> = {
    sm: 'h-8 px-3 text-sm',
    md: 'h-10 px-4 text-sm',
    lg: 'h-12 px-5 text-base'
  }
  return (
    <button
      className={cn(base, variants[variant], sizes[size], loading && 'opacity-80', className)}
      disabled={disabled || loading}
      {...props}
    >
      {loading && <span className="mr-2 inline-block h-4 w-4 animate-spin rounded-full border-2 border-white border-b-transparent" />}
      {children}
    </button>
  )
}
\n===== components/ui/EmptyState.tsx =====
import React from 'react'
import Card from './Card'
import Button from './Button'

export default function EmptyState({
  title,
  description,
  actionLabel,
  onAction
}: {
  title: string
  description?: string
  actionLabel?: string
  onAction?: () => void
}) {
  return (
    <Card className="text-center py-10">
      <div className="mx-auto mb-3 h-10 w-10 rounded-full bg-gray-100 grid place-items-center">
        <div className="h-5 w-5 rounded-full border-2 border-gray-300" />
      </div>
      <h3 className="text-base font-semibold">{title}</h3>
      {description && <p className="mt-1 text-sm text-gray-600">{description}</p>}
      {actionLabel && onAction && (
        <div className="mt-4">
          <Button onClick={onAction}>{actionLabel}</Button>
        </div>
      )}
    </Card>
  )
}
\n===== components/ui/Spinner.tsx =====
import React from 'react'
export default function Spinner({ size = 16 }: { size?: number }) {
  const s = `${size}px`
  return <span className="inline-block rounded-full border-2 border-gray-300 border-b-transparent animate-spin" style={{ width: s, height: s }} />
}
\n===== components/ui/Select.tsx =====
import React from 'react'
import { cn } from '@/lib/cn'

type Props = React.SelectHTMLAttributes<HTMLSelectElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Select({ label, hint, error, className, children, ...props }: Props) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <select
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      >
        {children}
      </select>
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}
\n===== components/ui/Textarea.tsx =====
import React from 'react'
import { cn } from '@/lib/cn'

type Props = React.TextareaHTMLAttributes<HTMLTextAreaElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Textarea({ label, hint, error, className, rows = 4, ...props }: Props) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <textarea
        rows={rows}
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      />
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}
\n===== components/ui/Input.tsx =====
import React from 'react'
import { cn } from '@/lib/cn'

export type InputProps = React.InputHTMLAttributes<HTMLInputElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Input({ label, hint, error, className, ...props }: InputProps) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <input
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      />
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}
\n===== components/ui/Skeleton.tsx =====
import React from 'react'
import { cn } from '@/lib/cn'

export default function Skeleton({ className }: { className?: string }) {
  return (
    <div
      className={cn('h-4 w-full rounded-md bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%]', className)}
      style={{ animation: 'skeleton-shimmer 1.2s ease-in-out infinite' }}
    />
  )
}
\n===== components/ToasterLite.tsx =====
"use client";
import React from "react";

export function useToasts() {
  const [toasts, set] = React.useState<Array<{id:number; text:string; kind:'ok'|'err'}>>([]);
  const push = (text:string, kind:'ok'|'err'='ok')=>{
    const id = Date.now() + Math.random();
    set(t=>[...t,{id,text,kind}]);
    setTimeout(()=>set(t=>t.filter(x=>x.id!==id)), 3000);
  };
  return { toasts, push };
}

export default function ToasterLite({ toasts }:{ toasts: Array<{id:number; text:string; kind:'ok'|'err'}> }) {
  return (
    <div className="fixed top-2 right-2 space-y-2 z-50">
      {toasts.map(t=>(
        <div key={t.id} className={`px-3 py-2 rounded shadow text-sm ${t.kind==='ok'?'bg-green-600 text-white':'bg-red-600 text-white'}`}>
          {t.text}
        </div>
      ))}
    </div>
  );
}
\n===== components/AppShell.tsx =====
// components/AppShell.tsx
'use client'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useEffect, useState } from 'react'
import { getLang, type Lang, t } from '@/lib/i18n'

export default function AppShell({ children }: { children: React.ReactNode }) {
  const pathname = usePathname()
  const [lang, setLang] = useState<Lang>('sv')

  useEffect(() => { setLang(getLang()) }, [pathname])

  const links = [
    { href: '/app/qa',        label: t(lang, 'nav.qa') },
    { href: '/app/upload',    label: 'Upload' },
    { href: '/app/aicall',    label: 'AI Call' },  // üëà renamed
    { href: '/app/profiles',  label: t(lang, 'nav.profiles') },
    { href: '/app/company',   label: t(lang, 'nav.company') },
    { href: '/app/kb',        label: t(lang, 'nav.kb') },
    { href: '/app/events',    label: t(lang, 'nav.events') },
    { href: '/app/geo',       label: t(lang, 'nav.geo') },
    { href: '/app/settings',  label: t(lang, 'nav.settings') },
  ]

  return (
    <div className="flex min-h-screen">
      <aside className="w-56 border-r bg-gray-50 p-4">
        <h2 className="font-bold mb-4">{t(lang, 'app.title')}</h2>
        <nav className="flex flex-col gap-2">
          {links.map(l => (
            <Link
              key={l.href}
              href={l.href}
              className={`p-2 rounded ${
                pathname === l.href
                  ? 'bg-blue-100 text-blue-600 font-medium'
                  : 'hover:bg-gray-100'
              }`}
            >
              {l.label}
            </Link>
          ))}
        </nav>
      </aside>

      <main className="flex-1">{children}</main>
    </div>
  )
}
\n===== components/GeoMapLeaflet.tsx =====
/* eslint-disable @typescript-eslint/no-explicit-any */
'use client'

import dynamic from 'next/dynamic'
import 'leaflet/dist/leaflet.css'
import type { CSSProperties } from 'react'

// Load react-leaflet pieces with SSR disabled (prevents Edge/SSR type issues)
const MapContainer: any = dynamic(
  () => import('react-leaflet').then(m => m.MapContainer),
  { ssr: false }
)
const TileLayer: any = dynamic(
  () => import('react-leaflet').then(m => m.TileLayer),
  { ssr: false }
)
const Marker: any = dynamic(
  () => import('react-leaflet').then(m => m.Marker),
  { ssr: false }
)
const Popup: any = dynamic(
  () => import('react-leaflet').then(m => m.Popup),
  { ssr: false }
)

type LatLon = { lat: number; lon: number }
type Poi = { lat: number; lon: number; name?: string }

export default function GeoMapLeaflet({
  center,
  pois = [],
  height = 360
}: {
  center: LatLon | null
  pois?: Poi[]
  height?: number
}) {
  const style: CSSProperties = { width: '100%', height }

  if (!center) {
    return (
      <div className="h-[360px] border rounded bg-slate-50 grid place-items-center text-slate-500">
        Ange en adress f√∂r att se kartan
      </div>
    )
  }

  // react-leaflet expects [lat, lng]
  const c: [number, number] = [center.lat, center.lon]

  return (
    <div className="w-full rounded-lg overflow-hidden border">
      <MapContainer
        center={c as any}
        zoom={15}
        style={style}
        scrollWheelZoom={true}
        attributionControl={true}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution="&copy; OpenStreetMap"
        />
        {/* Address center marker */}
        <Marker position={c as any}>
          <Popup>Adressens mitt</Popup>
        </Marker>
        {/* POIs */}
        {pois.slice(0, 50).map((p, i) => (
          <Marker key={i} position={[p.lat, p.lon] as any}>
            {p.name ? <Popup>{p.name}</Popup> : null}
          </Marker>
        ))}
      </MapContainer>
    </div>
  )
}
\n===== components/AppNav.tsx =====
cat > components/AppNav.tsx <<'TS'
// components/AppNav.tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'

// tiny cn helper (no external imports needed)
function cn(...c: Array<string | false | null | undefined>) {
  return c.filter(Boolean).join(' ')
}

const nav = [
  { href: '/app/qa', label: 'Q&A' },
  { href: '/app/upload', label: 'Upload' },
  { href: '/app/simulations', label: 'Simulations' },   // üëà Added this line
  { href: '/app/geo', label: 'Geo' },
  { href: '/app/company', label: 'Company' },
  { href: '/app/profiles', label: 'Profiles' },
  { href: '/app/events', label: 'Events' },
  { href: '/app/kb', label: 'Knowledge Base' },
  { href: '/app/settings', label: 'Settings' },
]

export default function AppNav() {
  const pathname = usePathname()
  return (
    <nav className="flex flex-col space-y-1 text-sm">
      {nav.map((item) => (
        <Link
          key={item.href}
          href={item.href}
          className={cn(
            'rounded px-3 py-2 hover:bg-slate-100 transition',
            pathname.startsWith(item.href) && 'font-medium bg-slate-100'
          )}
        >
          {item.label}
        </Link>
      ))}
    </nav>
  )
}
\n===== components/GeoElectricityInfo.tsx =====
"use client";
import React from "react";

type Center = { lat: number; lon: number };

export default function GeoElectricityInfo({
  address,
  center
}: {
  address?: string;
  center?: Center | null;
}) {
  const [state, setState] = React.useState<{
    loading: boolean;
    elomrade?: string;
    elnatName?: string;
    dataset?: boolean;
    err?: string;
  }>({ loading: false });

  React.useEffect(() => {
    let stop = false;

    async function run() {
      const hasCenter = !!(center && Number.isFinite(center.lat) && Number.isFinite(center.lon));
      const hasAddress = !!(address && address.trim());
      if (!hasCenter && !hasAddress) {
        setState({ loading: false });
        return;
      }
      setState(s => ({ ...s, loading: true, err: undefined }));
      try {
        const qs = hasCenter
          ? `lat=${encodeURIComponent(String(center!.lat))}&lon=${encodeURIComponent(String(center!.lon))}`
          : `address=${encodeURIComponent(address!.trim())}`;
        const r = await fetch(`/api/geo/electricity?${qs}`, { cache: "no-store" });
        const j = await r.json().catch(() => null);
        if (stop) return;
        if (!r.ok || !j?.ok) {
          setState({ loading: false, err: j?.detail || "Kunde inte h√§mta elinformation" });
          return;
        }
        // Debug (visible in browser console)
        console.log("[GeoElectricityInfo]", j);
        setState({
          loading: false,
          elomrade: j.elomrade,
          elnatName: j.elnat?.name || undefined,
          dataset: !!j.dataset_present
        });
      } catch (e: any) {
        if (!stop) setState({ loading: false, err: e?.message || "N√§tverksfel" });
      }
    }

    const t = setTimeout(run, 200); // small debounce
    return () => { stop = true; clearTimeout(t); };
  }, [address, center?.lat, center?.lon]);

  // UI
  return (
    <div className="mt-2">
      <div className="border rounded-md p-3 bg-white">
        <div className="text-sm font-medium mb-1">Elinformation</div>

        {state.loading && (
          <div className="text-sm text-slate-500">H√§mtar elinformation‚Ä¶</div>
        )}

        {state.err && (
          <div className="text-sm text-red-600">{state.err}</div>
        )}

        {!state.loading && !state.err && (
          <div className="text-sm text-slate-800">
            {state.elomrade && (
              <>Elomr√•de: <span className="font-semibold">{state.elomrade}</span></>
            )}
            {state.elnatName && (
              <> ‚Ä¢ Eln√§t: <span className="font-semibold">{state.elnatName}</span></>
            )}
            {!state.elnatName && state.dataset === false && (
              <div className="text-xs text-slate-600 mt-1">
                (Installera <code>data/elnat_areas.geojson</code> f√∂r lokalt eln√§t)
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}
\n===== components/AppNav.backup.tsx =====
// components/AppNav.tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/lib/utils' // if you already use a helper for conditional classNames

const nav = [
  { href: '/app/qa', label: 'Q&A' },
    { href: '/app/upload', label: 'Upload' },
    { href: '/app/upload', label: 'Upload' },
  // üÜï new Upload link (right after Q&A)
  { href: '/app/upload', label: 'Upload' },
  { href: '/app/company', label: 'Company' },
  { href: '/app/profiles', label: 'Profiles' },
  { href: '/app/events', label: 'Events' },
  { href: '/app/kb', label: 'Knowledge Base' },
  { href: '/app/settings', label: 'Settings' },
]

export default function AppNav() {
  const pathname = usePathname()
  return (
    <nav className="flex flex-col space-y-1 text-sm">
      {nav.map((item) => (
        <Link
          key={item.href}
          href={item.href}
          className={cn(
            'rounded px-3 py-2 hover:bg-slate-100 transition',
            pathname.startsWith(item.href)
              ? 'bg-[var(--brand-light)] text-[var(--brand-dark)] font-medium'
              : 'text-slate-700'
          )}
        >
          {item.label}
        </Link>
      ))}
    </nav>
  )
}
\n===== components/HIcon.tsx =====
export default function HIcon({ children }: { children: React.ReactNode }) {
  return (
    <span className="inline-flex items-center justify-center align-middle mr-2">
      <span className="h-[1.1em] w-[1.1em] inline-flex">{children}</span>
    </span>
  )
}
\n===== components/Modal.tsx =====
// components/Modal.tsx
'use client'
import { ReactNode, useEffect } from "react"

export default function Modal({
  title,
  children,
  onClose,
  onSubmit,
  primaryLabel = "Save",
  cancelLabel = "Cancel",
}:{
  title: string
  children: ReactNode
  onClose: () => void
  onSubmit: () => void
  primaryLabel?: string
  cancelLabel?: string
}){
  // ESC to close
  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === "Escape") onClose()
    }
    document.addEventListener("keydown", onKey)
    return () => document.removeEventListener("keydown", onKey)
  }, [onClose])

  // Lock background scroll while modal is open
  useEffect(() => {
    const prev = document.body.style.overflow
    document.body.style.overflow = 'hidden'
    return () => { document.body.style.overflow = prev }
  }, [])

  // Click outside to close
  function onBackdrop(e: React.MouseEvent<HTMLDivElement>) {
    if (e.target === e.currentTarget) onClose()
  }

  return (
    <div
      className="fixed inset-0 z-50 grid place-items-center bg-black/40 p-4"
      onMouseDown={onBackdrop}
      role="dialog"
      aria-modal="true"
    >
      <div
        className="bg-white w-full max-w-xl rounded-2xl shadow-2xl outline-none flex flex-col max-h-[90vh]"
        onMouseDown={(e)=>e.stopPropagation()}
      >
        <div className="px-6 pt-5 pb-3 border-b shrink-0">
          <h2 className="text-lg font-semibold">{title}</h2>
        </div>

        {/* Scrollable body */}
        <div className="px-6 py-4 overflow-y-auto grow">
          {children}
        </div>

        <div className="px-6 pb-5 pt-3 border-t shrink-0 flex justify-end gap-2">
          <button
            onClick={onClose}
            className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300"
          >
            {cancelLabel}
          </button>
          <button
            onClick={onSubmit}
            className="px-4 py-2 rounded-md bg-[var(--brand)] text-white hover:opacity-90"
          >
            {primaryLabel}
          </button>
        </div>
      </div>
    </div>
  )
}
\n===== components/Toast.tsx =====
'use client'
import { useState } from 'react'
let showToastFn: (msg:string)=>void
export function ToastContainer(){
  const [msg,setMsg]=useState('')
  if(!showToastFn) showToastFn = setMsg
  return msg ? (
    <div className="fixed bottom-4 right-4 bg-black text-white px-4 py-2 rounded shadow">{msg}</div>
  ) : null
}
export function showToast(msg:string){
  if(showToastFn) showToastFn(msg)
  setTimeout(()=> showToastFn && showToastFn(''), 2000)
}
\n===== components/DemographicsCard.tsx =====
'use client';

type IncomeRow = { age: string; tkr: number };

export type DemoData = {
  year: number;
  incomeByAge: IncomeRow[];
  population?: number;
  densityPerKm2?: number;
  households1pShare?: number; // 0..1 (optional)
  households2pShare?: number; // 0..1 (optional)
};

export default function DemographicsCard({
  data,
  title,
}: {
  data: DemoData;
  title: string;
}) {
  return (
    <div className="border rounded p-3 bg-slate-50">
      <div className="text-sm text-slate-600">
        {title} ‚Äî {data.year}
      </div>
      <ul className="list-disc pl-5 text-sm">
        {typeof data.population === 'number' && (
          <li>Befolkning: {data.population.toLocaleString('sv-SE')}</li>
        )}
        {typeof data.densityPerKm2 === 'number' && (
          <li>T√§thet: {Math.round(data.densityPerKm2)} /km¬≤</li>
        )}
        {Array.isArray(data.incomeByAge) &&
          data.incomeByAge.map((r, i) => (
            <li key={i}>
              {r.age}: {r.tkr} tkr
            </li>
          ))}
        {typeof data.households1pShare === 'number' && (
          <li>Enpersonshush√•ll: {Math.round(data.households1pShare * 100)}%</li>
        )}
        {typeof data.households2pShare === 'number' && (
          <li>Tv√•personshush√•ll: {Math.round(data.households2pShare * 100)}%</li>
        )}
      </ul>
    </div>
  );
}
\n===== components/SiteImage.tsx =====
'use client';
import Image from 'next/image';
import { siteImageUrl } from '@/lib/siteImages';

type Props = {
  src: string;
  alt: string;
  className?: string;
  priority?: boolean;
};

/**
 * Mobile + Desktop: 100% width (full width)
 */
export default function SiteImage({ src, alt, className = '', priority }: Props) {
  const url = siteImageUrl(src);
  return (
    <div className={`w-full mx-auto rounded-2xl ${className}`}>
      <Image
        src={url || '/placeholder.svg'}
        alt={alt}
        width={1600}
        height={900}
        priority={priority}
        style={{ width: '100%', height: 'auto' }}
        className="object-contain rounded-2xl"
        sizes="100vw"
      />
    </div>
  );
}
\n===== components/MobileMenu.tsx =====
// components/MobileMenu.tsx
'use client'
import { useState } from 'react'
import Link from 'next/link'

export default function MobileMenu() {
  const [open, setOpen] = useState(false)
  return (
    <div className="md:hidden w-full">
      <div className="flex items-center justify-between">
        <button
          type="button"
          aria-label="Menu"
          aria-expanded={open}
          onClick={() => setOpen(v => !v)}
          className="px-3 py-2 rounded border"
        >
          ‚ò∞ Menu
        </button>

        {/* Log In / Sign Up stay visible */}
        <div className="flex items-center gap-2">
          <Link href="/auth" className="px-3 py-1 rounded border">Log In</Link>
          <Link href="/auth" className="px-3 py-1 rounded bg-black text-white">Sign Up</Link>
        </div>
      </div>

      {open && (
        <nav className="mt-2 grid gap-2 rounded border p-3 bg-white" onClick={() => setOpen(false)}>
          <Link href="/features" className="px-2 py-1 rounded hover:bg-slate-50">Features</Link>
          <Link href="/pricing"  className="px-2 py-1 rounded hover:bg-slate-50">Pricing</Link>
          <Link href="/contact"  className="px-2 py-1 rounded hover:bg-slate-50">Contact</Link>
        </nav>
      )}
    </div>
  )
}
\n===== lib/supabaseRoute.ts =====
// lib/supabaseRoute.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

export function supabaseFromRequest(req: NextRequest) {
  // We return a NextResponse that callers can ignore if they don't need to mutate cookies
  const res = NextResponse.next()

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        // Read cookies from the incoming request
        getAll() {
          return req.cookies.getAll()
        },
        // Write cookies onto the response (Supabase may set/clear auth cookies)
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            // NextResponse.cookies.set(name, value, options)
            res.cookies.set(name, value, options as CookieOptions)
          })
        },
      },
    }
  )

  return { supabase, res }
}
\n===== lib/serverBaseUrl.ts =====
// lib/serverBaseUrl.ts
export function serverBaseUrl(req: Request) {
  const host = req.headers.get('x-forwarded-host') || req.headers.get('host') || 'localhost:3000'
  const proto = req.headers.get('x-forwarded-proto') || (host.startsWith('localhost') ? 'http' : 'https')
  return `${proto}://${host}`
}
\n===== lib/sbAdmin.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
// lib/sbAdmin.ts
export async function sbAdmin(path: string, init: RequestInit = {}) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const service = process.env.SUPABASE_SERVICE_KEY!
  const headers = {
    apikey: service,
    Authorization: `Bearer ${service}`,
    'Content-Type': 'application/json',
    ...(init.headers||{})
  }
  const r = await fetch(`${url}/rest/v1${path}`, { ...init, headers, cache:'no-store' })
  const ok = r.ok
  let data:any = null
  try { data = await r.json() } catch {}
  if (!ok) throw new Error(data?.message || `Supabase error: ${r.status}`)
  return data
}
\n===== lib/qaLogic.ts =====
/* eslint-disable @typescript-eslint/no-explicit-any */
type QAInput = {
  question: string
  goal?: string
  segment?: string
  channel?: string
  numbers?: string
  profileName?: string
  extras?: Record<string,string|number|boolean|undefined|null>
  lang?: 'sv'|'en'|string
}

type QARaw = {
  one_liner?: string
  why?: any
  ack?: string
  short_script?: string
  full_script?: string
  math?: string
  next_step?: string
}

const PREFERRED_MODELS = [
  process.env.OPENAI_MODEL || 'gpt-4o-mini'
]

// ---------- prompt builders ----------
function buildSystemPromptGeneric(activeProfileName: string, profileJson: any, userProfile: any) {
  const lang = (profileJson?.Language || userProfile?.language || 'Svenska') as string
  const tone = [profileJson?.Tone, userProfile?.preferred_tone].filter(Boolean).join('; ')
  const compliance = profileJson?.Compliance || ''
  const callback = profileJson?.CallbackWindows || ''
  const proof = profileJson?.Proof || ''

  return [
    `Du √§r en professionell s√§ljcoach. Svara alltid p√• ${lang}.`,
    `Stil/ton: ${tone || 'Varm, konkret, m√§nsklig. Korta, handlingsbara svar.'}`,
    compliance ? `Compliance: ${compliance}` : ``,
    proof ? `Bevis/Proof att anv√§nda n√§r relevant: ${proof}` : ``,
    callback ? `Ring-/m√∂testider att f√∂resl√• (om m√•l kr√§ver): ${callback}` : ``,
    `Returnera STRIKT JSON i f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.`,
    `why ska vara i tredje person om kunden och kan vara sammanh√§ngande text.`,
    `short_script max 2 meningar. full_script max 90‚Äì120 ord.`
  ].filter(Boolean).join('\n')
}

function buildUserPromptGeneric(input: QAInput, kbBest: {text?: string, hit?: boolean}, profileJson: any, userProfile: any) {
  const parts:string[] = []
  if (kbBest?.text) parts.push('INTERNAL BEST PRACTICE (f√∂lj ramarna): ' + kbBest.text)

  if (Array.isArray(profileJson?.Goals) && profileJson.Goals.length)
    parts.push('Till√•tna m√•l: ' + profileJson.Goals.join(', '))
  if (profileJson?.PersonaHints)
    parts.push('Persona hints: ' + profileJson.PersonaHints)

  const up:string[] = []
  if (userProfile?.role) up.push('roll=' + userProfile.role)
  if (userProfile?.experience) up.push('erfarenhet=' + userProfile.experience)
  if (userProfile?.preferred_tone) up.push('tone_pref=' + userProfile.preferred_tone)
  if (userProfile?.language) up.push('spr√•k_pref=' + userProfile.language)
  if (up.length) parts.push('SPEAKER PROFILE: ' + up.join('; '))

  parts.push([
    'M√•l: ' + (input.goal || ''),
    'Signal: ' + (input.question || ''),
    'Segment: ' + (input.segment || ''),
    'Kanal: ' + (input.channel || ''),
    'Siffror: ' + (input.numbers || '')
  ].join(' | '))

  const extras = input.extras || {}
  Object.keys(extras).forEach(k => {
    const v = (extras as any)[k]
    if (v !== undefined && v !== null && String(v).trim() !== '') {
      parts.push(k + ': ' + String(v))
    }
  })

  const cb = profileJson?.CallbackWindows || ''
  if (cb && /(m√∂te|boka|intro|avst√§mning|uppf√∂ljning)/i.test(input.goal || '')) {
    parts.push('Om du f√∂resl√•r tider, anv√§nd tv√• exakta tider fr√•n: ' + cb)
  }
  return parts.join(' | ')
}

// ---------- shaping ----------
function coerceWhyObject(why: any) {
  const toStr = (x:any) => (x === undefined || x === null) ? '' : String(x).trim()
  let w:any = {}
  if (why && typeof why === 'object') w = why
  else if (why && typeof why === 'string') w = { qfocus: why }
  if (!toStr(w.qfocus))      w.qfocus      = 'Kunden vill f√∂rst√• nyttan och s√§nka risk f√∂re beslut.'
  if (!toStr(w.personal))    w.personal    = 'Personliga m√•l och begr√§nsningar styr beslutsvilja och tajming.'
  if (!toStr(w.biases))      w.biases      = 'Status quo och f√∂rlustaversion bromsar; tydlighet √∂kar trygghet.'
  if (!toStr(w.norms))       w.norms       = 'Verifierbarhet och skriftlig bekr√§ftelse v√§rderas.'
  if (!toStr(w.law))         w.law         = 'Transparens minskar upplevd risk (ej juridisk r√•dgivning).'
  if (!toStr(w.implication)) w.implication = 'Erbjud enkel n√§sta handling, kort och verifierbar.'
  return w
}

function enforceCaps(obj: QARaw) {
  const trimWords = (s:string, n:number) => (s || '').toString().split(/\s+/).slice(0, n).join(' ').trim()
  const limitChars = (s:string, n:number) => (s || '').toString().slice(0, n).trim()

  if (obj.one_liner) obj.one_liner = trimWords(obj.one_liner, 14)
  obj.why = coerceWhyObject(obj.why)
  ;['qfocus','personal','biases','norms','law','implication'].forEach(k => {
    obj.why[k] = limitChars(String(obj.why[k] || ''), 280)
  })
  if (obj.ack) obj.ack = limitChars(obj.ack, 140)
  if (obj.short_script) {
    const two = obj.short_script.split(/(?<=[.!?])\s+/).slice(0, 2)
    obj.short_script = two.join(' ')
  }
  if (obj.full_script) obj.full_script = limitChars(obj.full_script, 600)
  if (obj.math) obj.math = limitChars(obj.math.replace(/\n+/g, ' '), 200)
  if (obj.next_step) {
    const first = obj.next_step.split(/(?<=[.!?])\s+/)[0] || obj.next_step
    obj.next_step = limitChars(first, 240)
  }
  return obj
}

// --------- small helpers (stubbed) ----------
async function getActiveProfileJSON(profileName?: string) {
  // Hook into your real profile storage if you want.
  // For now return empty (non-breaking).
  return {}
}
async function getUserProfile() {
  // Hook into your Users table if you have one.
  return { language: 'Svenska', preferred_tone: '' }
}
async function kbFindBest(signal: string, profileName?: string) {
  // If you have a KB table / vector store, implement fuzzy search here.
  return { text: '', hit: false }
}

// --------- OpenAI call ----------
async function callOpenAIJSON(systemPrompt: string, userPrompt: string) {
  const key = process.env.OPENAI_API_KEY
  if (!key) throw new Error('Missing OPENAI_API_KEY')

  let lastErr: any
  for (const model of PREFERRED_MODELS) {
    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${key}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model,
          temperature: 0.25,
          response_format: { type: 'json_object' },
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ]
        })
      })
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${await resp.text()}`)
      const data = await resp.json()
      let content = data?.choices?.[0]?.message?.content || '{}'
      const match = content.match(/\{[\s\S]*\}$/)
      if (match) content = match[0]
      return JSON.parse(content) as QARaw
    } catch (e:any) { lastErr = e }
  }
  throw new Error('OpenAI call failed: ' + (lastErr?.message || String(lastErr)))
}

// --------- main entry ----------
export async function generateQAAnswer(input: QAInput) {
  const profileJson = await getActiveProfileJSON(input.profileName)
  const userProfile = await getUserProfile()
  const kb = await kbFindBest(input.question || '', input.profileName)

  const sys = buildSystemPromptGeneric(input.profileName || '', profileJson, userProfile)
  const usr = buildUserPromptGeneric(input, kb, profileJson, userProfile)

  let obj = await callOpenAIJSON(sys, usr)
  obj = enforceCaps(obj)

  return {
    obj,
    meta: { kb_used: !!kb?.hit, profile: input.profileName || '' }
  }
}
\n===== lib/cn.ts =====
export function cn(...classes: Array<string | false | null | undefined>) {
  return classes.filter(Boolean).join(' ')
}
\n===== lib/i18n.ts =====
// lib/i18n.ts
export type Lang = 'sv' | 'en'

const dict: Record<Lang, Record<string, string>> = {
  sv: {
    // App & nav
    'app.title': 'SalesMind',
    'nav.qa': 'Q&A',
    'nav.profiles': 'Profiler',
    'nav.company': 'F√∂retag',
    'nav.kb': 'Kunskapsbank',
    'nav.events': 'H√§ndelser',
    'nav.settings': 'Inst√§llningar',

    // Common
    'common.save': 'Spara',
    'common.cancel': 'Avbryt',
    'common.delete': 'Ta bort',
    'common.new': 'Ny',
    'common.none': '‚Äî ingen ‚Äî',
    'common.loading': 'Laddar ‚Ä¶',
    'common.error': 'N√•got gick fel',
    'common.ok': 'OK',

    // QA ‚Äî titles & labels
    'qa.title': 'Q&A',
    'qa.company': 'F√∂retag',
    'qa.profile': 'Profil',
    'qa.goal': 'M√•l',
    'qa.segment': 'Segment',
    'qa.channel': 'Kanal',
    'qa.numbers': 'Siffror',
    'qa.question': 'Fr√•ga / Signal',
    'qa.getAnswer': 'H√§mta svar',
    'qa.hint.enter': 'Enter: skicka ‚Ä¢ Shift+Enter: ny rad',

    // QA ‚Äî placeholders
    'qa.ph.company': 'V√§lj f√∂retag (valfritt)',
    'qa.ph.profile': 'V√§lj s√§ljprofil',
    'qa.ph.goal': 'T.ex. ‚ÄùBoka demo‚Äù eller ‚ÄùKvalificera‚Äù',
    'qa.ph.segment': 'T.ex. ‚ÄùSMB SaaS i Norden‚Äù',
    'qa.ph.channel': 'T.ex. ‚ÄùE-post‚Äù, ‚ÄùTelefon‚Äù, ‚ÄùLinkedIn‚Äù',
    'qa.ph.numbers': 'T.ex. ‚Äù3 m√∂ten/vecka‚Äù, ‚ÄùCTR 2,1%‚Äù',
    'qa.ph.question': 'Skriv din fr√•ga / signal ‚Ä¶ (Enter skickar, Shift+Enter ny rad)',

    // QA ‚Äî result blocks
    'qa.res.one_liner': 'One-liner',
    'qa.res.why': 'Varf√∂r',
    'qa.res.ack': 'Bekr√§fta',
    'qa.res.short_script': 'Kort manus',
    'qa.res.full_script': 'Fullt manus',
    'qa.res.math': 'Utr√§kning',
    'qa.res.next_step': 'N√§sta steg',

    // QA ‚Äî feedback
    'qa.fb.title': 'Feedback',
    'qa.fb.rating': 'Betyg (1‚Äì5)',
    'qa.fb.used': 'Anv√§ndes?',
    'qa.fb.tags': 'Taggar',
    'qa.fb.save': 'Spara feedback',
    'qa.fb.yes': 'Ja',
    'qa.fb.no': 'Nej',

    // QA ‚Äî location context (NYTT)
    'qa.loc.title': 'Platskontext',
    'qa.loc.segment': 'Segment',
    'qa.loc.nearby': 'I n√§rheten',
    'qa.loc.hooks': 'Krokar',
    'qa.loc.plan': 'Plan',
  },

  en: {
    // App & nav
    'app.title': 'SalesMind',
    'nav.qa': 'Q&A',
    'nav.profiles': 'Profiles',
    'nav.company': 'Company',
    'nav.kb': 'Knowledge Base',
    'nav.events': 'Events',
    'nav.settings': 'Settings',

    // Common
    'common.save': 'Save',
    'common.cancel': 'Cancel',
    'common.delete': 'Delete',
    'common.new': 'New',
    'common.none': '‚Äî none ‚Äî',
    'common.loading': 'Loading ‚Ä¶',
    'common.error': 'Something went wrong',
    'common.ok': 'OK',

    // QA ‚Äî titles & labels
    'qa.title': 'Q&A',
    'qa.company': 'Company',
    'qa.profile': 'Profile',
    'qa.goal': 'Goal',
    'qa.segment': 'Segment',
    'qa.channel': 'Channel',
    'qa.numbers': 'Numbers',
    'qa.question': 'Question / Signal',
    'qa.getAnswer': 'Get answer',
    'qa.hint.enter': 'Enter: submit ‚Ä¢ Shift+Enter: new line',

    // QA ‚Äî placeholders
    'qa.ph.company': 'Choose company (optional)',
    'qa.ph.profile': 'Choose sales profile',
    'qa.ph.goal': 'e.g. ‚ÄúBook demo‚Äù or ‚ÄúQualify‚Äù',
    'qa.ph.segment': 'e.g. ‚ÄúSMB SaaS in Nordics‚Äù',
    'qa.ph.channel': 'e.g. ‚ÄúEmail‚Äù, ‚ÄúPhone‚Äù, ‚ÄúLinkedIn‚Äù',
    'qa.ph.numbers': 'e.g. ‚Äú3 meetings/week‚Äù, ‚ÄúCTR 2.1%‚Äù',
    'qa.ph.question': 'Type your question / signal‚Ä¶ (Enter submits, Shift+Enter new line)',

    // QA ‚Äî result blocks
    'qa.res.one_liner': 'One-liner',
    'qa.res.why': 'Why',
    'qa.res.ack': 'Acknowledge',
    'qa.res.short_script': 'Short script',
    'qa.res.full_script': 'Full script',
    'qa.res.math': 'Math',
    'qa.res.next_step': 'Next step',

    // QA ‚Äî feedback
    'qa.fb.title': 'Feedback',
    'qa.fb.rating': 'Rating (1‚Äì5)',
    'qa.fb.used': 'Used?',
    'qa.fb.tags': 'Tags',
    'qa.fb.save': 'Save feedback',
    'qa.fb.yes': 'Yes',
    'qa.fb.no': 'No',

    // QA ‚Äî location context (NEW)
    'qa.loc.title': 'Location context',
    'qa.loc.segment': 'Segment',
    'qa.loc.nearby': 'Nearby',
    'qa.loc.hooks': 'Hooks',
    'qa.loc.plan': 'Plan',
  },
}

function readCookie(name: string, cookieStr?: string) {
  const source = typeof cookieStr === 'string'
    ? cookieStr
    : (typeof document !== 'undefined' ? document.cookie : '')
  if (!source) return null
  const match = source.split(';').map(s => s.trim()).find(s => s.startsWith(name + '='))
  return match ? decodeURIComponent(match.split('=').slice(1).join('=')) : null
}

export function getLang(cookieStr?: string): Lang {
  const v = readCookie('salesmind_lang', cookieStr)
  if (v === 'en' || v === 'sv') return v
  return 'sv'
}

export function setLangCookie(lang: Lang) {
  if (typeof document === 'undefined') return
  document.cookie = `salesmind_lang=${lang}; Path=/; Max-Age=31536000; SameSite=Lax`
}

export function t(lang: Lang, key: string): string {
  return dict[lang]?.[key] ?? key
}
\n===== lib/supabaseServer.ts =====
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import { type CookieOptions } from "@supabase/ssr";

export async function supabaseServer() {
  const cookieStore = await cookies(); // ‚úÖ fix: await required in Next 15
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll() {
          // no-op fix for "Cookies can only be modified..." warning
        },
      },
    }
  );
}
\n===== lib/scb.ts =====
export type PxQuery = {
  query: Array<{ code: string; selection: { filter: string; values: string[] } }>;
  response?: { format: 'JSON' | 'PX' };
};

export async function pxwebFetch(baseUrl: string, body: PxQuery) {
  // Example baseUrl:
  //  "https://api.scb.se/OV0104/v1/doris/sv/ssd/HE/HE0110/HE0110A/DispInkMedelKom√Ölder"
  // You control exact dataset path via env.
  const r = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...body,
      response: { format: 'JSON' },
    }),
    // Node fetch
    cache: 'no-store'
  });
  if (!r.ok) {
    const text = await r.text().catch(() => '');
    throw new Error(`SCB HTTP ${r.status}: ${text}`);
  }
  return r.json();
}
\n===== lib/kommuner.ts =====
import { KOMMUNER } from '../data/kommuner'

/** Map both Swedish and English names -> kommun code */
const nameToCode: Record<string, string> = {}
for (const k of KOMMUNER) {
  if (k.name_sv) nameToCode[k.name_sv] = k.code
  if (k.name_en) nameToCode[k.name_en] = k.code
}

/** Backward-compatible export name expected by your code */
export const KOMMUN_CODE_BY_NAME = nameToCode

/** Extra helpers if you need them later */
export const KOMMUN_BY_CODE = new Map(KOMMUNER.map(k => [k.code, k]))
export function kommunCodeFromName(input: string | undefined | null): string | undefined {
  if (!input) return
  const s = input.trim()
  if (/^\d{4}$/.test(s)) return s
  return nameToCode[s] || nameToCode[s.normalize('NFKC')]
}

export { KOMMUNER }
\n===== lib/siteImages.ts =====
// lib/siteImages.ts
// Build a public URL for files stored in the Supabase "site" bucket.
// Example: siteImageUrl('hero.jpg') -> https://.../storage/v1/object/public/site/hero.jpg

const base = process.env.NEXT_PUBLIC_SUPABASE_URL || '';

export function siteImageUrl(path: string) {
  const p = String(path || '').replace(/^\/+/, '');
  if (!base) return '';
  return `${base}/storage/v1/object/public/site/${p}`;
}
\n===== lib/utils.ts =====
export function cn(...classes: Array<string | false | null | undefined>) {
  return classes.filter(Boolean).join(' ')
}
\n===== lib/supabaseBrowser.ts =====
// lib/supabaseBrowser.ts
'use client'

import { createClient, type SupabaseClient } from '@supabase/supabase-js'

let _client: SupabaseClient | null = null

export function supabaseBrowser(): SupabaseClient {
  if (_client) return _client

  const url = process.env.NEXT_PUBLIC_SUPABASE_URL
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  if (!url || !key) {
    // G√∂r felet tydligt i b√•de dev och prod
    throw new Error(
      'Supabase env saknas: Kontrollera NEXT_PUBLIC_SUPABASE_URL och NEXT_PUBLIC_SUPABASE_ANON_KEY'
    )
  }

  _client = createClient(url, key, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
    },
  })
  return _client
}
\n===== lib/chunk.ts =====
// lib/chunk.ts
export function chunkText(text: string, maxChars = 1200): string[] {
  const parts:string[] = []
  let buf = ''
  for (const line of text.split(/\n+/)) {
    if ((buf + '\n' + line).length > maxChars) {
      if (buf.trim()) parts.push(buf.trim())
      buf = line
    } else {
      buf = buf ? buf + '\n' + line : line
    }
  }
  if (buf.trim()) parts.push(buf.trim())
  return parts
}
\n===== lib/baseUrl.ts =====
import type { NextRequest } from 'next/server'

export function getBaseUrl(req?: NextRequest) {
  // Vercel URL
  const vercel = process.env.VERCEL_URL
  if (vercel) return `https://${vercel}`
  // Explicit (useful for Codespaces or custom proxies)
  const explicit = process.env.NEXT_PUBLIC_BASE_URL
  if (explicit) return explicit.replace(/\/$/, '')
  // Derive from request headers in dev
  if (req) {
    const proto = req.headers.get('x-forwarded-proto') || 'http'
    const host  = req.headers.get('x-forwarded-host')  || req.headers.get('host') || 'localhost:3000'
    return `${proto}://${host}`
  }
  // Fallback
  return 'http://localhost:3000'
}
\n===== lib/embedding.ts =====
// lib/embedding.ts
export async function embedText(text: string): Promise<number[]> {
  const apiKey = process.env.OPENAI_API_KEY!
  if (!apiKey) throw new Error('OPENAI_API_KEY missing')
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: 'text-embedding-3-small', input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(j.error?.message || 'embedding failed')
  return j.data[0].embedding
}
