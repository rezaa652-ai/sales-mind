
--- app/app/settings/SettingsClient.tsx ---
// app/app/settings/SettingsClient.tsx
'use client'

import { useState } from 'react'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

type Props = { initialEmail: string }

export default function SettingsClient({ initialEmail }: Props){
  const supabase = supabaseBrowser()
  const [tab, setTab] = useState<'profile'|'billing'>('profile')

  // Profile state
  const [email, setEmail] = useState(initialEmail)
  const [pass, setPass] = useState('')
  const [loading, setLoading] = useState(false)
  const [msg, setMsg] = useState<string>('')

  // Billing (placeholder for now)
  const [plan] = useState<'Free'|'Pro'>('Free')

  async function updateEmail(e: React.FormEvent){
    e.preventDefault()
    setMsg(''); setLoading(true)
    const { error } = await supabase.auth.updateUser({ email })
    setLoading(false)
    if (error) setMsg(`Kunde inte uppdatera e-post: ${error.message}`)
    else setMsg('E-post uppdaterad! Kolla din inbox om bekr√§ftelse kr√§vs.')
  }

  async function updatePassword(e: React.FormEvent){
    e.preventDefault()
    setMsg(''); setLoading(true)
    const { error } = await supabase.auth.updateUser({ password: pass })
    setLoading(false)
    if (error) setMsg(`Kunde inte byta l√∂senord: ${error.message}`)
    else { setMsg('L√∂senord uppdaterat!'); setPass('') }
  }

  function goUpgrade(){
    // Placeholder: koppla mot Stripe Checkout eller egen uppgraderingssida.
    alert('Upgrade flow not implemented yet. (Stripe/Checkout-l√§nk h√§r senare)')
  }

  return (
    <div className="max-w-[960px]">
      <h1 className="text-xl font-semibold mb-4">Settings</h1>

      <div className="flex gap-6">
        {/* Left menu */}
        <aside className="w-48">
          <nav className="flex flex-col gap-1">
            <button
              className={`text-left p-2 rounded ${tab==='profile'?'bg-blue-100 text-blue-700 font-medium':'hover:bg-gray-100'}`}
              onClick={()=>setTab('profile')}
            >
              Profile
            </button>
            <button
              className={`text-left p-2 rounded ${tab==='billing'?'bg-blue-100 text-blue-700 font-medium':'hover:bg-gray-100'}`}
              onClick={()=>setTab('billing')}
            >
              Billing
            </button>

            <form action="/auth/signout" method="post" className="mt-4">
              <button className="p-2 rounded bg-red-50 text-red-700 hover:bg-red-100 w-full text-left">
                Logga ut
              </button>
            </form>
          </nav>
        </aside>

        {/* Right panel */}
        <section className="flex-1">
          {msg && (
            <div className="mb-3 rounded border border-blue-200 bg-blue-50 text-blue-800 px-3 py-2 text-sm">
              {msg}
            </div>
          )}

          {tab === 'profile' && (
            <div className="space-y-6">
              <div className="border rounded p-4">
                <h2 className="font-medium mb-3">E-post</h2>
                <form onSubmit={updateEmail} className="grid gap-3 max-w-md">
                  <label className="text-sm">
                    Ny e-post
                    <input
                      className="w-full border rounded p-2"
                      type="email"
                      value={email}
                      onChange={e=>setEmail(e.target.value)}
                      required
                    />
                  </label>
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
                    disabled={loading}
                  >
                    Uppdatera e-post
                  </button>
                </form>
              </div>

              <div className="border rounded p-4">
                <h2 className="font-medium mb-3">Byt l√∂senord</h2>
                <form onSubmit={updatePassword} className="grid gap-3 max-w-md">
                  <label className="text-sm">
                    Nytt l√∂senord
                    <input
                      className="w-full border rounded p-2"
                      type="password"
                      value={pass}
                      onChange={e=>setPass(e.target.value)}
                      minLength={6}
                      required
                    />
                  </label>
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
                    disabled={loading}
                  >
                    Uppdatera l√∂senord
                  </button>
                </form>
              </div>
            </div>
          )}

          {tab === 'billing' && (
            <div className="space-y-6">
              <div className="border rounded p-4">
                <h2 className="font-medium mb-2">Prenumeration</h2>
                <p className="text-sm text-slate-600 mb-3">
                  Nuvarande plan: <b>{plan}</b>
                </p>
                <div className="flex gap-2">
                  <button
                    className="bg-[var(--brand)] text-white rounded px-4 py-2"
                    onClick={goUpgrade}
                  >
                    Upgrade
                  </button>
                  <button
                    className="border rounded px-4 py-2"
                    onClick={()=>alert('Billing portal not implemented yet')}
                  >
                    Billing portal
                  </button>
                </div>
                <p className="text-xs text-slate-500 mt-3">
                  (H√§r kopplar vi mot Stripe Checkout/Customer Portal i n√§sta steg.)
                </p>
              </div>
            </div>
          )}
        </section>
      </div>
    </div>
  )
}

--- app/app/settings/page.tsx ---
'use client'
import { useEffect, useState } from 'react'
import { getLang, setLangCookie, t, type Lang } from '@/lib/i18n'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

type Tab = 'profile' | 'billing' | 'language'

export default function SettingsPage(){
  const [lang,setLang] = useState<Lang>('sv')
  const [tab,setTab] = useState<Tab>('profile')
  const [email,setEmail] = useState<string>('')

  useEffect(()=>{
    setLang(getLang())
    ;(async()=>{
      const supabase = supabaseBrowser()
      const { data } = await supabase.auth.getUser()
      setEmail(data.user?.email || '')
    })()
  },[])

  function changeLang(next: Lang){
    setLangCookie(next)
    setLang(next)
  }

  async function signOut(){
    // POST so we clean cookies server-side
    await fetch('/auth/signout', { method:'POST' })
    window.location.href = '/auth'
  }

  return (
    <div className="min-h-screen">
      <h1 className="text-xl font-semibold mb-4">{t(lang,'settings.title')}</h1>

      <div className="grid grid-cols-1 md:grid-cols-[220px_1fr] gap-6">
        {/* Vertical menu */}
        <aside className="border rounded-lg p-3 bg-white">
          <nav className="flex md:flex-col gap-2">
            <button
              className={`text-left px-3 py-2 rounded ${tab==='profile' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('profile')}
            >
              {t(lang,'settings.menu.profile')}
            </button>
            <button
              className={`text-left px-3 py-2 rounded ${tab==='billing' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('billing')}
            >
              {t(lang,'settings.menu.billing')}
            </button>
            <button
              className={`text-left px-3 py-2 rounded ${tab==='language' ? 'bg-blue-100 text-blue-700' : 'hover:bg-slate-100'}`}
              onClick={()=>setTab('language')}
            >
              {t(lang,'settings.menu.language')}
            </button>

            <hr className="my-3" />

            <button
              className="text-left px-3 py-2 rounded border border-red-200 text-red-600 hover:bg-red-50"
              onClick={signOut}
            >
              {t(lang,'settings.logout')}
            </button>
          </nav>
        </aside>

        {/* Content */}
        <section className="space-y-4">
          {tab==='profile' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="grid md:grid-cols-2 gap-3">
                <label className="text-sm">{t(lang,'settings.profile.email')}
                  <input className="border rounded p-2 w-full" value={email} readOnly />
                </label>
                <label className="text-sm">{t(lang,'settings.profile.password')}
                  <input className="border rounded p-2 w-full" value="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢" readOnly />
                </label>
              </div>
              <div className="mt-3">
                <button className="px-4 py-2 rounded bg-[var(--brand)] text-white hover:opacity-90">
                  {t(lang,'settings.profile.change')}
                </button>
              </div>
            </div>
          )}

          {tab==='billing' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="grid md:grid-cols-2 gap-3">
                <label className="text-sm">{t(lang,'settings.billing.plan')}
                  <input className="border rounded p-2 w-full" value="Free" readOnly />
                </label>
                <div className="flex items-end">
                  <button className="px-4 py-2 rounded bg-[var(--brand)] text-white hover:opacity-90">
                    {t(lang,'settings.billing.upgrade')}
                  </button>
                </div>
              </div>
            </div>
          )}

          {tab==='language' && (
            <div className="border rounded-lg p-4 bg-white">
              <div className="text-sm mb-2">{t(lang,'settings.language.choose')}</div>
              <div className="flex gap-2">
                <button
                  className={`px-3 py-2 rounded border ${lang==='sv' ? 'bg-blue-100 border-blue-300' : 'hover:bg-slate-100'}`}
                  onClick={()=>changeLang('sv' as Lang)}
                >
                  Svenska
                </button>
                <button
                  className={`px-3 py-2 rounded border ${lang==='en' ? 'bg-blue-100 border-blue-300' : 'hover:bg-slate-100'}`}
                  onClick={()=>changeLang('en' as Lang)}
                >
                  English
                </button>
              </div>
            </div>
          )}
        </section>
      </div>
    </div>
  )
}

--- app/app/kb/page.tsx ---
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type KB = {
  id?: string
  signal: string
  best_practice: string
  profile_name?: string
}

export default function KBPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<KB[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<KB | null>(null)
  const [form, setForm] = useState<KB>({ signal: '', best_practice: '', profile_name: '' })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load() {
    setLoading(true); setError(null)
    try{
      const r = await fetch('/api/kb', { headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load KB failed:', e)
      setError(t(lang,'common.error')); setRows([])
    }finally{ setLoading(false) }
  }

  useEffect(()=>{ load() },[]) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){ setEditing(null); setForm({ signal:'', best_practice:'', profile_name:'' }); setOpen(true) }
  function openEdit(k: KB){ setEditing(k); setForm({ id:k.id, signal:k.signal, best_practice:k.best_practice, profile_name:k.profile_name||'' }); setOpen(true) }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/kb/${editing.id}` : '/api/kb'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type':'application/json', accept:'application/json' },
        body: JSON.stringify(form),
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save KB failed:', e)
      alert(t(lang,'common.error'))
    }finally{ setSaving(false) }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/kb/${id}`, { method:'DELETE', headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete KB failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'kb.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'kb.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'kb.list.empty')}</div>}

      <div className="grid gap-3">
        {rows.map(k=>(
          <div key={k.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{k.signal||'‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={()=>openEdit(k)}>{t(lang,'common.edit')}</button>
                <ConfirmDialog onConfirm={()=>del(k.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm text-slate-700 whitespace-pre-wrap">{k.best_practice||'‚Äî'}</div>
            {k.profile_name && <div className="text-xs text-slate-500 mt-1">{t(lang,'kb.profile')}: {k.profile_name}</div>}
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'kb.edit') : t(lang,'kb.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'kb.form.signal')}
              <input
                className="border rounded p-2 w-full"
                value={form.signal}
                placeholder={t(lang,'kb.ph.signal')}
                onChange={e=>setForm({...form, signal:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'kb.form.best')}
              <textarea
                className="border rounded p-2 w-full min-h-[110px]"
                value={form.best_practice}
                placeholder={t(lang,'kb.ph.best')}
                onChange={e=>setForm({...form, best_practice:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'kb.form.profile')}
              <input
                className="border rounded p-2 w-full"
                value={form.profile_name||''}
                placeholder={t(lang,'kb.ph.profile')}
                onChange={e=>setForm({...form, profile_name:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}

--- app/app/geo/page.tsx ---
'use client'
import React, { useEffect, useMemo, useState } from 'react'
import GeoElectricityInfo from '@/components/GeoElectricityInfo'
import DemographicsCard, { DemoData } from '@/components/DemographicsCard'
import { GoogleMap, Marker, useLoadScript } from '@react-google-maps/api'

let KOMMUNER: Array<{ code: string; name_sv: string; name_en: string }> = []
try {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  KOMMUNER = require('../../../data/kommuner').KOMMUNER || []
} catch {}

/** Types */
type Lang = 'sv' | 'en';
type Poi = {
  name: string;
  type?: string;
  distance_m?: number;
  lat: number;
  lon: number;
  rating?: number;
  address?: string;
};
type GeoResp = {
  center?: { lat: number; lon: number };
  address?: string;
  radius_m?: number;
  pois?: Poi[];
  segment?: string;
  plan?: string[];
  hooks?: string[];
  demographics?: { median_income?: string; families?: string; students?: string };
  lang?: Lang;
};

/** Localized text */
const LTEXT = {
  sv: {
    title: 'Geos√∂k (adress + n√§romr√•de)',
    address: 'Adress',
    address_ph: 'Ex: S√∂dra F√∂rstadsgatan 56, Malm√∂',
    enter_hint: 'Tryck Enter f√∂r att s√∂ka',
    radius: 'Radie (m)',
    search: 'S√∂k',
    searching: 'S√∂ker‚Ä¶',
    segment: 'Segment',
    plan: 'Plan',
    hooks: 'Krokar',
    nearby: 'I n√§rheten (f√∂retag)',
    demog: 'SCB: Median disponibel inkomst per √•lder (tkr)',
    loading_map: 'Laddar karta‚Ä¶',
  },
  en: {
    title: 'Geo search (address + nearby)',
    address: 'Address',
    address_ph: 'e.g. S√∂dra F√∂rstadsgatan 56, Malm√∂',
    enter_hint: 'Press Enter to search',
    radius: 'Radius (m)',
    search: 'Search',
    searching: 'Searching‚Ä¶',
    segment: 'Segment',
    plan: 'Plan',
    hooks: 'Hooks',
    nearby: 'Nearby (businesses)',
    demog: 'SCB: Median disposable income by age (tkr)',
    loading_map: 'Loading map‚Ä¶',
  },
} as const;

export default function GeoPage() {
  const [lang, setLang] = useState<Lang>('sv')
  const [address, setAddress] = useState('')
  const [radius, setRadius] = useState(600)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | undefined>()
  const [data, setData] = useState<GeoResp | null>(null)
  const [scb, setScb] = useState<any | null>(null)

  const L = LTEXT[lang]

  const DEMO_MOCK: DemoData = {
    year: 2020,
    incomeByAge: [
      { age: '20‚Äì24', tkr: 190 },
      { age: '25‚Äì34', tkr: 260 },
      { age: '35‚Äì44', tkr: 310 },
      { age: '45‚Äì54', tkr: 330 },
      { age: '55‚Äì64', tkr: 300 },
      { age: '65‚Äì74', tkr: 260 },
    ],
    population: 347_000,
    densityPerKm2: 5100,
  }

  useEffect(() => {
    const ql = new URLSearchParams(window.location.search).get('lang')
    if (ql === 'en') setLang('en')
  }, [])

  const { isLoaded } = useLoadScript({
    googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!,
    libraries: ['places'],
  })

  function onKeyDownSubmit(e: React.KeyboardEvent<HTMLInputElement>) {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      search()
    }
  }

  async function search() {
    try {
      setLoading(true)
      setError(undefined)
      setData(null)
      setScb(null)

      const r = await fetch(
        `/api/geo/pois?address=${encodeURIComponent(address)}&radius_m=${radius}&lang=${lang}`,
        { cache: 'no-store' }
      )
      if (!r.ok) {
        const tx = await r.text().catch(() => '')
        throw new Error(tx || `HTTP ${r.status}`)
      }
      const json: GeoResp = await r.json()
      setData(json)

      const kommunCode = guessKommunCodeFromAddress(json?.address, lang) || ''
      if (kommunCode) {
        const sr = await fetch(
          `/api/geo/scb?region=${encodeURIComponent(kommunCode)}&year=2020&lang=${lang}`,
          { cache: 'no-store' }
        )
        if (sr.ok) {
          const sj = await sr.json()
          setScb(sj)
        }
      }
    } catch (e: any) {
      setError(e?.message || 'Failed to fetch')
    } finally {
      setLoading(false)
    }
  }

  const center = data?.center
  const hasPois = Array.isArray(data?.pois) && data!.pois!.length > 0

  const greenIcon = {
    url: 'https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png',
    scaledSize: { width: 32, height: 32 } as unknown as google.maps.Size,
  }

  const map = useMemo(() => {
    if (!center || !isLoaded) return null
    const centerLatLng = { lat: center.lat, lng: center.lon }
    return (
      <div className="rounded-lg overflow-hidden border" style={{ height: 420 }}>
        <GoogleMap
          center={centerLatLng}
          zoom={16}
          mapContainerStyle={{ width: '100%', height: '100%' }}
          options={{ streetViewControl: false, mapTypeControl: false }}
        >
          <Marker position={centerLatLng} icon={greenIcon} title={address} />
          {hasPois &&
            data!.pois!.slice(0, 30).map((p, i) => (
              <Marker
                key={i}
                position={{ lat: p.lat, lng: p.lon }}
                title={p.name}
              />
            ))}
        </GoogleMap>
      </div>
    )
  }, [center?.lat, center?.lon, isLoaded, hasPois, data, address])

  return (
    <div className="space-y-4">
      <h1 className="text-xl font-semibold">{L.title}</h1>

      <form
        className="grid md:grid-cols-3 gap-3"
        onSubmit={(e) => { e.preventDefault(); search() }}
      >
        <label className="text-sm md:col-span-2">
          {L.address}
          <input
            className="border rounded p-2 w-full"
            value={address}
            onChange={(e) => setAddress(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            placeholder={L.address_ph}
            aria-label={L.enter_hint}
          />
          <GeoElectricityInfo
            address={address}
            center={data?.center ? { lat: data.center.lat, lon: data.center.lon } : undefined}
          />
        </label>
        <label className="text-sm">
          {L.radius}
          <input
            className="border rounded p-2 w-full"
            type="number"
            min={100}
            max={3000}
            step={50}
            value={radius}
            onChange={(e) => setRadius(Number(e.target.value))}
            onKeyDown={onKeyDownSubmit}
          />
        </label>

        <div className="md:col-span-3 flex gap-2">
          <button
            onClick={(e) => { e.preventDefault(); search() }}
            className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
            disabled={loading}
          >
            {loading ? L.searching : L.search}
          </button>
        </div>
      </form>

      {error && <div className="text-red-600 text-sm">{error}</div>}

      <div className="grid md:grid-cols-2 gap-4">
        <div className="space-y-3">
          {data?.segment && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.segment}</div>
              <div className="font-medium">{data.segment}</div>
            </div>
          )}

          {Array.isArray(data?.plan) && data!.plan!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.plan}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.plan!.slice(0, 3).map((p, i) => <li key={i}>{p}</li>)}
              </ul>
            </div>
          )}

          {Array.isArray(data?.hooks) && data!.hooks!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.hooks}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.hooks!.slice(0, 3).map((h, i) => <li key={i}>{h}</li>)}
              </ul>
            </div>
          )}

          {data?.center && (<DemographicsCard data={DEMO_MOCK} title={L.demog} />)}

          {scb &&
            Array.isArray(scb.median_income_by_age) &&
            scb.median_income_by_age.length > 0 && (
              <div className="border rounded p-3 bg-slate-50">
                <div className="text-sm text-slate-600">{L.demog} ‚Äî {scb.year}</div>
                <ul className="list-disc pl-5 text-sm">
                  {scb.median_income_by_age.map((row: any, i: number) => (
                    <li key={i}>{row.age}: {row.tkr}</li>
                  ))}
                </ul>
              </div>
            )}

          {Array.isArray(data?.pois) && data!.pois!.length > 0 && (
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">{L.nearby}</div>
              <ul className="list-disc pl-5 text-sm">
                {data!.pois!.slice(0, 12).map((p, i) => {
                  const dist = typeof p.distance_m === 'number' ? `${Math.round(p.distance_m)} m` : ''
                  const rating = typeof p.rating === 'number' ? ` ‚Ä¢ ‚òÖ ${p.rating}` : ''
                  return (
                    <li key={i}>
                      <span className="font-medium">{p.name || '‚Äî'}</span>
                      {p.type ? <> ‚Ä¢ {p.type}</> : null}
                      {dist ? <> ‚Ä¢ {dist}</> : null}
                      {rating ? <>{rating}</> : null}
                    </li>
                  )
                })}
              </ul>
            </div>
          )}
        </div>

        <div>{map || (
          <div className="h-[420px] border rounded bg-slate-50 grid place-items-center text-slate-500">
            {L.loading_map}
          </div>
        )}</div>
      </div>
    </div>
  )
}

function guessKommunCodeFromAddress(addr?: string | null, lang: Lang = 'sv'): string | undefined {
  if (!addr) return undefined
  const txt = addr.toLowerCase()
  const matches = KOMMUNER.filter(
    (k) =>
      k.name_sv.toLowerCase() === txt ||
      txt.includes(k.name_sv.toLowerCase()) ||
      txt.includes(k.name_en.toLowerCase())
  )
  if (matches.length > 0) return matches[0].code
  if (/malm/.test(txt)) return '1280'
  if (/stockholm/.test(txt)) return '0180'
  if (/g√∂teborg|goteborg|gothenburg/.test(txt)) return '1480'
  return undefined
}

--- app/app/qa/QAClient.tsx ---
// app/app/qa/QAClient.tsx
'use client'

import { useState } from 'react'

export default function QAClient() {
  const [question, setQuestion] = useState('')
  const [loading, setLoading] = useState(false)
  const [answer, setAnswer] = useState<string | null>(null)

  async function handleSubmit(e: React.FormEvent) {
    e.preventDefault()
    if (!question.trim()) return
    setLoading(true)
    setAnswer(null)

    try {
      const res = await fetch('/api/qa', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ question }),
      })
      const data = await res.json()
      setAnswer(data.answer || 'No answer received.')
    } catch (err) {
      console.error(err)
      setAnswer('Error fetching answer.')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="max-w-2xl mx-auto space-y-6">
      <form onSubmit={handleSubmit} className="space-y-3">
        <label className="block text-sm font-medium text-gray-700">
          Question / Signal
        </label>
        <input
          type="text"
          placeholder="Ask your question..."
          className="w-full border rounded p-3"
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
        />

        <button
          type="submit"
          disabled={loading}
          className="bg-[var(--brand)] text-white rounded px-4 py-2 disabled:opacity-50"
        >
          {loading ? 'Loading...' : 'Get Answer'}
        </button>
      </form>

      {answer && (
        <div className="p-4 border rounded bg-slate-50">
          <h2 className="font-medium mb-2">Answer:</h2>
          <p>{answer}</p>
        </div>
      )}
    </div>
  )
}

--- app/app/qa/page.tsx ---
"use client";

import React, { useEffect, useMemo, useState, KeyboardEvent } from "react";
import GeoElectricityInfo from "@/components/GeoElectricityInfo";
import { GoogleMap, Marker, useLoadScript } from "@react-google-maps/api";

type Item = { id: string; name: string };

// ------- Geo types (same shape as /api/geo/pois) -------
type Lang = "sv" | "en";
type Poi = {
  name: string;
  type?: string;
  distance_m?: number;
  lat: number;
  lon: number;
  rating?: number;
  address?: string;
};
type GeoResp = {
  center?: { lat: number; lon: number };
  address?: string;
  radius_m?: number;
  pois?: Poi[];
  segment?: string;
  plan?: string[];
  hooks?: string[];
  demographics?: { median_income?: string; families?: string; students?: string };
  lang?: Lang;
};

// ---------- Little helpers ----------
function StarRating({
  value,
  onChange,
  onEnter,
}: {
  value: number;
  onChange: (v: number) => void;
  onEnter?: () => void;
}) {
  return (
    <div
      className="flex gap-1 items-center text-xl select-none"
      tabIndex={0}
      onKeyDown={(e) => {
        if (e.key === "Enter" && onEnter) onEnter();
        if (e.key === "ArrowRight") onChange(Math.min(5, (value || 0) + 1));
        if (e.key === "ArrowLeft") onChange(Math.max(1, (value || 0) - 1));
      }}
      aria-label="Betyg 1‚Äì5"
      role="radiogroup"
    >
      {[1, 2, 3, 4, 5].map((n) => (
        <button
          key={n}
          type="button"
          className="px-1"
          onClick={() => onChange(n)}
          aria-checked={value === n}
          role="radio"
          title={`${n}/5`}
        >
          {n <= value ? "‚òÖ" : "‚òÜ"}
        </button>
      ))}
    </div>
  );
}

function AnswerBlock({
  title,
  text,
  onCopy,
  liked,
  onLike,
  onDislike,
}: {
  title: string;
  text: string;
  onCopy: () => void;
  liked: "like" | "dislike" | "";
  onLike: () => void;
  onDislike: () => void;
}) {
  if (!text) return null;
  return (
    <div className="border rounded p-3 bg-white">
      <div className="font-medium mb-2">{title}</div>
      <div className="whitespace-pre-wrap text-sm leading-relaxed">{text}</div>
      <div className="flex gap-3 mt-3 text-sm">
        <button type="button" onClick={onCopy} className="px-2 py-1 border rounded">
          üìã Kopiera
        </button>
        <button
          type="button"
          onClick={onLike}
          className={`px-2 py-1 border rounded ${liked === "like" ? "bg-green-50" : ""}`}
        >
          üëç Gilla
        </button>
        <button
          type="button"
          onClick={onDislike}
          className={`px-2 py-1 border rounded ${liked === "dislike" ? "bg-red-50" : ""}`}
        >
          üëé Ogilla
        </button>
      </div>
    </div>
  );
}

export default function QAPage() {
  // Language toggle
  const [lang, setLang] = useState<"sv" | "en">("sv");

  // Select data
  const [companies, setCompanies] = useState<Item[]>([]);
  const [profiles, setProfiles] = useState<Item[]>([]);
  const [companyId, setCompanyId] = useState("");
  const [profileId, setProfileId] = useState("");

  // Inputs
  const GOAL_OPTS = useMemo(
    () => ["Kvalificera", "Boka samtal/tid senare", "S√§lj/Avslut"],
    []
  );
  const SEG_OPTS = useMemo(
    () => ["Enpersonshush√•ll", "Tv√•personshush√•ll", "Familjehush√•ll"],
    []
  );
  const CHANNEL_OPTS = useMemo(() => ["Telefon", "SMS", "E-post"], []);

  const [goal, setGoal] = useState("");
  const [segment, setSegment] = useState("");
  const [channel, setChannel] = useState("");

  const [valueLine, setValueLine] = useState(""); // ‚ÄúV√§rderad rad (valfritt)‚Äù
  const [address, setAddress] = useState("");
  const [question, setQuestion] = useState("");

  // Submit state
  const [submitting, setSubmitting] = useState(false);

  // Outputs
  const [oneLiner, setOneLiner] = useState("");
  const [why, setWhy] = useState("");
  const [ack, setAck] = useState("");
  const [shortScript, setShortScript] = useState("");
  const [fullScript, setFullScript] = useState("");
  const [math, setMath] = useState("");
  const [nextStep, setNextStep] = useState("");

  // Feedback state per block
  const [likes, setLikes] = useState<Record<string, "like" | "dislike" | "">>({
    one_liner: "",
    why: "",
    ack: "",
    short_script: "",
    full_script: "",
    math: "",
    next_step: "",
  });
  const [rating, setRating] = useState(0);

  // Companies & profiles
  useEffect(() => {
    (async () => {
      try {
        const [cRes, pRes] = await Promise.all([
          fetch("/api/qa/companies").then((r) => r.json()).catch(() => ({ items: [] })),
          fetch("/api/qa/profiles").then((r) => r.json()).catch(() => ({ items: [] })),
        ]);
        setCompanies(Array.isArray(cRes.items) ? cRes.items : []);
        setProfiles(Array.isArray(pRes.items) ? pRes.items : []);
      } catch {
        setCompanies([]);
        setProfiles([]);
      }
    })();
  }, []);

  const onKeyDownSubmit = (
    e: KeyboardEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>
  ) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      onSubmit();
    }
  };

  // --------- NEW: geo state + map loader ----------
  const [geo, setGeo] = useState<GeoResp | null>(null);
  const [geoLoading, setGeoLoading] = useState(false);
  const [geoError, setGeoError] = useState<string | undefined>(undefined);
  const { isLoaded: mapLoaded } = useLoadScript({
    googleMapsApiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY!,
    libraries: ["places"],
  });

  async function fetchGeoIfAddress() {
    if (!address.trim()) {
      setGeo(null);
      setGeoError(undefined);
      return;
    }
    try {
      setGeoLoading(true);
      setGeoError(undefined);
      setGeo(null);
      const r = await fetch(
        `/api/geo/pois?address=${encodeURIComponent(address)}&radius_m=600&lang=${lang}`,
        { cache: "no-store" }
      );
      if (!r.ok) {
        const tx = await r.text().catch(() => "");
        throw new Error(tx || `HTTP ${r.status}`);
      }
      const json: GeoResp = await r.json();
      setGeo(json);
    } catch (e: any) {
      setGeoError(e?.message || "geo_failed");
    } finally {
      setGeoLoading(false);
    }
  }

  async function onSubmit() {
    if (submitting) return;
    if (!question.trim()) return;
    setSubmitting(true);

    // Kick off geo fetch in parallel (if address present)
    const geoPromise = fetchGeoIfAddress();

    try {
      const res = await fetch("/api/qa/ask", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          lang,
          companyId: companyId || undefined,
          profileId: profileId || undefined,
          goal: goal || undefined,
          segment: segment || undefined,
          channel: channel || undefined,
          valueLine: valueLine || undefined,
          address: address || undefined,
          question: question.trim(),
        }),
      });
      const j = await res.json().catch(() => null);
      if (!res.ok || !j?.ok) {
        console.error("ask failed", j);
        return;
      }
      setOneLiner(j.one_liner || "");
      setWhy(j.why || "");
      setAck(j.ack || "");
      setShortScript(j.short_script || "");
      setFullScript(j.full_script || "");
      setMath(j.math || "");
      setNextStep(j.next_step || "");
      // reset feedback
      setLikes({
        one_liner: "",
        why: "",
        ack: "",
        short_script: "",
        full_script: "",
        math: "",
        next_step: "",
      });
      setRating(0);
    } finally {
      // Ensure geo finished too (even if ask failed)
      await geoPromise.catch(() => {});
      setSubmitting(false);
    }
  }

  const copyText = async (t: string) => {
    try {
      await navigator.clipboard.writeText(t || "");
    } catch {}
  };

  const FieldLabel = ({ children }: { children: React.ReactNode }) => (
    <div className="text-sm font-medium text-slate-700 mb-1">{children}</div>
  );

  // ---- map helpers ----
  const center = geo?.center ? { lat: geo.center.lat, lng: geo.center.lon } : undefined;
  const hasPois = Array.isArray(geo?.pois) && (geo?.pois?.length || 0) > 0;
  const greenIcon = {
    url: "https://maps.gstatic.com/mapfiles/ms2/micons/green-dot.png",
    scaledSize: { width: 32, height: 32 } as unknown as google.maps.Size,
  };

  return (
    <div className="max-w-3xl mx-auto p-4 md:p-6">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-2xl font-semibold">Q&amp;A</h1>
        <div className="flex gap-2">
          <button
            type="button"
            className={`px-3 py-1 rounded border ${lang === "sv" ? "bg-slate-900 text-white" : ""}`}
            onClick={() => setLang("sv")}
          >
            SV
          </button>
          <button
            type="button"
            className={`px-3 py-1 rounded border ${lang === "en" ? "bg-slate-900 text-white" : ""}`}
            onClick={() => setLang("en")}
          >
            EN
          </button>
        </div>
      </div>

      {/* Row 1: Company + Profile */}
      <div className="grid md:grid-cols-2 gap-3 mb-3">
        <div>
          <FieldLabel>F√∂retag</FieldLabel>
          <select
            className="w-full border rounded px-3 py-2"
            value={companyId}
            onChange={(e) => setCompanyId(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          >
            <option value="">{lang === "en" ? "Select company‚Ä¶" : "V√§lj f√∂retag‚Ä¶"}</option>
            {companies.map((c) => (
              <option key={c.id} value={c.id}>
                {c.name}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Profil</FieldLabel>
          <select
            className="w-full border rounded px-3 py-2"
            value={profileId}
            onChange={(e) => setProfileId(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          >
            <option value="">{lang === "en" ? "Select profile‚Ä¶" : "V√§lj profil‚Ä¶"}</option>
            {profiles.map((p) => (
              <option key={p.id} value={p.id}>
                {p.name}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Row 2: Goal + Segment + Channel */}
      <div className="grid md:grid-cols-3 gap-3 mb-3">
        <div>
          <FieldLabel>M√•l (valfritt)</FieldLabel>
          <select
            value={goal}
            onChange={(e) => setGoal(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select goal‚Ä¶" : "V√§lj m√•l‚Ä¶"}</option>
            {GOAL_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Segment (valfritt)</FieldLabel>
          <select
            value={segment}
            onChange={(e) => setSegment(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select segment‚Ä¶" : "V√§lj segment‚Ä¶"}</option>
            {SEG_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>

        <div>
          <FieldLabel>Kanal (valfritt)</FieldLabel>
          <select
            value={channel}
            onChange={(e) => setChannel(e.target.value)}
            onKeyDown={onKeyDownSubmit}
            className="w-full border rounded px-3 py-2"
          >
            <option value="">{lang === "en" ? "Select channel‚Ä¶" : "V√§lj kanal‚Ä¶"}</option>
            {CHANNEL_OPTS.map((x) => (
              <option key={x} value={x}>
                {x}
              </option>
            ))}
          </select>
        </div>
      </div>

      {/* Row 3: Value line + Address */}
      <div className="grid md:grid-cols-2 gap-3 mb-3">
        <div>
          <FieldLabel>V√§rderad rad (valfritt)</FieldLabel>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            placeholder={
              lang === "en"
                ? "Example: reduce your electricity bill up to 30 percent per month"
                : "Exempel: s√§nk din elr√§kning upp till 30 % per m√•nad"
            }
            value={valueLine}
            onChange={(e) => setValueLine(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          />
        </div>

        <div>
          <FieldLabel>Adress (valfritt)</FieldLabel>
          <input
            type="text"
            className="w-full border rounded px-3 py-2"
            placeholder={
              lang === "en"
                ? "Example: S√∂dra F√∂rstadsgatan 1, Malm√∂"
                : "Exempel: S√∂dra F√∂rstadsgatan 1, Malm√∂"
            }
            value={address}
            onChange={(e) => setAddress(e.target.value)}
            onKeyDown={onKeyDownSubmit}
          />
        </div>
      </div>

      {/* Row 4: Question full width */}
      <div className="mb-2">
        <FieldLabel>Fr√•ga / Signal</FieldLabel>
        <textarea
          className="w-full border rounded px-3 py-2 min-h-[90px]"
          placeholder={
            lang === "en"
              ? 'How do I handle "I don‚Äôt have time"?'
              : 'Hur hanterar jag ‚Äùjag har inte tid‚Äù?'
          }
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          onKeyDown={(e) => {
            if (e.key === "Enter" && !e.shiftKey) {
              e.preventDefault();
              onSubmit();
            }
          }}
        />
      </div>

      {/* Submit centered */}
      <div className="flex justify-center mb-6">
        <button
          type="button"
          onClick={onSubmit}
          disabled={submitting || !question.trim()}
          className="px-4 py-2 rounded bg-[var(--brand)] text-white disabled:opacity-50"
        >
          {lang === "en" ? "Get answer" : "H√§mta svar"}
        </button>
      </div>

      {/* NEW: Geo panel (shows only when address searched) */}
      {(address.trim() && (geo || geoLoading || geoError)) ? (
        <div className="mb-6 grid md:grid-cols-2 gap-4">
          <div className="space-y-3">
            <div className="border rounded p-3 bg-slate-50">
              <div className="text-sm text-slate-600">
                {lang === "en" ? "Electricity info" : "El-info"}
              </div>
              <GeoElectricityInfo
                address={address}
                center={geo?.center ? { lat: geo.center.lat, lon: geo.center.lon } : undefined}
              />
            </div>

            {geoError && (
              <div className="text-red-600 text-sm">{geoError}</div>
            )}

            {Array.isArray(geo?.pois) && geo!.pois!.length > 0 && (
              <div className="border rounded p-3 bg-slate-50">
                <div className="text-sm text-slate-600">
                  {lang === "en" ? "Nearby (businesses)" : "I n√§rheten (f√∂retag)"}
                </div>
                <ul className="list-disc pl-5 text-sm">
                  {geo!.pois!.slice(0, 10).map((p, i) => {
                    const dist =
                      typeof p.distance_m === "number"
                        ? `${Math.round(p.distance_m)} m`
                        : "";
                    const rating =
                      typeof p.rating === "number" ? ` ‚Ä¢ ‚òÖ ${p.rating}` : "";
                    return (
                      <li key={i}>
                        <span className="font-medium">{p.name || "‚Äî"}</span>
                        {p.type ? <> ‚Ä¢ {p.type}</> : null}
                        {dist ? <> ‚Ä¢ {dist}</> : null}
                        {rating ? <>{rating}</> : null}
                      </li>
                    );
                  })}
                </ul>
              </div>
            )}
          </div>

          <div>
            <div className="rounded-lg overflow-hidden border" style={{ height: 320 }}>
              {mapLoaded && center ? (
                <GoogleMap
                  center={center}
                  zoom={16}
                  mapContainerStyle={{ width: "100%", height: "100%" }}
                  options={{ streetViewControl: false, mapTypeControl: false }}
                >
                  <Marker position={center} icon={greenIcon} title={address} />
                  {hasPois &&
                    geo!.pois!.slice(0, 30).map((p, i) => (
                      <Marker
                        key={i}
                        position={{ lat: p.lat, lng: p.lon }}
                        title={p.name}
                      />
                    ))}
                </GoogleMap>
              ) : (
                <div className="h-full grid place-items-center text-slate-500 bg-slate-50">
                  {geoLoading
                    ? (lang === "en" ? "Loading map‚Ä¶" : "Laddar karta‚Ä¶")
                    : (lang === "en" ? "No map" : "Ingen karta")}
                </div>
              )}
            </div>
          </div>
        </div>
      ) : null}

      {/* Answers */}
      {(oneLiner || why || ack || shortScript || fullScript || math || nextStep) && (
        <div className="space-y-3">
          <AnswerBlock
            title="One-liner"
            text={oneLiner}
            onCopy={() => copyText(oneLiner)}
            liked={likes.one_liner}
            onLike={() => setLikes((l) => ({ ...l, one_liner: l.one_liner === "like" ? "" : "like" }))}
            onDislike={() =>
              setLikes((l) => ({ ...l, one_liner: l.one_liner === "dislike" ? "" : "dislike" }))
            }
          />
          <AnswerBlock
            title="Varf√∂r"
            text={why}
            onCopy={() => copyText(why)}
            liked={likes.why}
            onLike={() => setLikes((l) => ({ ...l, why: l.why === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, why: l.why === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="Bekr√§fta"
            text={ack}
            onCopy={() => copyText(ack)}
            liked={likes.ack}
            onLike={() => setLikes((l) => ({ ...l, ack: l.ack === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, ack: l.ack === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="Kort manus"
            text={shortScript}
            onCopy={() => copyText(shortScript)}
            liked={likes.short_script}
            onLike={() =>
              setLikes((l) => ({ ...l, short_script: l.short_script === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({
                ...l,
                short_script: l.short_script === "dislike" ? "" : "dislike",
              }))
            }
          />
          <AnswerBlock
            title="Fullt manus"
            text={fullScript}
            onCopy={() => copyText(fullScript)}
            liked={likes.full_script}
            onLike={() =>
              setLikes((l) => ({ ...l, full_script: l.full_script === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({
                ...l,
                full_script: l.full_script === "dislike" ? "" : "dislike",
              }))
            }
          />
          <AnswerBlock
            title="Utr√§kning"
            text={math}
            onCopy={() => copyText(math)}
            liked={likes.math}
            onLike={() => setLikes((l) => ({ ...l, math: l.math === "like" ? "" : "like" }))}
            onDislike={() => setLikes((l) => ({ ...l, math: l.math === "dislike" ? "" : "dislike" }))}
          />
          <AnswerBlock
            title="N√§sta steg"
            text={nextStep}
            onCopy={() => copyText(nextStep)}
            liked={likes.next_step}
            onLike={() =>
              setLikes((l) => ({ ...l, next_step: l.next_step === "like" ? "" : "like" }))
            }
            onDislike={() =>
              setLikes((l) => ({ ...l, next_step: l.next_step === "dislike" ? "" : "dislike" }))
            }
          />

          {/* Overall rating */}
          <div className="border rounded p-3 bg-white">
            <div className="font-medium mb-2">
              {lang === "en" ? "Rating (whole answer)" : "Betyg (hela svaret)"}
            </div>
            <StarRating value={rating} onChange={setRating} onEnter={() => {}} />
          </div>
        </div>
      )}
    </div>
  );
}

--- app/app/layout.tsx ---
import AppNav from '@/components/AppNav'
// app/app/layout.tsx
import { ReactNode } from "react";
import { redirect } from "next/navigation";
import AppShell from "@/components/AppShell";
import { supabaseServer } from "@/lib/supabaseServer";

export const dynamic = "force-dynamic";
export const runtime = 'nodejs'

export default async function AppLayout({ children }: { children: ReactNode }) {
  const supabase = await supabaseServer();
  const { data: { user }, error } = await supabase.auth.getUser();

  if (error || !user) redirect("/auth");

  return <AppShell>{children}</AppShell>;
}

--- app/app/error.tsx ---
"use client";

export default function AppError({ error, reset }: { error: unknown; reset: () => void }) {
  console.error("[/app] error boundary:", error);
  return (
    <div className="p-6 space-y-3">
      <h1 className="text-xl font-semibold">Something went wrong</h1>
      <p className="text-slate-600 text-sm">
        Please try again. If it keeps happening, sign out and back in.
      </p>
      <div className="flex gap-2">
        <button
          className="px-4 py-2 rounded bg-black text-white"
          onClick={() => reset()}
        >
          Try again
        </button>
        <a className="px-4 py-2 rounded border" href="/auth/signout">
          Sign out
        </a>
      </div>
    </div>
  );
}

--- app/app/profiles/page.tsx ---
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type Profile = {
  id?: string
  name: string
  language?: string
  tone?: string
  goals?: string
  persona_hints?: string
}

export default function ProfilesPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<Profile[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<Profile | null>(null)
  const [form, setForm] = useState<Profile>({
    name: '',
    language: '',
    tone: '',
    goals: '',
    persona_hints: '',
  })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load(){
    setLoading(true); setError(null)
    try{
      const r = await fetch('/api/profiles', { headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load profiles failed:', e)
      setError(t(lang,'common.error')); setRows([])
    }finally{ setLoading(false) }
  }

  useEffect(()=>{ load() },[]) // eslint-disable-line react-hooks/exhaustive-deps
  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){
    setEditing(null)
    setForm({ name:'', language:'', tone:'', goals:'', persona_hints:'' })
    setOpen(true)
  }
  function openEdit(p: Profile){
    setEditing(p)
    setForm({
      id: p.id,
      name: p.name || '',
      language: p.language || '',
      tone: p.tone || '',
      goals: p.goals || '',
      persona_hints: p.persona_hints || '',
    })
    setOpen(true)
  }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/profiles/${editing.id}` : '/api/profiles'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type':'application/json', accept:'application/json' },
        body: JSON.stringify(form)
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save profile failed:', e)
      alert(t(lang,'common.error'))
    }finally{ setSaving(false) }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/profiles/${id}`, { method:'DELETE', headers: { accept:'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) throw new Error(await r.text().catch(()=>`HTTP ${r.status}`))
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete profile failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'profiles.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'profiles.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'profiles.list.empty')}</div>}

      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {rows.map(p=>(
          <div key={p.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{p.name || '‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={()=>openEdit(p)}>{t(lang,'common.edit')}</button>
                <ConfirmDialog onConfirm={()=>del(p.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm space-y-1 text-slate-700">
              {p.language && <div><b>{t(lang,'profiles.form.language')}:</b> {p.language}</div>}
              {p.tone && <div><b>{t(lang,'profiles.form.tone')}:</b> {p.tone}</div>}
              {p.goals && <div><b>{t(lang,'profiles.form.goals')}:</b> {p.goals}</div>}
              {p.persona_hints && <div><b>{t(lang,'profiles.form.persona')}:</b> {p.persona_hints}</div>}
            </div>
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'profiles.edit') : t(lang,'profiles.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'profiles.form.name')}
              <input
                className="border rounded p-2 w-full"
                value={form.name}
                placeholder={t(lang,'profiles.ph.name')}
                onChange={e=>setForm({...form, name:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.language')}
              <input
                className="border rounded p-2 w-full"
                value={form.language}
                placeholder={t(lang,'profiles.ph.language')}
                onChange={e=>setForm({...form, language:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.tone')}
              <input
                className="border rounded p-2 w-full"
                value={form.tone}
                placeholder={t(lang,'profiles.ph.tone')}
                onChange={e=>setForm({...form, tone:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.goals')}
              <input
                className="border rounded p-2 w-full"
                value={form.goals}
                placeholder={t(lang,'profiles.ph.goals')}
                onChange={e=>setForm({...form, goals:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'profiles.form.persona')}
              <textarea
                className="border rounded p-2 w-full min-h-[90px]"
                value={form.persona_hints}
                placeholder={t(lang,'profiles.ph.persona')}
                onChange={e=>setForm({...form, persona_hints:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}

--- app/app/events/page.tsx ---
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type EventItem = {
  id?: string
  ts?: string        // ISO date-time
  title?: string
  type?: string
  notes?: string
  tags?: string
}

export default function EventsPage(){
  const [lang, setLang] = useState<Lang>('sv')
  const [rows, setRows] = useState<EventItem[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<EventItem | null>(null)
  const [form, setForm] = useState<EventItem>({
    ts: new Date().toISOString().slice(0,16),
    title: '',
    type: '',
    notes: '',
    tags: ''
  })

  useEffect(()=>{ setLang(getLang()) },[])

  async function load(){
    setLoading(true)
    setError(null)
    try{
      const r = await fetch('/api/events', { headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      const data = await r.json().catch(()=>[])
      setRows(Array.isArray(data) ? data : [])
    }catch(e){
      console.error('Load events failed:', e)
      setRows([])
      setError(t(lang,'common.error'))
    }finally{
      setLoading(false)
    }
  }

  useEffect(()=>{ load() /* on mount */ },[]) // eslint-disable-line react-hooks/exhaustive-deps

  useEffect(()=>{ document.body.style.overflow = open ? 'hidden' : '' ; return ()=>{ document.body.style.overflow = '' } },[open])

  function openNew(){
    setEditing(null)
    setForm({
      ts: new Date().toISOString().slice(0,16),
      title: '',
      type: '',
      notes: '',
      tags: ''
    })
    setOpen(true)
  }
  function openEdit(e: EventItem){
    setEditing(e)
    setForm({
      id: e.id,
      ts: (e.ts||'').slice(0,16),
      title: e.title||'',
      type: e.type||'',
      notes: e.notes||'',
      tags: e.tags||'',
    })
    setOpen(true)
  }

  async function save(){
    if (saving) return
    setSaving(true)
    try{
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/events/${editing.id}` : '/api/events'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', accept: 'application/json' },
        body: JSON.stringify(form)
      })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      setOpen(false); setEditing(null)
      await load()
    }catch(e){
      console.error('Save event failed:', e)
      alert(t(lang,'common.error'))
    }finally{
      setSaving(false)
    }
  }

  async function del(id?: string){
    if (!id) return
    try{
      const r = await fetch(`/api/events/${id}`, { method: 'DELETE', headers: { accept: 'application/json' } })
      if (r.status === 401) { window.location.assign('/auth'); return }
      if (!r.ok) { throw new Error(await r.text().catch(()=>`HTTP ${r.status}`)) }
      setRows(prev => prev.filter(x=>x.id!==id))
    }catch(e){
      console.error('Delete event failed:', e)
      alert(t(lang,'common.error'))
    }
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'events.title')}</h1>
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2" onClick={openNew}>
          {t(lang,'events.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && rows.length===0 && <div className="text-slate-500">{t(lang,'events.list.empty')}</div>}

      <div className="border rounded overflow-x-auto">
        <table className="w-full text-sm">
          <thead className="bg-slate-50">
            <tr>
              <th className="p-2">{t(lang,'events.table.date')}</th>
              <th className="p-2">{t(lang,'events.table.title')}</th>
              <th className="p-2">{t(lang,'events.table.type')}</th>
              <th className="p-2">{t(lang,'events.table.notes')}</th>
              <th className="p-2">{t(lang,'events.table.tags')}</th>
              <th className="p-2"></th>
            </tr>
          </thead>
          <tbody>
            {rows.map(e=>(
              <tr key={e.id} className="border-t">
                <td className="p-2 whitespace-nowrap">{e.ts ? new Date(e.ts).toLocaleString() : '‚Äî'}</td>
                <td className="p-2">{e.title||'‚Äî'}</td>
                <td className="p-2">{e.type||'‚Äî'}</td>
                <td className="p-2">{e.notes||'‚Äî'}</td>
                <td className="p-2">{e.tags||'‚Äî'}</td>
                <td className="p-2 text-right whitespace-nowrap">
                  <button className="mr-2 underline" onClick={()=>openEdit(e)}>{t(lang,'common.edit')}</button>
                  <ConfirmDialog onConfirm={()=>del(e.id)}>
                    <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                  </ConfirmDialog>
                </td>
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'events.edit') : t(lang,'events.new')}
          onClose={()=>setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'events.form.date')}
              <input
                type="datetime-local"
                className="border rounded p-2 w-full"
                value={form.ts}
                onChange={e=>setForm({...form, ts:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.title')}
              <input
                className="border rounded p-2 w-full"
                value={form.title}
                placeholder={t(lang,'events.ph.title')}
                onChange={e=>setForm({...form, title:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.type')}
              <input
                className="border rounded p-2 w-full"
                value={form.type}
                placeholder={t(lang,'events.ph.type')}
                onChange={e=>setForm({...form, type:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.notes')}
              <textarea
                className="border rounded p-2 w-full min-h-[90px]"
                value={form.notes}
                placeholder={t(lang,'events.ph.notes')}
                onChange={e=>setForm({...form, notes:e.target.value})}
              />
            </label>
            <label className="text-sm">{t(lang,'events.form.tags')}
              <input
                className="border rounded p-2 w-full"
                value={form.tags}
                placeholder={t(lang,'events.ph.tags')}
                onChange={e=>setForm({...form, tags:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}

--- app/app/upload/page.tsx ---
'use client'
import { useState } from 'react'

export default function UploadPage() {
  const [file, setFile] = useState<File|null>(null)
  const [msg, setMsg] = useState('')
  async function onSubmit(e: React.FormEvent) {
    e.preventDefault()
    setMsg('')
    if (!file) { setMsg('V√§lj en ljudfil f√∂rst.'); return }
    const fd = new FormData()
    fd.append('file', file)
    const r = await fetch('/api/audio/upload', { method: 'POST', body: fd })
    const j = await r.json().catch(()=>null)
    if (!r.ok || !j?.ok) { setMsg(j?.error || 'Uppladdning misslyckades'); return }
    setMsg('Uppladdat och transkriberat!')
  }

  return (
    <div className="max-w-xl mx-auto p-6 space-y-4">
      <h1 className="text-2xl font-semibold">Upload audio</h1>
      <form onSubmit={onSubmit} className="space-y-3">
        <input
          type="file"
          accept="audio/*"
          onChange={(e)=>setFile(e.target.files?.[0] || null)}
          className="block"
        />
        <button className="bg-[var(--brand)] text-white rounded px-4 py-2">
          Upload & Transcribe
        </button>
      </form>
      {msg && <div className="text-sm text-slate-700">{msg}</div>}
    </div>
  )
}

--- app/app/company/page.tsx ---
'use client'
import { useEffect, useState } from 'react'
import Modal from '@/components/Modal'
import ConfirmDialog from '@/components/ConfirmDialog'
import { getLang, t, type Lang } from '@/lib/i18n'

type Company = {
  id?: string
  company_name: string
  geo_notes?: string
  unique_features?: string
  compliance?: string
  proof_points?: string
  disclaimer?: string
}

export default function CompanyPage() {
  const [lang, setLang] = useState<Lang>('sv')
  const [items, setItems] = useState<Company[]>([])
  const [open, setOpen] = useState(false)
  const [saving, setSaving] = useState(false)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [editing, setEditing] = useState<Company | null>(null)
  const [form, setForm] = useState<Company>({
    company_name: '',
    geo_notes: '',
    unique_features: '',
    compliance: '',
    proof_points: '',
    disclaimer: '',
  })

  useEffect(() => { setLang(getLang()) }, [])

  async function fetchCompanies() {
    setLoading(true)
    setError(null)
    try {
      const r = await fetch('/api/company', { headers: { accept: 'application/json' } })
      if (r.status === 401) {
        // not authenticated (avoid crashing on .json())
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      const data = await r.json().catch(() => [])
      setItems(Array.isArray(data) ? data : [])
    } catch (e: any) {
      console.error('Load companies failed:', e)
      setError(t(lang, 'common.error'))
      setItems([])
    } finally {
      setLoading(false)
    }
  }

  useEffect(() => {
    fetchCompanies()
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  useEffect(() => {
    // lock background scroll while modal open
    document.body.style.overflow = open ? 'hidden' : ''
    return () => { document.body.style.overflow = '' }
  }, [open])

  async function save() {
    if (saving) return
    setSaving(true)
    try {
      const method = editing?.id ? 'PUT' : 'POST'
      const url = editing?.id ? `/api/company/${editing.id}` : '/api/company'
      const r = await fetch(url, {
        method,
        headers: { 'Content-Type': 'application/json', accept: 'application/json' },
        body: JSON.stringify(form),
      })
      if (r.status === 401) {
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      setOpen(false)
      setEditing(null)
      await fetchCompanies()
    } catch (e) {
      console.error('Save company failed:', e)
      alert(t(lang, 'common.error'))
    } finally {
      setSaving(false)
    }
  }

  async function del(id?: string) {
    if (!id) return
    try {
      const r = await fetch(`/api/company/${id}`, { method: 'DELETE', headers: { accept: 'application/json' } })
      if (r.status === 401) {
        window.location.assign('/auth')
        return
      }
      if (!r.ok) {
        const text = await r.text().catch(() => '')
        throw new Error(text || `HTTP ${r.status}`)
      }
      setItems(prev => prev.filter(i => i.id !== id))
    } catch (e) {
      console.error('Delete company failed:', e)
      alert(t(lang, 'common.error'))
    }
  }

  function openNew() {
    setEditing(null)
    setForm({
      company_name: '',
      geo_notes: '',
      unique_features: '',
      compliance: '',
      proof_points: '',
      disclaimer: '',
    })
    setOpen(true)
  }

  function openEdit(c: Company) {
    setEditing(c)
    setForm({
      company_name: c.company_name || '',
      geo_notes: c.geo_notes || '',
      unique_features: c.unique_features || '',
      compliance: c.compliance || '',
      proof_points: c.proof_points || '',
      disclaimer: c.disclaimer || '',
      id: c.id,
    })
    setOpen(true)
  }

  return (
    <div className="min-h-screen">
      <div className="flex items-center justify-between mb-4">
        <h1 className="text-xl font-semibold">{t(lang,'company.title')}</h1>
        <button
          className="bg-[var(--brand)] text-white rounded px-4 py-2"
          onClick={openNew}
        >
          {t(lang,'company.new')}
        </button>
      </div>

      {loading && <div className="text-slate-500">{t(lang,'common.loading')}</div>}
      {!loading && error && <div className="text-red-600 text-sm">{error}</div>}
      {!loading && !error && items.length === 0 && (
        <div className="text-slate-500">{t(lang,'company.list.empty')}</div>
      )}

      <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
        {items.map(c => (
          <div key={c.id} className="rounded-xl border p-4 bg-white shadow-sm">
            <div className="flex items-center justify-between mb-2">
              <div className="font-semibold">{c.company_name || '‚Äî'}</div>
              <div className="flex items-center gap-3">
                <button className="underline" onClick={() => openEdit(c)}>{t(lang,'company.edit')}</button>
                <ConfirmDialog onConfirm={() => del(c.id)}>
                  <button className="text-red-600 underline">{t(lang,'common.delete')}</button>
                </ConfirmDialog>
              </div>
            </div>
            <div className="text-sm space-y-1 text-slate-700">
              {c.geo_notes && <div><b>{t(lang,'company.card.geo')}:</b> {c.geo_notes}</div>}
              {c.unique_features && <div><b>{t(lang,'company.card.unique')}:</b> {c.unique_features}</div>}
              {c.compliance && <div><b>{t(lang,'company.form.compliance')}:</b> {c.compliance}</div>}
              {c.proof_points && <div><b>{t(lang,'company.form.proof')}:</b> {c.proof_points}</div>}
              {c.disclaimer && <div><b>{t(lang,'company.card.disclaimer')}:</b> {c.disclaimer}</div>}
            </div>
          </div>
        ))}
      </div>

      {open && (
        <Modal
          title={editing ? t(lang,'company.edit') : t(lang,'company.new')}
          onClose={() => setOpen(false)}
          onSubmit={save}
          primaryLabel={saving ? t(lang,'common.loading') : t(lang,'common.save')}
          cancelLabel={t(lang,'common.cancel')}
        >
          <div className="grid gap-3">
            <label className="text-sm">{t(lang,'company.form.name')}
              <input
                className="border rounded p-2 w-full"
                value={form.company_name}
                placeholder={t(lang,'company.ph.name')}
                onChange={e=>setForm({...form, company_name:e.target.value})}
              />
            </label>

            <label className="text-sm">{t(lang,'company.form.geo')}
              <input
                className="border rounded p-2 w-full"
                value={form.geo_notes}
                placeholder={t(lang,'company.ph.geo')}
                onChange={e=>setForm({...form, geo_notes:e.target.value})}
              />
            </label>

            <label className="text-sm">{t(lang,'company.form.unique')}
              <input
                className="border rounded p-2 w-full"
                value={form.unique_features}
                placeholder={t(lang,'company.ph.unique')}
                onChange={e=>setForm({...form, unique_features:e.target.value})}
              />
            </label>

            <div className="grid md:grid-cols-2 gap-3">
              <label className="text-sm">{t(lang,'company.form.compliance')}
                <input
                  className="border rounded p-2 w-full"
                  value={form.compliance}
                  placeholder={t(lang,'company.ph.compliance')}
                  onChange={e=>setForm({...form, compliance:e.target.value})}
                />
              </label>
              <label className="text-sm">{t(lang,'company.form.proof')}
                <input
                  className="border rounded p-2 w-full"
                  value={form.proof_points}
                  placeholder={t(lang,'company.ph.proof')}
                  onChange={e=>setForm({...form, proof_points:e.target.value})}
                />
              </label>
            </div>

            <label className="text-sm">{t(lang,'company.form.disclaimer')}
              <textarea
                className="border rounded p-2 w-full min-h-[110px]"
                value={form.disclaimer}
                placeholder={t(lang,'company.ph.disclaimer')}
                onChange={e=>setForm({...form, disclaimer:e.target.value})}
              />
            </label>
          </div>
        </Modal>
      )}
    </div>
  )
}

--- app/auth/whoami/route.ts ---
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";
export const runtime = "nodejs"; export const dynamic = "force-dynamic";
function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies:{ getAll(){return req.cookies.getAll()}, setAll(c){c.forEach(({name,value,options})=>{res.cookies.set(name,value,options as CookieOptions)})} } }
  );
}
export async function GET(req: NextRequest){
  const res = NextResponse.json({});
  const supabase = makeClient(req,res);
  const { data:{ user }, error } = await supabase.auth.getUser();
  return NextResponse.json({ ok:!!user && !error, error:error?.message||null, user:user?{id:user.id,email:user.email}:null, cookies:req.cookies.getAll().map(c=>c.name) });
}

--- app/auth/signup/route.ts ---
// app/auth/signup/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

function makeSupabaseServer() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  return createClient(url, anon, { auth: { persistSession: false } })
}

// Read either JSON or multipart form
async function readSignupPayload(req: NextRequest) {
  const ct = req.headers.get('content-type') || ''
  if (ct.includes('application/json')) {
    const j = await req.json().catch(() => ({}))
    return {
      email: String(j.email || '').trim(),
      password: String(j.password || '').trim(),
      name: String(j.name || j.fullName || '').trim(),
    }
  }
  if (ct.includes('multipart/form-data') || ct.includes('application/x-www-form-urlencoded')) {
    const f = await req.formData()
    return {
      email: String(f.get('email') || '').trim(),
      password: String(f.get('password') || '').trim(),
      name: String(f.get('name') || f.get('fullName') || '').trim(),
    }
  }
  throw new Error('unsupported_content_type')
}
export async function POST(req: NextRequest) {
  try {
    const { email, password, name } = await readSignupPayload(req)
    if (!email || !password) {
      return NextResponse.json({ error: 'missing_email_or_password' }, { status: 400 })
    }

    const sb = makeSupabaseServer()
    // Where to send magic-link/email-confirm redirects (optional)
    const origin = req.headers.get('origin') || process.env.NEXT_PUBLIC_SITE_URL || ''
    const emailRedirectTo = origin ? `${origin}/auth/callback` : undefined

    const { data, error } = await sb.auth.signUp({
      email,
      password,
      options: {
        data: name ? { name } : undefined,
        emailRedirectTo,
      }
    })

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 400 })
    }

    // Note: depending on Supabase settings, user may need to confirm email first
    return NextResponse.json({ ok: true, user: data.user }, { status: 200 })
  } catch (e:any) {
    if (e?.message === 'unsupported_content_type') {
      return NextResponse.json(
        { error: 'Content-Type must be application/json or multipart/form-data' },
        { status: 415 }
      )
    }
    return NextResponse.json({ error: e?.message || 'signup_failed' }, { status: 500 })
  }
}

--- app/auth/signout/route.ts ---
// app/auth/signout/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function makeClient(req: NextRequest) {
  const res = NextResponse.redirect(new URL("/auth", req.url), 303);
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll(); },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
  return { supabase, res };
}

async function doSignOut(req: NextRequest) {
  const { supabase, res } = makeClient(req);
  await supabase.auth.signOut();
  return res;
}

export async function GET(req: NextRequest)  { return doSignOut(req); }
export async function POST(req: NextRequest) { return doSignOut(req); }

--- app/auth/layout.tsx ---
// app/auth/layout.tsx
import { ReactNode } from "react";
import { redirect } from "next/navigation";
import { supabaseServer } from "@/lib/supabaseServer";

export const dynamic = "force-dynamic";
export const runtime = "nodejs";

export default async function AuthLayout({ children }: { children: ReactNode }) {
  const supabase = await supabaseServer();
  const { data: { user }, error } = await supabase.auth.getUser();
  if (!error && user) redirect("/app/qa");
  return <>{children}</>;
}

--- app/auth/callback/CallbackClient.tsx ---
'use client';

import { Suspense, useEffect } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { supabaseBrowser } from '@/lib/supabaseBrowser';

function CallbackInner() {
  const search = useSearchParams();
  const router = useRouter();

  useEffect(() => {
    const code = search.get('code');
    const err  = search.get('error_description') || search.get('error');

    (async () => {
      try {
        if (err) {
          router.replace('/auth?error=' + encodeURIComponent(err));
          return;
        }
        if (code) {
          const sb = supabaseBrowser();
          await sb.auth.exchangeCodeForSession(code);
          router.replace('/app/qa');
          return;
        }
        router.replace('/auth');
      } catch {
        router.replace('/auth?error=callback_failed');
      }
    })();
  }, [search, router]);

  return <div className="p-6 text-sm text-slate-600">Signing you in‚Ä¶</div>;
}

export default function CallbackClient() {
  return (
    <Suspense fallback={<div className="p-6 text-sm text-slate-600">Loading‚Ä¶</div>}>
      <CallbackInner />
    </Suspense>
  );
}

--- app/auth/callback/page.tsx ---
'use client'
import { useEffect } from 'react'
import { useRouter, useSearchParams } from 'next/navigation'
import { supabaseBrowser } from '@/lib/supabaseBrowser'

export default function AuthCallback(){
  const r = useRouter(); const q = useSearchParams();
  useEffect(()=>{(async()=>{
    const err = q.get('error') || q.get('error_description')
    if (err) return r.replace('/auth?error='+encodeURIComponent(err))
    const { data } = await supabaseBrowser().auth.getSession()
    const at = data.session?.access_token, rt = data.session?.refresh_token
    if(!at || !rt) return r.replace('/auth?error=no_session')
    const s = await fetch('/api/auth/sync',{method:'POST',headers:{'content-type':'application/json'},body:JSON.stringify({access_token:at,refresh_token:rt})})
    if(!s.ok) return r.replace('/auth?error=sync_failed')
    r.replace('/app/qa')
  })()},[q,r])
  return <div className="p-6">Completing sign-in‚Ä¶</div>
}

--- app/auth/page.tsx ---
// app/auth/page.tsx
'use client'
import { useState } from 'react'

export default function AuthPage() {
  const [mode, setMode] = useState<'login'|'signup'>('login')
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [pending, setPending] = useState(false)
  const [msg, setMsg] = useState<string>('')

  async function submit(e: React.FormEvent) {
    e.preventDefault()
    setMsg(''); setPending(true)
    try {
      if (mode === 'login') {
        const r = await fetch('/auth/login', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ email, password }),
        })
        if (!r.ok) {
          const j = await r.json().catch(()=>({}))
          throw new Error(j?.error || `Login failed (${r.status})`)
        }
        // We do NOT manually redirect here. The route already responded 303 to /app/qa.
        // Browser follows automatically; if JS intercepts, we can fallback:
        window.location.href = '/app/qa'
      } else {
        const r = await fetch('/auth/signup', {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({ email, password }),
        })
        const j = await r.json().catch(()=>({}))
        if (!r.ok) throw new Error(j?.error || `Signup failed (${r.status})`)
        setMsg(j?.needsEmailConfirm ? 'Check your email to confirm your account.' : 'Signed up!')
        if (!j?.needsEmailConfirm) window.location.href = '/app/qa'
      }
    } catch (e:any) {
      setMsg(e?.message || 'Auth failed')
    } finally {
      setPending(false)
    }
  }

  return (
    <div className="min-h-screen grid place-items-center p-6">
      <form onSubmit={submit} className="w-full max-w-sm border rounded-xl p-6">
        <h1 className="text-xl font-semibold mb-4">{mode==='login'?'Logga in':'Skapa konto'}</h1>
        <label className="block text-sm mb-2">E-post
          <input className="w-full border rounded p-2" type="email" value={email} onChange={e=>setEmail(e.target.value)} required autoComplete="email" />
        </label>
        <label className="block text-sm mb-4">L√∂senord
          <input className="w-full border rounded p-2" type="password" value={password} onChange={e=>setPassword(e.target.value)} required autoComplete={mode==='login'?'current-password':'new-password'} />
        </label>
        {msg && <p className="text-red-600 text-sm mb-3">{msg}</p>}
        <button className="w-full bg-[var(--brand)] text-white rounded p-2 disabled:opacity-60" disabled={pending}>
          {pending ? 'Arbetar‚Ä¶' : (mode==='login'?'Logga in':'Skapa konto')}
        </button>
        <button type="button" className="w-full mt-2 underline" onClick={()=>setMode(mode==='login'?'signup':'login')}>
          {mode==='login'?'Skapa nytt konto':'Har konto? Logga in'}
        </button>
      </form>
    </div>
  )
}

--- app/auth/login/route.ts ---
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

/** Build an absolute URL on the current origin (works on local & prod www.salesmind.app) */
function urlOnSameOrigin(req: NextRequest, pathname: string) {
  const u = new URL(req.url);
  u.pathname = pathname;
  u.search = "";
  u.hash = "";
  return u.toString();
}

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll() },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            // Forward Supabase Auth cookies onto our redirect response
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
}

export async function POST(req: NextRequest) {
  // IMPORTANT: set the redirect response up-front so cookies can attach to it.
  const res = NextResponse.redirect(urlOnSameOrigin(req, "/app/qa"), 303);
  try {
    const { email, password } = await req.json();
    if (!email || !password) {
      return NextResponse.json({ error: "missing_credentials" }, { status: 400 });
    }
    const supabase = makeClient(req, res);
    const { error } = await supabase.auth.signInWithPassword({ email, password });
    if (error) return NextResponse.json({ error: error.message }, { status: 401 });
    // Cookies are on 'res' now; the 303 ensures the browser re-requests /app/qa with fresh cookies.
    return res;
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "bad_request" }, { status: 400 });
  }
}

--- app/auth/debug/page.tsx ---
// app/auth/debug/page.tsx
import { supabaseServer } from '@/lib/supabaseServer'

export default async function DebugAuthPage(){
  const supabase = await supabaseServer()
  const { data: { user }, error } = await supabase.auth.getUser()
  return (
    <pre className="p-4 text-sm">
      {JSON.stringify({ user, error }, null, 2)}
    </pre>
  )
}

--- app/(site)/sections/HeroSection.tsx ---
// app/(site)/sections/HeroSection.tsx
'use client'

export default function HeroSection() {
  const base = process.env.NEXT_PUBLIC_SUPABASE_URL || ''
  const heroSrc = `${base}/storage/v1/object/public/site/hero.jpg`

  return (
    <section className="max-w-6xl mx-auto px-4 py-16 grid md:grid-cols-2 items-center gap-8">
      <div className="text-center md:text-left">
        <h1 className="text-3xl md:text-5xl font-bold mb-2">
          üß† SalesMind ‚Äì AI Sales Coach for Real-Time Objection Handling
        </h1>
        <h2 className="text-xl mb-4">Turn every sales call into a sale.</h2>

        {/* Mobile-only image placement */}
        <div className="block md:hidden mb-4">
          <img
            src={heroSrc}
            alt="SalesMind AI Coach"
            className="rounded-2xl w-full object-contain"
          />
        </div>

        <p className="text-lg text-gray-700">
          SalesMind helps sales reps handle objections in real time and build trust with prospects
          using conversational AI and personal data insights ‚Äî boosting confidence, connection, and closing rates.
        </p>
      </div>

      {/* Desktop-only hero image on the right */}
      <div className="hidden md:block">
        <img
          src={heroSrc}
          alt="SalesMind AI Coach"
          className="rounded-2xl w-full object-contain"
        />
      </div>
    </section>
  )
}

--- app/(site)/contact/page.tsx ---
export const dynamic = 'force-dynamic'

export default function ContactPage(){
  return (
    <div className="max-w-2xl mx-auto px-4 py-12 md:py-16 space-y-6">
      <h1 className="text-3xl md:text-4xl font-bold">Contact</h1>
      <p className="text-slate-700">
        Email us at <a href="mailto:hello@salesmind.app" className="underline">hello@salesmind.app</a>.
      </p>

      <form
        action="https://formsubmit.co/hello@salesmind.app"
        method="POST"
        className="grid gap-3"
      >
        <input type="hidden" name="_subject" value="SalesMind website contact" />
        <input type="hidden" name="_captcha" value="false" />
        <label className="block">
          <span className="text-sm">Your name</span>
          <input name="name" required className="mt-1 w-full border rounded px-3 py-2" />
        </label>
        <label className="block">
          <span className="text-sm">Email</span>
          <input type="email" name="email" required className="mt-1 w-full border rounded px-3 py-2" />
        </label>
        <label className="block">
          <span className="text-sm">Message</span>
          <textarea name="message" rows={5} required className="mt-1 w-full border rounded px-3 py-2" />
        </label>
        <button className="px-4 py-2 rounded bg-black text-white w-fit">Send</button>
      </form>
    </div>
  )
}

--- app/(site)/features/page.tsx ---
// app/(site)/features/page.tsx
import SiteImage from '@/components/SiteImage'

export const dynamic = 'force-dynamic'

export default function FeaturesPage() {
  return (
    <div className="max-w-6xl mx-auto px-4 py-12 md:py-20 space-y-10">
      <header className="space-y-4 text-center">
        <h1 className="text-3xl md:text-5xl font-bold">üöÄ Key Features</h1>
        <p className="text-lg text-slate-700 max-w-2xl mx-auto">
          SalesMind gives every sales rep the confidence, tools, and insights to
          win more calls ‚Äî all powered by AI.
        </p>
      </header>

      <section className="space-y-10">
        <div className="space-y-4">
          <h2 className="text-2xl font-semibold">üí° Personal Data Insights</h2>
          <p className="text-slate-700">
            Instantly surface public information about prospects ‚Äî like interests,
            company background, or tone hints ‚Äî so you can build trust and relatability
            from the very first seconds of a call.
          </p>
        </div>

        <div className="space-y-4">
          <h2 className="text-2xl font-semibold">üéôÔ∏è Simulation Training</h2>
          <p className="text-slate-700">
            Practice live conversations with an AI-driven customer that reacts like
            a real person. Build confidence, sharpen objection handling, and train
            naturally ‚Äî anytime, anywhere.
          </p>
        </div>

        <div className="space-y-4">
          <h2 className="text-2xl font-semibold">‚ö° AI Coaching Q&A</h2>
          <p className="text-slate-700">
            Get instant answers to any customer objection. Ask ‚ÄúWhat do I say if
            they say it‚Äôs too expensive?‚Äù and receive clear, personalized responses
            in your tone ‚Äî ready to use right away.
          </p>
        </div>
      </section>

      <div className="pt-6">
        <SiteImage
          src="sections/three-icons.jpg"
          alt="Three feature icons layout"
        />
      </div>
    </div>
  )
}

--- app/(site)/layout.tsx ---
// app/(site)/layout.tsx
import MobileMenu from '@/components/MobileMenu'
import type { ReactNode } from 'react'
import Link from 'next/link'
import { siteImageUrl } from '@/lib/siteImages'

export default function SiteLayout({ children }: { children: ReactNode }) {
  const logo = siteImageUrl('logo.png') // upload to Supabase: bucket "site", path "logo.png"
  return (
    <div className="min-h-screen flex flex-col">
      <header className="max-w-6xl w-full mx-auto px-4 py-4 flex flex-col md:flex-row md:items-center md:justify-between gap-4">
        {/* Logo */}
        <div className="flex items-center">
          <Link href="/" className="flex items-center">
            <img
              src={logo || '/placeholder.svg'}
              alt="SalesMind Logo"
              className="h-40 w-auto md:h-40"
            />
          </Link>
        </div>

        {/* Navigation (stacks on mobile, inline on desktop) */}
        <nav className="flex flex-col md:flex-row items-start md:items-center gap-2 md:gap-4 text-sm">
          <Link href="/features">Features</Link>
          <Link href="/pricing">Pricing</Link>
          <Link href="/contact">Contact</Link>
          <Link href="/auth" className="px-3 py-1 rounded border">Log In</Link>
          <Link href="/auth" className="px-3 py-1 rounded bg-black text-white">Sign Up</Link>
        </nav>
      </header>

      <main className="flex-1">{children}</main>

      <footer className="border-t">
        <div className="max-w-6xl mx-auto px-4 py-8 text-sm text-slate-600 text-center md:text-left">
          ¬© {new Date().getFullYear()} SalesMind
        </div>
      </footer>
    </div>
  )
}

--- app/(site)/page.tsx ---
// app/(site)/page.tsx
import Link from 'next/link'
import SiteImage from '@/components/SiteImage'

export const dynamic = 'force-dynamic'

export default function HomePage() {
  return (
    <>
      {/* Hero (no border lines) */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-10 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-8">
            <div className="md:w-1/2 space-y-4">
              <h1 className="text-3xl md:text-5xl font-bold">
                üß† SalesMind ‚Äì AI Sales Coach for Real-Time Objection Handling
              </h1>
              <h3 className="text-xl md:text-2xl text-slate-800">
                Turn every sales call into a sale.
              </h3>
              <p className="text-lg text-slate-700">
                SalesMind helps sales reps handle objections in real time and build trust with prospects using conversational AI and personal data insights ‚Äî boosting confidence, connection, and closing rates.
              </p>
              <div className="flex gap-3">
                <Link href="/auth" className="px-4 py-2 rounded border">Log In</Link>
                <Link href="/auth" className="px-4 py-2 rounded bg-black text-white">Sign Up</Link>
              </div>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="hero.jpg"  // upload to Supabase bucket "site"
                alt="Sales rep using AI assistant during call"
                priority
              />
            </div>
          </div>
        </div>
      </section>

      {/* Built for Sales Reps */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <div className="flex flex-col md:flex-row items-center gap-10">
            <div className="md:w-1/2 space-y-4">
              <h2 className="text-2xl md:text-3xl font-semibold">üéØ Built for Sales Reps Who Want to Win Every Call</h2>
              <p className="text-slate-700">
                <strong>Tired of freezing mid-call?</strong> SalesMind gives you the right words and insights exactly when you need them ‚Äî so you can handle any objection confidently.
              </p>
              <ul className="list-disc ml-5 text-slate-700 space-y-1">
                <li>üß© Personal intel to build trust and relatability</li>
                <li>üéôÔ∏è Live AI feedback on tone and phrasing</li>
                <li>üß† Continuous learning from your real calls</li>
              </ul>
              <blockquote className="p-4 bg-slate-50 rounded">
                ‚ÄúIt‚Äôs like having a coach next to you during every customer call.‚Äù<br/>‚Äî Sales Rep, Telecom Sector
              </blockquote>
            </div>
            <div className="md:w-1/2">
              <SiteImage
                src="sections/coaching.jpg"
                alt="Sales team collaboration or coaching scene"
              />
            </div>
          </div>
        </div>
      </section>
      {/* How It Works */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">‚öôÔ∏è How It Works</h2>
          <ol className="space-y-2 text-slate-700">
            <li>1. <strong>Sign up</strong> ‚Äì self-serve or via your sales manager</li>
            <li>2. <strong>Ask for help mid-call</strong> ‚Äì get tailored objection scripts and customer insights instantly</li>
            <li>3. <strong>Review and learn</strong> ‚Äì your calls become personalized lessons with AI simulations</li>
          </ol>
          <div className="mt-6">
            <SiteImage
              src="sections/flow.jpg"
              alt="Step-by-step flow graphic"
            />
          </div>
        </div>
      </section>

      {/* Why 10√ó Better */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">üí° Why SalesMind Is 10√ó Better</h2>
          <div className="overflow-x-auto border rounded">
            <table className="w-full text-left text-sm">
              <thead className="bg-slate-50">
                <tr>
                  <th className="p-3">Today‚Äôs Way</th>
                  <th className="p-3">With SalesMind</th>
                </tr>
              </thead>
              <tbody>
                <tr className="border-t"><td className="p-3">Managers spend hours repeating the same coaching</td><td className="p-3">AI simulations train reps automatically</td></tr>
                <tr className="border-t"><td className="p-3">Scattered tools for research, notes, and training</td><td className="p-3">One unified platform</td></tr>
                <tr className="border-t"><td className="p-3">Guesswork in customer connection</td><td className="p-3">Personal data insights build rapport instantly</td></tr>
              </tbody>
            </table>
          </div>
          <div className="mt-6">
            <SiteImage
              src="sections/comparison.jpg"
              alt="Comparison chart graphic"
            />
          </div>
        </div>
      </section>
      {/* Key Features */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">üöÄ Key Features</h2>

          <div className="grid md:grid-cols-3 gap-6">
            <div className="p-4 rounded border">
              <h3 className="font-medium mb-2">üí° Personal Data Insights</h3>
              <p className="text-slate-700">
                Instantly surface public information about prospects ‚Äî like interests, company background, or tone hints ‚Äî so you can build trust and relatability from the very first seconds of a call.
              </p>
            </div>
            <div className="p-4 rounded border">
              <h3 className="font-medium mb-2">üéôÔ∏è Simulation Training</h3>
              <p className="text-slate-700">
                Practice live conversations with an AI-driven customer that reacts like a real person. Build confidence, sharpen objection handling, and train naturally ‚Äî anytime, anywhere.
              </p>
            </div>
            <div className="p-4 rounded border">
              <h3 className="font-medium mb-2">‚ö° AI Coaching Q&A</h3>
              <p className="text-slate-700">
                Get instant answers to any customer objection. Ask ‚ÄúWhat do I say if they say it‚Äôs too expensive?‚Äù and receive clear, personalized responses in your tone ‚Äî ready to use right away.
              </p>
            </div>
          </div>

          <div className="mt-6">
            <SiteImage
              src="sections/three-icons.jpg"
              alt="Three feature icons layout"
            />
          </div>
        </div>
      </section>

      {/* Pricing */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">üí∞ Simple Pricing ‚Äì Subscription per Seat</h2>
          <div className="overflow-x-auto border rounded">
            <table className="w-full text-left text-sm">
              <thead className="bg-slate-50">
                <tr>
                  <th className="p-3">Plan</th>
                  <th className="p-3">Description</th>
                  <th className="p-3">Price</th>
                </tr>
              </thead>
              <tbody>
                <tr className="border-t"><td className="p-3 font-medium">Solo</td><td className="p-3">1 rep, unlimited Q&A, personal insights</td><td className="p-3">399 SEK / month</td></tr>
                <tr className="border-t"><td className="p-3 font-medium">Team</td><td className="p-3">10+ reps, shared knowledge base, analytics</td><td className="p-3">from 2,990 SEK / month</td></tr>
                <tr className="border-t"><td className="p-3 font-medium">Enterprise</td><td className="p-3">Custom setup, integrations, dedicated support</td><td className="p-3">Contact us</td></tr>
              </tbody>
            </table>
          </div>
          <div className="mt-6">
            <SiteImage
              src="sections/pricing.jpg"
              alt="Pricing table graphic"
            />
          </div>
        </div>
      </section>

      {/* Why It Works */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">üìà Why It Works</h2>
          <div className="overflow-x-auto border rounded">
            <table className="w-full text-left text-sm">
              <thead className="bg-slate-50">
                <tr>
                  <th className="p-3">Metric</th>
                  <th className="p-3">Impact</th>
                </tr>
              </thead>
              <tbody>
                <tr className="border-t"><td className="p-3">‚è±Ô∏è Time Saved</td><td className="p-3">30‚Äì60 seconds per objection</td></tr>
                <tr className="border-t"><td className="p-3">üíº Deal Conversion</td><td className="p-3">+15‚Äì25% more deals closed</td></tr>
                <tr className="border-t"><td className="p-3">üßë‚Äçüè´ Manager Efficiency</td><td className="p-3">5‚Äì8 hours saved weekly on coaching</td></tr>
              </tbody>
            </table>
          </div>
          <p className="text-slate-700 mt-4">
            Each call becomes a training moment ‚Äî creating stronger, faster, and more confident sales teams.
          </p>
          <div className="mt-6">
            <SiteImage
              src="sections/chart.jpg"
              alt="Data visualization chart or graph"
            />
          </div>
        </div>
      </section>

      {/* About Us */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
          <h2 className="text-2xl md:text-3xl font-semibold mb-6">üåç About Us</h2>
          <p className="text-slate-700">
            SalesMind started in Sweden, built by real sales professionals who‚Äôve lived the challenge of handling objections under pressure.
            Now expanding across the Nordics ‚Äî empowering every sales rep to sell smarter, faster, and more human.
          </p>
          <div className="mt-6">
            <SiteImage
              src="sections/team.jpg"
              alt="Founders portrait or team photo"
            />
          </div>
        </div>
      </section>

      {/* CTA */}
      <section>
        <div className="max-w-6xl mx-auto px-4 py-12 md:py-16 text-center space-y-4">
          <h2 className="text-2xl md:text-3xl font-semibold">‚úÖ Start Free ‚Äì See Results in Minutes</h2>
          <p className="text-slate-700">No credit card. Just make calls. Start selling smarter.</p>
          <div className="flex gap-3 justify-center">
            <Link href="/auth" className="px-4 py-2 rounded bg-black text-white">Sign Up</Link>
            <Link href="/auth" className="px-4 py-2 rounded border">Log In</Link>
          </div>
        </div>
      </section>
    </>
  )
}

--- app/(site)/pricing/page.tsx ---
export const dynamic = 'force-dynamic'

export default function PricingPage(){
  return (
    <div className="max-w-6xl mx-auto px-4 py-12 md:py-16">
      <h1 className="text-3xl md:text-4xl font-bold mb-6">Pricing</h1>

      <div className="overflow-x-auto border rounded">
        <table className="w-full text-left text-sm">
          <thead className="bg-slate-50">
            <tr>
              <th className="p-3">Plan</th>
              <th className="p-3">Description</th>
              <th className="p-3">Price</th>
            </tr>
          </thead>
          <tbody>
            <tr className="border-t">
              <td className="p-3 font-medium">Solo</td>
              <td className="p-3">1 rep, unlimited Q&A, personal insights</td>
              <td className="p-3">399 SEK / month</td>
            </tr>
            <tr className="border-t">
              <td className="p-3 font-medium">Team</td>
              <td className="p-3">10+ reps, shared knowledge base, analytics</td>
              <td className="p-3">from 2,990 SEK / month</td>
            </tr>
            <tr className="border-t">
              <td className="p-3 font-medium">Enterprise</td>
              <td className="p-3">Custom setup, integrations, dedicated support</td>
              <td className="p-3">Contact us</td>
            </tr>
          </tbody>
        </table>
      </div>

      <p className="text-slate-700 mt-6">
        Prices shown exclude VAT. Need a custom plan? <a href="/contact" className="underline">Get in touch</a>.
      </p>
    </div>
  )
}

--- app/layout.tsx ---
// app/layout.tsx ‚Äî neutral root wrapper for *all* routes
import type { ReactNode } from 'react'
import './globals.css'   // ‚úÖ restore Tailwind/global styles

export const dynamic = 'force-dynamic'

export default function RootLayout({ children }: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  )
}

--- app/api/calls/list/route.ts ---
// app/api/calls/list/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

export async function GET(req: NextRequest){
  const res = NextResponse.json({ ok: true })
  try{
    const supabase = makeClient(req, res)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })
    const { data, error } = await supabase
      .from('calls')
      .select('*')
      .eq('owner', user.id)
      .order('created_at', { ascending: false })
    if (error) return NextResponse.json({ items: [] })
    return NextResponse.json({ items: data || [] })
  }catch{
    return NextResponse.json({ items: [] })
  }
}

--- app/api/calls/transcribe/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/calls/transcribe/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'
export const maxDuration = 60

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { chunkText } from '@/lib/chunk'
import { embedText } from '@/lib/embedding'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

async function transcribeWithWhisper(buf: ArrayBuffer, mime: string){
  const apiKey = process.env.OPENAI_API_KEY
  if (!apiKey) throw new Error('OPENAI_API_KEY missing')
  const fd = new FormData()
  fd.append('file', new Blob([buf], { type: mime || 'application/octet-stream' }), 'audio')
  fd.append('model', 'whisper-1')
  // Optional: language hint ‚Äî uncomment if all calls are Swedish
  // fd.append('language', 'sv')

  const r = await fetch('https://api.openai.com/v1/audio/transcriptions', {
    method: 'POST',
    headers: { Authorization: `Bearer ${apiKey}` },
    body: fd
  })
  const j = await r.json().catch(()=> ({}))
  if (!r.ok) throw new Error(j?.error?.message || 'whisper_failed')
  const text: string = j.text || ''
  return text
}

export async function POST(req: NextRequest){
  const res = NextResponse.json({ ok: true })
  try{
    const supabase = makeClient(req, res)
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error || !user) return NextResponse.json({ error:'unauthorized' }, { status:401 })

    const { id } = await req.json()
    if (!id) return NextResponse.json({ error:'missing_id' }, { status:400 })

    // Load call row (owner scoped)
    const { data: call, error: e1 } = await supabase
      .from('calls').select('*').eq('id', id).eq('owner', user.id).single()
    if (e1 || !call) return NextResponse.json({ error:'not_found' }, { status:404 })

    // Get a signed URL to download the audio
    const key = call.filename as string
    const signed = await supabase.storage.from('calls').createSignedUrl(key, 60)
    if (signed.error || !signed.data?.signedUrl) {
      return NextResponse.json({ error: signed.error?.message || 'signed_url_failed' }, { status: 500 })
    }

    // Download audio file into memory
    const audioResp = await fetch(signed.data.signedUrl, { cache: 'no-store' })
    if (!audioResp.ok) {
      return NextResponse.json({ error: `download_failed (${audioResp.status})` }, { status: 502 })
    }
    const mime = audioResp.headers.get('content-type') || call.mime_type || 'application/octet-stream'
    const buf = await audioResp.arrayBuffer()

    // Transcribe with Whisper
    const text = await transcribeWithWhisper(buf, mime)

    // Save transcript on call
    await supabase.from('calls').update({ text }).eq('id', id).eq('owner', user.id)

    // Chunk + embed into call_chunks
    const chunks = chunkText(text, 1200)
    // Remove old chunks (re-run safe)
    await supabase.from('call_chunks').delete().eq('call_id', id)

    let idx = 0
    for (const c of chunks) {
      const emb = await embedText(c)
      const { error: insErr } = await supabase
        .from('call_chunks')
        .insert({ call_id: id, idx: idx++, content: c, embedding: emb as any })
      if (insErr) throw insErr
    }

    return NextResponse.json({ ok:true, id, chunks: chunks.length, chars: text.length })
  }catch(e:any){
    return NextResponse.json({ error: e?.message || 'transcribe_failed' }, { status: 500 })
  }
}

--- app/api/calls/upload/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/calls/upload/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse){
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll(){ return req.cookies.getAll() },
        setAll(c){ c.forEach(({name,value,options})=>res.cookies.set(name,value,options as CookieOptions)) }
      }
    }
  )
}

export async function POST(req: NextRequest) {
  const res = NextResponse.json({ ok: true })
  try {
    const supabase = makeClient(req, res)
    const { data: { user }, error } = await supabase.auth.getUser()
    if (error || !user) return NextResponse.json({ error: 'unauthorized' }, { status: 401 })

    const form = await req.formData()
    const file = form.get('file') as File | null
    if (!file) return NextResponse.json({ error: 'missing_file' }, { status: 400 })

    const key = `${user.id}/${Date.now()}-${(file as any).name || 'call'}`

    // Upload to private bucket 'calls'
    const up = await supabase.storage.from('calls').upload(key, file, {
      contentType: file.type || 'application/octet-stream',
      upsert: false
    })
    if (up.error) return NextResponse.json({ error: up.error.message }, { status: 500 })

    // Insert DB row
    const { data, error: dberr } = await supabase
      .from('calls')
      .insert({
        owner: user.id,
        filename: key,
        mime_type: file.type || null,
        size_bytes: (file as any).size ?? null
      })
      .select()
      .single()

    if (dberr) return NextResponse.json({ error: dberr.message }, { status: 500 })

    return NextResponse.json({ ok: true, item: data })
  } catch (e:any) {
    return NextResponse.json({ error: e?.message || 'upload_failed' }, { status: 500 })
  }
}

--- app/api/kb/route.ts ---
// app/api/kb/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('kb_entries')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('kb_entries')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

--- app/api/kb/[id]/route.ts ---
// app/api/kb/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('kb_entries')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('kb_entries')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}

--- app/api/kb/save/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'

function s() {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  return createClient(url, key, { auth: { persistSession: false } })
}

type SaveBody = {
  companyId?: string
  profileId?: string
  question: string
  outputs: {
    one_liner?: string
    why?: string
    ack?: string
    short_script?: string
    full_script?: string
    math?: string
    next_step?: string
  }
  like?: boolean              // üëç true / üëé false / undefined
  rating?: number | null      // 1..5
  tags?: string[] | null      // optional tags
  eventId?: string | null     // link to qa_events row
}

export async function POST(req: NextRequest) {
  try {
    const supabase = s()
    const body: SaveBody = await req.json()

    if (!body?.question) return NextResponse.json({ error: 'missing_question' }, { status: 400 })

    const tables = ['kb', 'knowledge_base', 'kb_items']
    let inserted: any = null
    let lastError: any = null

    for (const table of tables) {
      const payload: any = {
        company_id: body.companyId || null,
        profile_id: body.profileId || null,
        question: body.question,
        one_liner: body.outputs?.one_liner || null,
        why: body.outputs?.why || null,
        ack: body.outputs?.ack || null,
        short_script: body.outputs?.short_script || null,
        full_script: body.outputs?.full_script || null,
        math: body.outputs?.math || null,
        next_step: body.outputs?.next_step || null,
        liked: body.like ?? null,
        rating: body.rating ?? null,
        tags: body.tags ?? null,
        event_id: body.eventId ?? null
      }

      const { data, error } = await supabase.from(table).insert(payload).select().maybeSingle()
      if (!error && data) { inserted = data; break }
      lastError = error
    }

    if (!inserted) {
      return NextResponse.json({ error: 'insert_failed', detail: lastError?.message || 'kb insert failed' }, { status: 500 })
    }

    return NextResponse.json({ ok: true, item: inserted })
  } catch (e: any) {
    return NextResponse.json({ error: 'kb_save_error', detail: e?.message || String(e) }, { status: 500 })
  }
}

--- app/api/auth/sync/route.ts ---
// app/api/auth/sync/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createServerClient, type CookieOptions } from "@supabase/ssr";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return req.cookies.getAll(); },
        setAll(cookies) {
          cookies.forEach(({ name, value, options }) => {
            res.cookies.set(name, value, options as CookieOptions);
          });
        },
      },
    }
  );
}

export async function POST(req: NextRequest) {
  const res = NextResponse.json({ ok: true });
  try {
    const { access_token, refresh_token } = await req.json();
    if (!access_token || !refresh_token) {
      return NextResponse.json({ error: "missing tokens" }, { status: 400 });
    }
    const supabase = makeClient(req, res);
    const { error } = await supabase.auth.setSession({ access_token, refresh_token });
    if (error) return NextResponse.json({ error: error.message }, { status: 401 });
    return res;
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "bad request" }, { status: 400 });
  }
}

--- app/api/admin/kb/ingest/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/admin/kb/ingest/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'
import { embedText } from '@/lib/embedding'
import { chunkText } from '@/lib/chunk'
import { sbAdmin } from '@/lib/sbAdmin'

function makeClient(req: NextRequest) {
  const res = NextResponse.next()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name) => req.cookies.get(name)?.value,
        set: () => {},
        remove: () => {},
      },
    }
  )
}

async function assertAdmin(req: NextRequest) {
  const supabase = makeClient(req)
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) throw new Error('unauthenticated')
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  const r = await fetch(`${url}/rest/v1/app_users?user_id=eq.${user.id}&select=role`, {
    headers: { apikey:key, Authorization:`Bearer ${key}` }
  })
  const rows = await r.json()
  if (!Array.isArray(rows) || rows[0]?.role !== 'admin') throw new Error('forbidden')
  return user
}

export async function POST(req: NextRequest) {
  try {
    await assertAdmin(req)
    const { title, url, text } = await req.json() as { title:string, url?:string, text:string }
    if (!title || !text) return NextResponse.json({ error:'title and text required' }, { status:400 })

    // upsert source
    const existing = await sbAdmin(`/kb_sources?title=eq.${encodeURIComponent(title)}&select=*`)
    const source_id = existing[0]?.id || (await sbAdmin('/kb_sources', {
      method:'POST',
      headers:{ Prefer:'return=representation' },
      body: JSON.stringify([{ title, kind:'internal', url: url||null }])
    }))[0].id

    // chunk + embed + insert
    const chunks = chunkText(text)
    const rows:any[] = []
    for (const c of chunks) {
      const emb = await embedText(c)
      rows.push({ source_id, content: c, token_count: Math.ceil(c.length/4), embedding: emb })
    }
    await sbAdmin('/kb_chunks', { method:'POST', body: JSON.stringify(rows) })

    return NextResponse.json({ ok:true, source_id, chunks: rows.length })
  } catch (e:any) {
    const msg = e?.message || 'ingest failed'
    const code = /unauthenticated|forbidden/.test(msg) ? 403 : 500
    return NextResponse.json({ error: msg }, { status: code })
  }
}

--- app/api/admin/company/list/route.ts ---
export const runtime = 'nodejs'
import { NextResponse } from 'next/server'

/**
 * Returns [{id,name}] from your DB if available,
 * otherwise [] (no hard failure).
 */
export async function GET() {
  try {
    // TODO: swap in your real DB/Supabase. For now, try env hints or return [].
    // If you already have a route, you can delete this file.
    return NextResponse.json({ companies: [] })
  } catch (e:any) {
    return NextResponse.json({ companies: [] })
  }
}

--- app/api/geo/demographics/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'
import { KOMMUN_CODE_BY_NAME } from '@/lib/kommuner'
import { pxwebFetch } from '@/lib/scb'

/**
 * ENV you can set (dev: .env.local, prod: Vercel envs)
 *
 * SCB_DATASET_URL=
 *   Full PXWeb endpoint URL to a dataset that has:
 *   - Region (kommun) variable
 *   - Age variable
 *   - A measure/indicator we can read (e.g., median income)
 *
 *   Example (NOTE: this is just an illustrative path ‚Äî pick the actual one you want from SCB):
 *   https://api.scb.se/OV0104/v1/doris/sv/ssd/HE/HE0110/HE0110A/DispInkKomMedianK
 *
 * SCB_REGION_CODE=     # e.g. "Region"
 * SCB_AGE_CODE=        # e.g. "Alder"
 * SCB_MEASURE_CODE=    # e.g. "ContentsCode" OR a fixed measure var you include in the query
 * SCB_MEASURE_VALUE=   # e.g. "HE0110KM"  (depends on dataset)
 *
 * AGE bucket mapping (we‚Äôll request a compact set like 20‚Äì29, 30‚Äì44, 45‚Äì64, 65+).
 * You must use values that exist in your chosen dataset.
 *
 * If env is NOT set, we return a clean mocked response so UI still works.
 */

function parseMunicipalityNameFromGoogle(components: any[]): string | null {
  // Try locality first; fallback to postal_town
  const get = (type: string) =>
    components.find((c: any) => (c.types || []).includes(type))?.long_name || null;
  return get('locality') || get('postal_town') || null;
}

// Translate Google lang to sv/en
function pickLocale(searchParams: URLSearchParams) {
  const l = (searchParams.get('lang') || 'sv').toLowerCase();
  return l === 'en' ? 'en' : 'sv';
}

export async function GET(req: NextRequest) {
  try {
    const { searchParams } = new URL(req.url);
    const lang = pickLocale(searchParams);
    const address = searchParams.get('address') || '';
    if (!address.trim()) {
      return NextResponse.json({ error: 'missing address' }, { status: 400 });
    }

    // 1) Geocode with Google to get municipality name
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) return NextResponse.json({ error: 'missing_google_key' }, { status: 500 });

    const geoURL = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}`;
    const geo = await fetch(geoURL).then(r => r.json());
    if (geo.status !== 'OK' || !geo.results?.length) {
      return NextResponse.json({
        error: 'geocode_not_found',
        provider_status: geo.status,
        provider_error: geo.error_message || null
      }, { status: 404 });
    }
    const comp = geo.results[0]?.address_components || [];
    const municipalityName = parseMunicipalityNameFromGoogle(comp);
    const country = comp.find((c:any)=> (c.types||[]).includes('country'))?.short_name || null;

    // 2) If not Sweden, or we fail to detect municipality ‚Üí return mock (so UI still works)
    if (country !== 'SE' || !municipalityName) {
      const mock = lang === 'en'
        ? {
            source: 'mock',
            municipality: municipalityName || '‚Äî',
            demographics: {
              buckets: [
                { age: '20‚Äì29', median_income: '240 000 SEK' },
                { age: '30‚Äì44', median_income: '310 000 SEK' },
                { age: '45‚Äì64', median_income: '340 000 SEK' },
                { age: '65+',   median_income: '270 000 SEK' },
              ]
            }
          }
        : {
            k√§lla: 'mock',
            kommun: municipalityName || '‚Äî',
            demografi: {
              √•lder_inkomst: [
                { √•lder: '20‚Äì29', medianinkomst: '240 000 kr' },
                { √•lder: '30‚Äì44', medianinkomst: '310 000 kr' },
                { √•lder: '45‚Äì64', medianinkomst: '340 000 kr' },
                { √•lder: '65+',   medianinkomst: '270 000 kr' },
              ]
            }
          };
      return NextResponse.json(mock);
    }

    const kommunCode = KOMMUN_CODE_BY_NAME[municipalityName] || null;
    const datasetUrl = process.env.SCB_DATASET_URL;
    const REGION = process.env.SCB_REGION_CODE || 'Region';
    const AGE    = process.env.SCB_AGE_CODE    || 'Alder';
    const MEAS   = process.env.SCB_MEASURE_CODE || 'ContentsCode';
    const MEAS_V = process.env.SCB_MEASURE_VALUE || ''; // optional

    // 3) If no dataset configured or kommun code missing, return mock
    if (!datasetUrl || !kommunCode) {
      const mock = lang === 'en'
        ? {
            source: 'mock',
            municipality: municipalityName,
            demographics: {
              buckets: [
                { age: '20‚Äì29', median_income: '240 000 SEK' },
                { age: '30‚Äì44', median_income: '310 000 SEK' },
                { age: '45‚Äì64', median_income: '340 000 SEK' },
                { age: '65+',   median_income: '270 000 SEK' },
              ]
            }
          }
        : {
            k√§lla: 'mock',
            kommun: municipalityName,
            demografi: {
              √•lder_inkomst: [
                { √•lder: '20‚Äì29', medianinkomst: '240 000 kr' },
                { √•lder: '30‚Äì44', medianinkomst: '310 000 kr' },
                { √•lder: '45‚Äì64', medianinkomst: '340 000 kr' },
                { √•lder: '65+',   medianinkomst: '270 000 kr' },
              ]
            }
          };
      return NextResponse.json(mock);
    }

    // 4) Build a PXWeb query (example age buckets ‚Äî must exist in your chosen dataset)
    // Replace the AGE values with the dataset's actual codes/labels.
    const ageValues = ['20-29', '30-44', '45-64', '65+'];

    const query = {
      query: [
        { code: REGION, selection: { filter: 'item', values: [kommunCode] } },
        { code: AGE,    selection: { filter: 'item', values: ageValues } },
        ...(MEAS_V ? [{ code: MEAS, selection: { filter: 'item', values: [MEAS_V] } }] : []),
      ]
    };

    const json = await pxwebFetch(datasetUrl, query as any);

    // 5) Parse PXWeb JSON: values align with query order
    // We map them back to our 4 age buckets.
    const values: (number|string)[] = json?.data?.map((d: any) => d?.values?.[0]) || [];
    const parsed = ageValues.map((age, i) => {
      const v = values[i];
      const n = typeof v === 'string' ? Number(v.replace(/\s+/g, '')) : (typeof v === 'number' ? v : null);
      return { age, median_income_value: n };
    });

    const payload = lang === 'en'
      ? {
          source: 'scb',
          municipality: municipalityName,
          demographics: {
            buckets: parsed.map(b => ({
              age: b.age,
              median_income: (b.median_income_value != null)
                ? `${Math.round(b.median_income_value).toLocaleString('sv-SE')} SEK`
                : '‚Äî'
            }))
          }
        }
      : {
          k√§lla: 'scb',
          kommun: municipalityName,
          demografi: {
            √•lder_inkomst: parsed.map(b => ({
              √•lder: b.age.replace('-', '‚Äì'),
              medianinkomst: (b.median_income_value != null)
                ? `${Math.round(b.median_income_value).toLocaleString('sv-SE')} kr`
                : '‚Äî'
            }))
          }
        };

    return NextResponse.json(payload);

  } catch (e:any) {
    return NextResponse.json({ error: 'server_error', detail: e?.message }, { status: 500 })
  }
}

--- app/api/geo/scb/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'

/**
 * PXWeb v1 reader for SCB Tab4bDispInkN (Disposable income).
 * GET /api/geo/scb?region=1280&year=2020&lang=sv
 * Returns: { year, region, lang, source, median_income_by_age:[{age, tkr}] }
 */
export async function GET(req: NextRequest) {
  try {
    const url = new URL(req.url)
    const region = (url.searchParams.get('region') || '').trim()
    const year   = (url.searchParams.get('year') || '2020').trim()
    const lang   = (url.searchParams.get('lang') || 'sv').toLowerCase() === 'en' ? 'en' : 'sv'

    if (!region) {
      return NextResponse.json({ error: 'missing_region', detail: 'Provide ?region=kommunkod, e.g. 1280' }, { status: 400 })
    }

    const TABLE     = process.env.SCB_V1_TABLE
    const REGION    = process.env.SCB_REGION_CODE    || 'Region'
    const AGE       = process.env.SCB_AGE_CODE       || 'Alder'
    const TIME      = process.env.SCB_TIME_CODE      || 'Tid'
    const MEASURE   = process.env.SCB_MEASURE_CODE   || 'ContentsCode'
    const MEAS_VAL  = process.env.SCB_MEASURE_VALUE  || '000000KE'
    const HH_CODE   = process.env.SCB_HH_TYPE_CODE   || 'Hushallstyp'
    const HH_KEEP   = process.env.SCB_HH_TYPE_KEEP   || 'E90'

    if (!TABLE) {
      return NextResponse.json({ error: 'missing_env', detail: 'SCB_V1_TABLE not set' }, { status: 500 })
    }

    const endpoint = TABLE.endsWith('/') ? TABLE : TABLE + '/'

    const baseQuery = [
      { code: REGION,  selection: { filter: 'item', values: [region] } },
      { code: AGE,     selection: { filter: 'all',  values: ['*'] } },
      { code: TIME,    selection: { filter: 'item', values: [year] } },
      { code: MEASURE, selection: { filter: 'item', values: [MEAS_VAL] } },
    ]

    const withHH = [
      ...baseQuery,
      { code: HH_CODE, selection: { filter: 'item', values: [HH_KEEP] } },
    ]

    async function postPX(body: any) {
      const resp = await fetch(endpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
          'User-Agent': 'sales-mind-pxweb-client',
          'Cache-Control': 'no-cache',
        },
        body: JSON.stringify({ query: body, response: { format: 'JSON' } }),
        cache: 'no-store',
      })
      const text = await resp.text()
      if (!resp.ok) return { ok: false as const, status: resp.status, text }
      try { return { ok: true as const, json: JSON.parse(text) } }
      catch { return { ok: false as const, status: 502, text } }
    }

    let res = await postPX(withHH)
    if (!res.ok && (res.status === 400 || res.status === 404)) {
      res = await postPX(baseQuery)
    }
    if (!res.ok) {
      return NextResponse.json({ error: 'scb_http', status: res.status, preview: res.text?.slice(0, 300) ?? '' }, { status: 502 })
    }

    const rows: any[] = Array.isArray(res.json?.data) ? res.json.data : Array.isArray(res.json) ? res.json : []
    if (!Array.isArray(rows) || rows.length === 0) {
      return NextResponse.json({ year, region, lang, source: 'SCB PXWeb v1 Tab4bDispInkN', median_income_by_age: [] })
    }

    const columns = res.json?.columns as Array<{ code: string }> | undefined
    let idxRegion = -1, idxAge = -1, idxTime = -1
    if (Array.isArray(columns)) {
      idxRegion = columns.findIndex(c => c.code === REGION)
      idxAge    = columns.findIndex(c => c.code === AGE)
      idxTime   = columns.findIndex(c => c.code === TIME)
    }

    const out: Array<{ age: string, tkr: number }> = []
    for (const row of rows) {
      if (Array.isArray(row.key) && Array.isArray(row.values)) {
        const key = row.key
        const vals = row.values
        const rRegion = idxRegion >= 0 ? key[idxRegion] : region
        const rAge    = idxAge    >= 0 ? key[idxAge]    : ''
        const rTime   = idxTime   >= 0 ? key[idxTime]   : year
        if (rRegion !== region || rTime !== year) continue
        const num = Number(vals[0]?.toString().replace(/\s/g,'').replace(',', '.'))
        if (Number.isFinite(num)) out.push({ age: rAge, tkr: num })
      } else {
        const rRegion = row[REGION] ?? region
        const rAge    = row[AGE]    ?? ''
        const rTime   = row[TIME]   ?? year
        const rawVal  = row.value ?? row.values?.[0]
        const num = Number(String(rawVal ?? '').replace(/\s/g,'').replace(',', '.'))
        if (rRegion === region && rTime === year && Number.isFinite(num)) {
          out.push({ age: String(rAge), tkr: num })
        }
      }
    }

    const order = ['18+', '18-29', '30-49', '50-64', '65-79', '65+', '66+', '80+']
    out.sort((a,b) => {
      const ia = order.indexOf(a.age); const ib = order.indexOf(b.age)
      return (ia === -1 ? 999 : ia) - (ib === -1 ? 999 : ib)
    })

    return NextResponse.json({
      year, region, lang,
      source: 'SCB PXWeb v1 Tab4bDispInkN',
      measure_code: MEAS_VAL,
      median_income_by_age: out,
    })
  } catch (e:any) {
    return NextResponse.json({ error: 'scb_route_error', detail: e?.message || String(e) }, { status: 500 })
  }
}

--- app/api/geo/electricity/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import fs from 'fs/promises'
import path from 'path'

type Point = { lat: number, lon: number }

/** Rough SE bidding zones (SE1..SE4) by latitude */
function guessBiddingZone(lat: number): 'SE1'|'SE2'|'SE3'|'SE4' {
  if (lat >= 64.0) return 'SE1'
  if (lat >= 62.0) return 'SE2'
  if (lat >= 57.7) return 'SE3'
  return 'SE4'
}

/** GeoJSON types */
type Feature = {
  type: 'Feature',
  properties: Record<string, any>,
  geometry: { type: 'Polygon'|'MultiPolygon', coordinates: number[][][] | number[][][][] }
}
type FeatureCollection = { type: 'FeatureCollection', features: Feature[] }

let cachedGeo: FeatureCollection | null = null

/* --- basic point-in-(multi)polygon helpers --- */
function bboxOfCoords(coords: number[][]): [number,number,number,number] {
  let minLon=Infinity, minLat=Infinity, maxLon=-Infinity, maxLat=-Infinity
  for (const [lon,lat] of coords) {
    if (lon < minLon) minLon = lon
    if (lat < minLat) minLat = lat
    if (lon > maxLon) maxLon = lon
    if (lat > maxLat) maxLat = lat
  }
  return [minLon,minLat,maxLon,maxLat]
}
function pointInRing(point: [number,number], ring: number[][]): boolean {
  const [x,y] = point
  let inside = false
  for (let i=0, j=ring.length-1; i<ring.length; j=i++) {
    const [xi, yi] = ring[i]
    const [xj, yj] = ring[j]
    const intersect = ((yi>y)!==(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi+1e-12)+xi)
    if (intersect) inside = !inside
  }
  return inside
}
function pointInPolygon(lonLat: [number,number], poly: number[][][]): boolean {
  if (!poly.length) return false
  const outer = poly[0]
  const [minLon,minLat,maxLon,maxLat] = bboxOfCoords(outer)
  const [lon,lat] = lonLat
  if (lon<minLon || lon>maxLon || lat<minLat || lat>maxLat) return false
  if (!pointInRing(lonLat, outer)) return false
  for (let i=1;i<poly.length;i++) {
    if (pointInRing(lonLat, poly[i])) return false
  }
  return true
}
function pointInMultiPolygon(lonLat: [number,number], multi: number[][][][]): boolean {
  for (const poly of multi) if (pointInPolygon(lonLat, poly)) return true
  return false
}

async function loadGeo(): Promise<FeatureCollection | null> {
  if (cachedGeo) return cachedGeo
  try {
    const file = path.join(process.cwd(), 'data', 'elnat_areas.geojson')
    const txt = await fs.readFile(file, 'utf8')
    const json = JSON.parse(txt)
    if (json && json.type === 'FeatureCollection' && Array.isArray(json.features)) {
      cachedGeo = json
      return cachedGeo
    }
    return null
  } catch {
    return null // dataset is optional
  }
}

async function geocode(address: string): Promise<Point | null> {
  const url = new URL('https://nominatim.openstreetmap.org/search')
  url.searchParams.set('q', address)
  url.searchParams.set('format', 'json')
  url.searchParams.set('addressdetails', '0')
  url.searchParams.set('countrycodes', 'se')
  url.searchParams.set('limit', '1')

  const r = await fetch(url, {
    headers: { 'User-Agent': 'sales-mind/geo-electricity (contact: admin@example.com)' },
    cache: 'no-store',
  })
  if (!r.ok) return null
  const arr = await r.json().catch(()=>[])
  if (!Array.isArray(arr) || !arr.length) return null
  const lat = parseFloat(arr[0].lat), lon = parseFloat(arr[0].lon)
  if (!isFinite(lat) || !isFinite(lon)) return null
  return { lat, lon }
}

export async function GET(req: NextRequest) {
  try {
    const u = new URL(req.url)
    const address = (u.searchParams.get('address') || '').trim()
    const latStr = u.searchParams.get('lat')
    const lonStr = u.searchParams.get('lon')

    let pt: Point | null = null
    if (latStr && lonStr) {
      const lat = parseFloat(latStr), lon = parseFloat(lonStr)
      if (isFinite(lat) && isFinite(lon)) pt = { lat, lon }
    }
    if (!pt && address) pt = await geocode(address)

    if (!pt) {
      return NextResponse.json({ error: 'no_point', detail: 'Provide address or lat/lon.' }, { status: 400 })
    }

    const elomr√•de = guessBiddingZone(pt.lat)

    let elnat: null | { name?: string, orgnr?: string, area_id?: string } = null
    const coll = await loadGeo()
    if (coll && Array.isArray(coll.features)) {
      const p: [number,number] = [pt.lon, pt.lat]
      for (const f of coll.features) {
        try {
          if (f.geometry?.type === 'Polygon') {
            const coords = f.geometry.coordinates as number[][][]
            if (pointInPolygon(p, coords)) { elnat = { name: f.properties?.name, orgnr: f.properties?.orgnr, area_id: f.properties?.area_id }; break }
          } else if (f.geometry?.type === 'MultiPolygon') {
            const coords = f.geometry.coordinates as number[][][][]
            if (pointInMultiPolygon(p, coords)) { elnat = { name: f.properties?.name, orgnr: f.properties?.orgnr, area_id: f.properties?.area_id }; break }
          }
        } catch {}
      }
    }

    return NextResponse.json({
      ok: true,
      input: { address, ...pt },
      elomrade: elomr√•de,
      elnat: elnat,
      dataset_present: !!coll,
      source: {
        geocode: 'OSM Nominatim',
        net_areas: coll ? 'data/elnat_areas.geojson' : 'not-installed'
      }
    })
  } catch (e:any) {
    return NextResponse.json({ error: 'electricity_route_error', detail: e?.message || String(e) }, { status: 500 })
  }
}

--- app/api/geo/pois/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
import { NextRequest, NextResponse } from 'next/server'

const BUSINESS_TYPES = [
  'restaurant','cafe','bar','bakery','meal_takeaway','meal_delivery',
  'supermarket','convenience_store','shopping_mall','department_store',
  'clothing_store','shoe_store','jewelry_store','furniture_store','electronics_store',
  'hardware_store','bicycle_store','book_store','florist','beauty_salon','hair_care',
  'pharmacy','doctor','dentist','veterinary_care',
  'bank','atm','car_rental','car_repair','car_dealer',
  'gas_station','electric_vehicle_charging_station','lodging'
];

function metersBetween(lat1:number, lon1:number, lat2:number, lon2:number){
  const toRad = (d:number)=>d*Math.PI/180;
  const R = 6371000;
  const dLat = toRad(lat2-lat1);
  const dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}

// Map Google type -> localized label (sv/en)
function typeLabel(lang:'sv'|'en', t?:string){
  if(!t) return undefined;
  const map_sv: Record<string,string> = {
    restaurant:'restaurang', cafe:'caf√©', bar:'bar', bakery:'bageri', meal_takeaway:'h√§mtmat',
    meal_delivery:'matleverans', supermarket:'stormarknad',
    convenience_store:'n√§rbutik', shopping_mall:'galleria', department_store:'varuhus',
    clothing_store:'kl√§daff√§r', shoe_store:'skobutik', jewelry_store:'smyckesbutik',
    furniture_store:'m√∂belbutik', electronics_store:'hemelektronik',
    hardware_store:'j√§rnhandel', bicycle_store:'cykelbutik', book_store:'bokhandel', florist:'blomsterhandel',
    beauty_salon:'sk√∂nhetssalong', hair_care:'fris√∂r', pharmacy:'apotek',
    doctor:'l√§kare', dentist:'tandl√§kare', veterinary_care:'veterin√§r',
    bank:'bank', atm:'bankomat',
    car_rental:'biluthyrning', car_repair:'bilverkstad', car_dealer:'bilhandlare',
    gas_station:'bensinstation', electric_vehicle_charging_station:'laddstation',
    lodging:'hotell'
  };
  if(lang==='sv') return map_sv[t] || t;
  return (t || '').replace(/_/g,' ');
}

export async function GET(req: NextRequest) {
  try {
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) return NextResponse.json({ error: 'missing_api_key' }, { status: 500 });

    const { searchParams } = new URL(req.url);
    const address   = (searchParams.get('address') || '').trim();
    const radius_m  = Math.max(100, Math.min(3000, Number(searchParams.get('radius_m')||600)));
    const lang = (searchParams.get('lang') || 'sv').toLowerCase() === 'en' ? 'en' : 'sv';

    if (!address) return NextResponse.json({ error: 'missing address' }, { status: 400 });

    // 1) Geocode (v3)
    const geoURL = `https://maps.googleapis.com/maps/api/geocode/json?address=${encodeURIComponent(address)}&key=${apiKey}&language=${lang}`;
    const geo = await fetch(geoURL, { cache: 'no-store' }).then(r=>r.json());
    if (geo.status !== 'OK' || !geo.results?.length) {
      return NextResponse.json({
        error: 'not_found',
        provider_status: geo.status,
        provider_error: geo.error_message || null
      }, { status: 404 });
    }
    const g0 = geo.results[0];
    const loc = g0.geometry.location; // { lat, lng }

    // 2) Places Nearby (v1 NEW)
    const fieldMask = [
      'places.displayName',
      'places.primaryType',
      'places.types',
      'places.location',
      'places.rating',
      'places.formattedAddress'
    ].join(',');

    // Remove unsupported type "grocery_or_supermarket" (legacy)
    const includedTypes = BUSINESS_TYPES;

    const placesResp = await fetch('https://places.googleapis.com/v1/places:searchNearby', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Goog-Api-Key': apiKey,
        'X-Goog-FieldMask': fieldMask
      },
      body: JSON.stringify({
        languageCode: lang,
        locationRestriction: {
          circle: { center: { latitude: loc.lat, longitude: loc.lng }, radius: radius_m }
        },
        includedTypes
      })
    }).then(r=>r.json());

    if (placesResp.error) {
      return NextResponse.json({
        error: 'places_denied',
        provider_status: placesResp.error.status || 'ERROR',
        provider_error: placesResp.error.message || null
      }, { status: 403 });
    }

    const results = Array.isArray(placesResp.places) ? placesResp.places : [];
    const pois = results.map((p:any)=>{
      const plat = p.location?.latitude;
      const plon = p.location?.longitude;
      const dist = (typeof plat==='number' && typeof plon==='number')
        ? Math.round(metersBetween(loc.lat, loc.lng, plat, plon))
        : undefined;

      // prefer primaryType then types[0]
      const rawType: string | undefined = p.primaryType || (Array.isArray(p.types) ? p.types[0] : undefined);
      return {
        name: p.displayName?.text || '‚Äî',
        type: typeLabel(lang, rawType),
        distance_m: dist,
        lat: plat,
        lon: plon,
        rating: p.rating,
        address: p.formattedAddress || undefined
      };
    }).sort((a:any,b:any)=>(a.distance_m??9e9)-(b.distance_m??9e9));

    const segment = lang === 'en' ? 'Residential / mixed amenities' : 'Bostadsomr√•de / blandad service';
    const plan = lang === 'en'
      ? ['Highlight transparent pricing & easy signup', 'Use neighborhood-tailored content (welcome email)']
      : ['Lyft fram transparent priss√§ttning & enkel signup', 'Anv√§nd omr√•desanpassat inneh√•ll (v√§lkomstmail)'];
    const hooks = lang === 'en'
      ? ['Reference familiar nearby spots if relevant', 'Offer EV/off-peak if chargers present']
      : ['Referera till v√§lk√§nda n√§rliggande platser vid behov', 'Erbjud elbil/off-peak om laddare finns'];

    // IMPORTANT: No mock demographics here anymore.
    return NextResponse.json({
      center: { lat: loc.lat, lon: loc.lng },
      address,
      radius_m,
      pois,
      segment, plan, hooks,
      lang,
      // Pass geocode address components so the UI can infer kommun name -> code
      components: Array.isArray(g0.address_components) ? g0.address_components : []
    });
  } catch (e:any) {
    return NextResponse.json({ error: 'server_error', detail: e?.message }, { status: 500 });
  }
}

--- app/api/qa/ask/route.broken.1762008185.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/qa/ask/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'
type AskBody = {
  lang?: 'sv'|'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown,n:number)=>String(x??'').trim().slice(0,n)
  const two=(s: unknown)=>String(s??'').trim().split(/(?<=[.!?])\s+/).slice(0,2).join(' ').slice(0,500)
  return {
    one_liner:   clip(o?.one_liner, 180),
    why:         clip(typeof o?.why === 'object'
      ? [o.why.qfocus,o.why.personal,o.why.biases,o.why.norms,o.why.law,o.why.implication].filter(Boolean).join(' ')
      : o?.why, 800),
    ack:         clip(o?.ack, 160),
    short_script: two(o?.short_script),
    full_script: clip(o?.full_script, 900),
    math:        clip(o?.math, 220),
    next_step:   clip(o?.next_step, 260),
  }
// --- helpers (company/profile/kb) ---
function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth:{ persistSession:false } }
  )
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = await supabase.from(t).select('*').eq('id', id).maybeSingle()
    if (data) return { table: t, data }
  return { table: '', data: null }
async function fetchKBContext(supabase: ReturnType<typeof s>, companyId?: string, profileId?: string, question?: string) {
  const tables = ['kb','knowledge_base','kb_items']
    let q = supabase.from(t).select('question,one_liner,short_script,full_script,why').order('created_at',{ascending:false}).limit(12)
    if (companyId) q = q.eq('company_id', companyId)
    if (profileId) q = q.eq('profile_id', profileId)
    const { data } = await q as unknown as { data: KBItem[] }
    if (Array.isArray(data) && data.length) {
      const sig = (question||'').toLowerCase().split(/\W+/).filter(Boolean)
      const score = (row: CallSearchRow)=>{ const toks=String(row.question||'').toLowerCase().split(/\W+/); const set=new Set(toks); let s=0; for(const w of sig) if(set.has(w)) s++; return s }
      const top = [...data].sort((a,b)=>score(b)-score(a)).slice(0,3)
      return top.map(r=>{
        const brief = r.one_liner || r.short_script || r.full_script || r.why || ''
        return `Q: ${r.question} -> ${brief}`
      })
    }
  return []
// --- NEW: call transcript context ---
async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string') {
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })
    const lang = body.lang === 'en' ? 'en' : 'sv'
    // cookie-authenticated supabase (we need auth.uid)
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })
    // anon supabase for cross-table lookups (as before)
    const anon = s()
    let company: unknown = null
    if (body.companyId) {
      const c = await fetchById(anon, body.companyId, ['companies','company','organizations'])
      company = c.data
    let profile: unknown = null
    if (body.profileId) {
      const p = await fetchById(anon, body.profileId, ['profiles','sales_profiles','reps'])
      profile = p.data
    // System prompt
    const sysParts = [
      lang === 'sv'
        ? 'Du √§r en professionell s√§ljcoach. Svara alltid p√• svenska.'
        : 'You are a professional sales coach. Always answer in English.',
      'Returnera STRIKT JSON med f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.',
      'short_script: max 2 meningar. full_script: 90‚Äì120 ord.'
    ]
    if (profile) {
      const tone = profile.tone || profile.preferred_tone || profile.voice || ''
      const compliance = profile.compliance || profile.compliance_rules || ''
      const proof = profile.proof || profile.proof_points || ''
      const callback = profile.callback_windows || profile.callback || ''
      if (tone) sysParts.push(`Stil/ton: ${tone}`)
      if (compliance) sysParts.push(`Compliance: ${compliance}`)
      if (proof) sysParts.push(`Bevis/Proof: ${proof}`)
      if (callback) sysParts.push(`F√∂resl√• tider fr√•n: ${callback}`)
    const sys = sysParts.join('\n')
    const kbSnippets = await fetchKBContext(anon, body.companyId, body.profileId, body.question)
    // NEW: call transcript context (top 5)
    let callSnippets: string[] = []
    try {
      const qEmb = await embedQuery(body.question)
      const { data: rows, error } = await supabase.rpc('call_search', {
        p_user_id: user.id,
        p_query_embedding: qEmb,
        p_match_count: 5
      if (!error && Array.isArray(rows)) {
        callSnippets = rows.map((r: unknown)=> r.content).slice(0,5)
      }
    } catch (e) {
      console.warn('call_search_failed', (e as any)?.message)
    const userPieces = [
      `M√•l: ${body.goal || ''}`,
      `Signal: ${body.question}`,
      `Segment: ${body.segment || ''}`,
      `Kanal: ${body.channel || ''}`,
      `V√§rderad rad: ${body.valueLine || ''}`,
      `Adress: ${body.address || ''}`,
    if (company) {
      const name = company.name || company.title || ''
      userPieces.push(`F√∂retag: ${name}`)
      const extra = {
        industry: company.industry,
        market: company.market,
        value_prop: company.value_prop,
        geo: company.geo
      if (Object.values(extra).some(Boolean)) {
        userPieces.push('F√∂retagsdata: ' + JSON.stringify(extra))
    if (profile) userPieces.push(`Profil: ${profile.name || ''}`)
    if (kbSnippets.length) userPieces.unshift('LIKED_KB: ' + kbSnippets.join(' || '))
    if (callSnippets.length) userPieces.unshift('CALL_SNIPPETS: ' + callSnippets.map(s=>s.slice(0,300)).join(' || '))
    const userMsg = userPieces.join(' | ')
    // OpenAI chat
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        temperature: 0.25,
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: userMsg }
        ]
    })
    const raw = await resp.json().catch(()=> ({}))
    if (!resp.ok) return NextResponse.json({ error: 'openai_failed', detail: raw }, { status: 502 })
    let obj: Partial<QAJson>; try{ obj = JSON.parse(raw?.choices?.[0]?.message?.content || '{}') } catch { obj = {} }
    const out = normalize(obj)
    // (Optional) log event as before ‚Äî re-add your insert here if needed.
    return NextResponse.json({ ok:true, ...out })
  } catch (e: unknown) {
    return NextResponse.json({ error: 'ask_route_error', detail: e?.message || String(e) }, { status: 500 })

--- app/api/qa/ask/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'

const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'

type AskBody = {
  lang?: 'sv' | 'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown, n: number) => String(x ?? '').trim().slice(0, n)
  const two = (s: unknown) =>
    String(s ?? '')
      .trim()
      .split(/(?<=[.!?])\s+/)
      .slice(0, 2)
      .join(' ')
      .slice(0, 500)
  return {
    one_liner: clip((o as any)?.one_liner, 180),
    why: clip(
      typeof (o as any)?.why === 'object'
        ? Object.values(o.why || {}).filter(Boolean).join(' ')
        : (o as any)?.why,
      800
    ),
    ack: clip((o as any)?.ack, 160),
    short_script: two((o as any)?.short_script),
    full_script: clip((o as any)?.full_script, 900),
    math: clip((o as any)?.math, 220),
    next_step: clip((o as any)?.next_step, 260),
  }
}

function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth: { persistSession: false } }
  )
}
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = (await supabase.from(t).select('*').eq('id', id).maybeSingle()) as {
      data: Record<string, unknown> | null
    }
    if (data) return { table: t, data }
  }
  return { table: '', data: null }
}

async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      Authorization: `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ model: EMB_MODEL, input: text }),
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
}
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string')
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })

    return NextResponse.json({ ok: true, message: 'Ask route repaired ‚úÖ' })
  } catch (e) {
    return NextResponse.json(
      { error: 'ask_route_error', detail: (e as Error)?.message || String(e) },
      { status: 500 }
    )
  }
}

--- app/api/qa/ask/route.broken.1762007941.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/qa/ask/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import type { KBItem, CallSearchRow, QAJson } from '@/types/qa'
import { supabaseFromRequest } from '@/lib/supabaseRoute'
import { createClient } from '@supabase/supabase-js'
const MODEL = process.env.OPENAI_MODEL || 'gpt-4o-mini'
const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'
type AskBody = {
  lang?: 'sv'|'en'
  companyId?: string
  profileId?: string
  goal?: string
  segment?: string
  channel?: string
  valueLine?: string
  address?: string
  question: string
}
function normalize(o: Partial<QAJson>) {
  const clip = (x: unknown,n:number)=>String(x??'').trim().slice(0,n)
  const two=(s: unknown)=>String(s??'').trim().split(/(?<=[.!?])\s+/).slice(0,2).join(' ').slice(0,500)
  return {
    one_liner:   clip(o?.one_liner, 180),
    why:         clip(typeof o?.why === 'object'
      ? [o.why.qfocus,o.why.personal,o.why.biases,o.why.norms,o.why.law,o.why.implication].filter(Boolean).join(' ')
      : o?.why, 800),
    ack:         clip(o?.ack, 160),
    short_script: two(o?.short_script),
    full_script: clip(o?.full_script, 900),
    math:        clip(o?.math, 220),
    next_step:   clip(o?.next_step, 260),
  }
// --- helpers (company/profile/kb) ---
function s() {
  return createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { auth:{ persistSession:false } }
  )
async function fetchById(supabase: ReturnType<typeof s>, id: string, tables: string[]) {
  for (const t of tables) {
    const { data } = await supabase.from(t).select('*').eq('id', id).maybeSingle()
    if (data) return { table: t, data }
  return { table: '', data: null }
async function fetchKBContext(supabase: ReturnType<typeof s>, companyId?: string, profileId?: string, question?: string) {
  const tables = ['kb','knowledge_base','kb_items']
    let q = supabase.from(t).select('question,one_liner,short_script,full_script,why').order('created_at',{ascending:false}).limit(12)
    if (companyId) q = q.eq('company_id', companyId)
    if (profileId) q = q.eq('profile_id', profileId)
    const { data } = await q as unknown as { data: KBItem[] }
    if (Array.isArray(data) && data.length) {
      const sig = (question||'').toLowerCase().split(/\W+/).filter(Boolean)
      const score = (row: CallSearchRow)=>{ const toks=String(row.question||'').toLowerCase().split(/\W+/); const set=new Set(toks); let s=0; for(const w of sig) if(set.has(w)) s++; return s }
      const top = [...data].sort((a,b)=>score(b)-score(a)).slice(0,3)
      return top.map(r=>{
        const brief = r.one_liner || r.short_script || r.full_script || r.why || ''
        return `Q: ${r.question} -> ${brief}`
      })
    }
  return []
// --- NEW: call transcript context ---
async function embedQuery(text: string) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_query_failed ${r.status}`)
  return j?.data?.[0]?.embedding as number[]
export async function POST(req: NextRequest) {
  try {
    const body: AskBody = await req.json()
    if (!body?.question || typeof body.question !== 'string') {
      return NextResponse.json({ error: 'missing_question' }, { status: 400 })
    const lang = body.lang === 'en' ? 'en' : 'sv'
    // cookie-authenticated supabase (we need auth.uid)
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })
    // anon supabase for cross-table lookups (as before)
    const anon = s()
    let company: unknown = null
    if (body.companyId) {
      const c = await fetchById(anon, body.companyId, ['companies','company','organizations'])
      company = c.data
    let profile: unknown = null
    if (body.profileId) {
      const p = await fetchById(anon, body.profileId, ['profiles','sales_profiles','reps'])
      profile = p.data
    // System prompt
    const sysParts = [
      lang === 'sv'
        ? 'Du √§r en professionell s√§ljcoach. Svara alltid p√• svenska.'
        : 'You are a professional sales coach. Always answer in English.',
      'Returnera STRIKT JSON med f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.',
      'short_script: max 2 meningar. full_script: 90‚Äì120 ord.'
    ]
    if (profile) {
      const tone = profile.tone || profile.preferred_tone || profile.voice || ''
      const compliance = profile.compliance || profile.compliance_rules || ''
      const proof = profile.proof || profile.proof_points || ''
      const callback = profile.callback_windows || profile.callback || ''
      if (tone) sysParts.push(`Stil/ton: ${tone}`)
      if (compliance) sysParts.push(`Compliance: ${compliance}`)
      if (proof) sysParts.push(`Bevis/Proof: ${proof}`)
      if (callback) sysParts.push(`F√∂resl√• tider fr√•n: ${callback}`)
    const sys = sysParts.join('\n')
    const kbSnippets = await fetchKBContext(anon, body.companyId, body.profileId, body.question)
    // NEW: call transcript context (top 5)
    let callSnippets: string[] = []
    try {
      const qEmb = await embedQuery(body.question)
      const { data: rows, error } = await supabase.rpc('call_search', {
        p_user_id: user.id,
        p_query_embedding: qEmb,
        p_match_count: 5
      if (!error && Array.isArray(rows)) {
        callSnippets = rows.map((r: unknown)=> r.content).slice(0,5)
      }
    } catch (e) {
      console.warn('call_search_failed', (e as any)?.message)
    const userPieces = [
      `M√•l: ${body.goal || ''}`,
      `Signal: ${body.question}`,
      `Segment: ${body.segment || ''}`,
      `Kanal: ${body.channel || ''}`,
      `V√§rderad rad: ${body.valueLine || ''}`,
      `Adress: ${body.address || ''}`,
    if (company) {
      const name = company.name || company.title || ''
      userPieces.push(`F√∂retag: ${name}`)
      const extra = {
        industry: company.industry,
        market: company.market,
        value_prop: company.value_prop,
        geo: company.geo
      if (Object.values(extra).some(Boolean)) {
        userPieces.push('F√∂retagsdata: ' + JSON.stringify(extra))
    if (profile) userPieces.push(`Profil: ${profile.name || ''}`)
    if (kbSnippets.length) userPieces.unshift('LIKED_KB: ' + kbSnippets.join(' || '))
    if (callSnippets.length) userPieces.unshift('CALL_SNIPPETS: ' + callSnippets.map(s=>s.slice(0,300)).join(' || '))
    const userMsg = userPieces.join(' | ')
    // OpenAI chat
    const resp = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: { 'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`, 'Content-Type': 'application/json' },
      body: JSON.stringify({
        model: MODEL,
        temperature: 0.25,
        response_format: { type: 'json_object' },
        messages: [
          { role: 'system', content: sys },
          { role: 'user', content: userMsg }
        ]
    })
    const raw = await resp.json().catch(()=> ({}))
    if (!resp.ok) return NextResponse.json({ error: 'openai_failed', detail: raw }, { status: 502 })
    let obj: Partial<QAJson>; try{ obj = JSON.parse(raw?.choices?.[0]?.message?.content || '{}') } catch { obj = {} }
    const out = normalize(obj)
    // (Optional) log event as before ‚Äî re-add your insert here if needed.
    return NextResponse.json({ ok:true, ...out })
  } catch (e: unknown) {
    return NextResponse.json({ error: 'ask_route_error', detail: e?.message || String(e) }, { status: 500 })

--- app/api/qa/route.ts ---
import { NextRequest, NextResponse } from "next/server";
import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function POST(req: NextRequest) {
  // Use Next 15 cookie store directly (type-safe with @supabase/ssr)
  const cookieStore = await cookies();

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    { cookies: cookieStore }
  );

  const { data: { user }, error } = await supabase.auth.getUser();
  if (error) {
    return new NextResponse(`Auth error: ${error.message}`, { status: 401 });
  }
  if (!user) {
    return new NextResponse("Unauthorized", { status: 401 });
  }

  return NextResponse.json({ ok: true });
}

--- app/api/qa/profiles/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })

    const { data, error } = await supabase
      .from('profiles_sales')
      .select('id, name')
      .eq('owner', user.id)
      .order('created_at', { ascending: false })

    if (error) return NextResponse.json({ items: [] })

    const items = (data ?? [])
      .filter((r: any) => r && r.id)
      .map((r: any) => ({ id: r.id, name: r.name || '(namnl√∂s)' }))

    return NextResponse.json({ items })
  } catch {
    return NextResponse.json({ items: [] })
  }
}

--- app/api/qa/companies/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ items: [] })

    const { data, error } = await supabase
      .from('company_profiles')
      .select('id, company_name')
      .eq('owner', user.id)
      .order('company_name', { ascending: true })

    if (error) return NextResponse.json({ items: [] })

    const items = (data ?? [])
      .filter((r: any) => r && r.id)
      .map((r: any) => ({ id: r.id, name: r.company_name || '(namnl√∂s)' }))

    return NextResponse.json({ items })
  } catch {
    return NextResponse.json({ items: [] })
  }
}

--- app/api/lang/route.ts ---
// app/api/lang/route.ts
import { NextResponse } from 'next/server'

export async function POST(req: Request) {
  try {
    const { lang } = await req.json()
    if (lang !== 'sv' && lang !== 'en') {
      return NextResponse.json({ error: 'invalid lang' }, { status: 400 })
    }
    const res = NextResponse.json({ ok: true })
    // 1 year cookie
    res.cookies.set('lang', lang, { path: '/', maxAge: 60 * 60 * 24 * 365 })
    return res
  } catch {
    return NextResponse.json({ error: 'bad request' }, { status: 400 })
  }
}

--- app/api/audio/search/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small'

async function embedOne(text: string): Promise<number[]> {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({ model: EMB_MODEL, input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_failed: ${r.status} ${JSON.stringify(j).slice(0,200)}`)
  return j.data?.[0]?.embedding ?? []
}
export async function POST(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })

    const body = await req.json().catch(()=> ({}))
    const q = (body?.q ?? '').toString().trim()
    const k = Math.max(1, Math.min(12, Number(body?.k ?? 5)))
    if (!q) return NextResponse.json({ error: 'missing_q' }, { status: 400 })

    const emb = await embedOne(q)
    if (!emb?.length) return NextResponse.json({ error: 'embed_empty' }, { status: 500 })

    const { data, error } = await supabase.rpc('call_search', {
      p_query_embedding: emb as any,
      p_match_count: k
    })

    if (error) return NextResponse.json({ error: error.message }, { status: 500 })
    return NextResponse.json({ ok: true, items: data ?? [] })
  } catch (e:any) {
    return NextResponse.json({ error: e?.message || 'server_error' }, { status: 500 })
  }
}

--- app/api/audio/upload/route.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// app/api/audio/upload/route.ts
export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

import { NextRequest, NextResponse } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

const EMB_MODEL = process.env.OPENAI_EMBED_MODEL || 'text-embedding-3-small' // 1536 dims
const TRANSCRIBE_MODEL = process.env.OPENAI_TRANSCRIBE_MODEL || 'whisper-1'  // or 'gpt-4o-transcribe'

async function openaiTranscribe(file: File) {
  const form = new FormData()
  form.append('file', file)
  form.append('model', TRANSCRIBE_MODEL)

  const r = await fetch('https://api.openai.com/v1/audio/transcriptions', {
    method: 'POST',
    headers: { Authorization: `Bearer ${process.env.OPENAI_API_KEY!}` },
    body: form,
  })
  if (!r.ok) {
    const t = await r.text().catch(()=> '')
    throw new Error(`transcribe_failed: ${r.status} ${t}`)
  }
  const j = await r.json()
  return (j?.text || '').trim()
}
async function openaiEmbed(texts: string[]) {
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${process.env.OPENAI_API_KEY!}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ model: EMB_MODEL, input: texts }),
  })
  const j = await r.json()
  if (!r.ok) throw new Error(`embed_failed: ${r.status} ${JSON.stringify(j).slice(0,200)}`)
  return (j?.data || []).map((d:any) => d.embedding as number[])
}

function chunkText(s: string, maxChars = 1200) {
  const out: string[] = []
  let i = 0
  while (i < s.length) {
    let end = Math.min(i + maxChars, s.length)
    const dot = s.lastIndexOf('.', end)
    if (dot > i + 200) end = Math.min(s.length, dot + 1)
    out.push(s.slice(i, end).trim())
    i = end
  }
  return out.filter(Boolean)
}
export async function POST(req: NextRequest) {
  try {
    const { supabase } = supabaseFromRequest(req)
    const { data: { user } } = await supabase.auth.getUser()
    if (!user) return NextResponse.json({ error: 'unauth' }, { status: 401 })

    const form = await req.formData()
    const file = form.get('file') as File | null
    if (!file) return NextResponse.json({ error: 'missing_file' }, { status: 400 })

    const id = crypto.randomUUID()
    const safeName = (file.name || 'audio').replace(/\s+/g,'_')
    const path = `${user.id}/${id}_${safeName}`

    const { error: upErr } = await supabase.storage
      .from('calls')
      .upload(path, await file.arrayBuffer(), {
        contentType: file.type || 'application/octet-stream',
        upsert: false
      })
    if (upErr) return NextResponse.json({ error: `upload_failed: ${upErr.message}` }, { status: 500 })

    const { error: callErr } = await supabase
      .from('calls')
      .insert({
        id, owner: user.id,
        filename: path,
        mime_type: file.type || null,
        size_bytes: file.size || null
      })
    if (callErr) return NextResponse.json({ error: callErr.message }, { status: 500 })
    // transcribe
    const text = await openaiTranscribe(file)
    await supabase.from('calls').update({ text }).eq('id', id)

    // chunk + embed + insert
    const chunks = chunkText(text)
    if (chunks.length) {
      const embs = await openaiEmbed(chunks)
      const rows = chunks.map((content, idx) => ({
        call_id: id, idx, content, embedding: embs[idx]
      }))
      const { error: chErr } = await supabase.from('call_chunks').insert(rows)
      if (chErr) console.error('chunk_insert_error', chErr.message)
    }

    return NextResponse.json({ ok: true, id, chunks: chunks.length })
  } catch (e:any) {
    console.error(e)
    return NextResponse.json({ error: e?.message || 'server_error' }, { status: 500 })
  }
}

--- app/api/me/route.ts ---
// app/api/me/route.ts
// @ts-nocheck
import { NextResponse, NextRequest } from 'next/server'
import { createServerClient } from '@supabase/ssr'

function makeClient(req: NextRequest, res: NextResponse) {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get: (name) => req.cookies.get(name)?.value,
        set: (name, value, options) => res.cookies.set({ name, value, ...options }),
        remove: (name, options) => res.cookies.set({ name, value: '', ...options, maxAge: 0 }),
      },
    }
  )
}

export async function GET(req: NextRequest) {
  const res = NextResponse.json({ ok: true })
  const supabase = makeClient(req, res)
  const { data: { user }, error } = await supabase.auth.getUser()
  if (error) return NextResponse.json({ error: error.message }, { status: 401 })
  return NextResponse.json({ email: user?.email || null })
}

--- app/api/profiles/route.ts ---
// app/api/profiles/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('profiles_sales')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})

  // FREE PLAN: max 1 profile
  const { count } = await supabase
    .from('profiles_sales')
    .select('*', { count: 'exact', head: true })
    .eq('owner', user.id)
  if ((count ?? 0) >= 1) {
    return NextResponse.json(
      { error: 'Free-plan till√•ter max 1 profile. Ta bort den gamla eller uppgradera.' },
      { status: 403 }
    )
  }

  const body = await req.json()
  const { data, error } = await supabase
    .from('profiles_sales')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

--- app/api/profiles/[id]/route.ts ---
// app/api/profiles/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('profiles_sales')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('profiles_sales')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}

--- app/api/events/route.ts ---
// app/api/events/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('events')
    .select('*')
    .eq('owner', user.id)
    .order('ts',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('events')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

--- app/api/events/[id]/route.ts ---
// app/api/events/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('events')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

--- app/api/company/route.ts ---
// app/api/company/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function GET(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'}, {status:401})
  const { data, error } = await supabase
    .from('company_profiles')
    .select('*')
    .eq('owner', user.id)
    .order('created_at',{ascending:false})
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data||[])
}

export async function POST(req: NextRequest){
  const { supabase } = supabaseFromRequest(req)
  const { data: { user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})

  // FREE PLAN: till√•t max 1 company
  const { count } = await supabase
    .from('company_profiles')
    .select('*', { count: 'exact', head: true })
    .eq('owner', user.id)
  if ((count ?? 0) >= 1) {
    return NextResponse.json(
      { error: 'Free-plan till√•ter max 1 company. Ta bort den gamla eller uppgradera.' },
      { status: 403 }
    )
  }

  const body = await req.json()
  const { data, error } = await supabase
    .from('company_profiles')
    .insert([{ ...body, owner: user.id }])
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

--- app/api/company/[id]/route.ts ---
// app/api/company/[id]/route.ts
import { NextResponse, NextRequest } from 'next/server'
import { supabaseFromRequest } from '@/lib/supabaseRoute'

export async function PUT(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const body = await req.json()
  const { data, error } = await supabase
    .from('company_profiles')
    .update(body)
    .eq('id', id)
    .eq('owner', user.id)
    .select()
    .single()
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json(data)
}

export async function DELETE(req: NextRequest, ctx: { params: Promise<{ id: string }> }){
  const { id } = await ctx.params
  const { supabase } = supabaseFromRequest(req)
  const { data:{ user } } = await supabase.auth.getUser()
  if(!user) return NextResponse.json({error:'unauth'},{status:401})
  const { error } = await supabase
    .from('company_profiles')
    .delete()
    .eq('id', id)
    .eq('owner', user.id)
  if(error) return NextResponse.json({error:error.message},{status:400})
  return NextResponse.json({ok:true})
}

--- app/data/kommuner.ts ---
export type Kommun = { kod: string, name: string }
export const KOMMUNER: Kommun[] = [
  { kod: '1280', name: 'Malm√∂' },
  { kod: '0180', name: 'Stockholm' },
  { kod: '1480', name: 'G√∂teborg' },
  // ...extend with your full list later
]

--- app/globals.css ---
@import "tailwindcss";

/* ====== Design tokens (simple, code-first) ====== */
:root {
  --brand: #2563eb;         /* Primary CTA */
  --brand-600: #2563eb;
  --brand-700: #1d4ed8;
  --bg: #ffffff;
  --bg-muted: #f8fafc;
  --fg: #0f172a;
  --muted: #6b7280;
  --border: #e5e7eb;
  --ring: rgba(37, 99, 235, 0.35);
  --success: #16a34a;
  --warning: #f59e0b;
  --danger: #dc2626;

  --radius: 10px;
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.06);
  --shadow-md: 0 8px 24px rgba(0,0,0,0.08);
  --shadow-lg: 0 24px 48px rgba(0,0,0,0.10);
}

html, body {
  height: 100%;
}

body {
  background: var(--bg);
  color: var(--fg);
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji";
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

/* Links */
a { color: var(--brand); }
a:hover { text-decoration: underline; }

/* Focus ring */
:focus-visible {
  outline: 2px solid var(--ring);
  outline-offset: 2px;
  border-radius: 6px;
}

/* Smooth card & modal animations */
@keyframes sm-fade-in {
  from { opacity: 0; transform: translateY(4px) scale(0.98); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}

@keyframes skeleton-shimmer {
  0% { background-position: -200% 0; }
  100% { background-position: 200% 0; }
}

/* Utility helpers */
.container {
  width: 100%;
  max-width: 1100px;
  margin-inline: auto;
  padding-inline: 1rem;
}

/* Table polish */
table { border-collapse: separate; border-spacing: 0; }
thead tr { background: #f8fafc; }
th, td { border-bottom: 1px solid var(--border); }

/* Page header spacing */
.page-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: .75rem;
  padding: .25rem 0 1rem;
}

/* Mobile bottom padding so actions aren't cramped */
main { padding-bottom: 72px; }

--- app/page.removed.1762002668.tsx ---
export { default } from './(site)/page'
export const dynamic = 'force-dynamic'

--- components/ConfirmDialog.tsx ---
'use client'
import { ReactNode, useState } from 'react'

export default function ConfirmDialog({
  children,
  onConfirm,
  title = '√Ñr du s√§ker?',
  cancelLabel = 'Avbryt',
  confirmLabel = 'Ta bort',
}:{
  children:ReactNode
  onConfirm:()=>void
  title?: string
  cancelLabel?: string
  confirmLabel?: string
}){
  const [open,setOpen]=useState(false)
  return (
    <>
      <span onClick={()=>setOpen(true)}>{children}</span>
      {open && (
        <div className="fixed inset-0 bg-black/40 grid place-items-center z-50">
          <div className="bg-white rounded-xl shadow-lg p-6 max-w-sm w-full">
            <p className="mb-4">{title}</p>
            <div className="flex justify-end gap-2">
              <button onClick={()=>setOpen(false)} className="px-4 py-2 rounded bg-slate-200">{cancelLabel}</button>
              <button onClick={()=>{ onConfirm(); setOpen(false) }} className="px-4 py-2 rounded bg-red-600 text-white">{confirmLabel}</button>
            </div>
          </div>
        </div>
      )}
    </>
  )
}

--- components/ui/Card.tsx ---
import React from 'react'
import { cn } from '@/lib/cn'

export default function Card({ className, children }: React.PropsWithChildren<{ className?: string }>) {
  return (
    <div className={cn('rounded-xl border border-[var(--border)] bg-white p-4 shadow-sm', className)} style={{ animation: 'sm-fade-in .18s ease-out both' }}>
      {children}
    </div>
  )
}

--- components/ui/Button.tsx ---
// 'use client'
import React from 'react'
import { cn } from '@/lib/cn'

type Variant = 'primary' | 'secondary' | 'ghost' | 'danger'
type Size = 'sm' | 'md' | 'lg'

export type ButtonProps = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: Variant
  size?: Size
  loading?: boolean
}

export default function Button({
  className,
  variant = 'primary',
  size = 'md',
  loading = false,
  disabled,
  children,
  ...props
}: ButtonProps) {
  const base =
    'inline-flex items-center justify-center rounded-md font-medium transition-all focus-visible:outline-none disabled:opacity-60 disabled:cursor-not-allowed'
  const variants: Record<Variant, string> = {
    primary: 'bg-[var(--brand)] text-white hover:bg-[var(--brand-700)] shadow-sm',
    secondary: 'bg-gray-100 text-gray-900 hover:bg-gray-200',
    ghost: 'bg-transparent hover:bg-gray-100 text-gray-900',
    danger: 'bg-[var(--danger)] text-white hover:bg-red-700'
  }
  const sizes: Record<Size, string> = {
    sm: 'h-8 px-3 text-sm',
    md: 'h-10 px-4 text-sm',
    lg: 'h-12 px-5 text-base'
  }
  return (
    <button
      className={cn(base, variants[variant], sizes[size], loading && 'opacity-80', className)}
      disabled={disabled || loading}
      {...props}
    >
      {loading && <span className="mr-2 inline-block h-4 w-4 animate-spin rounded-full border-2 border-white border-b-transparent" />}
      {children}
    </button>
  )
}

--- components/ui/EmptyState.tsx ---
import React from 'react'
import Card from './Card'
import Button from './Button'

export default function EmptyState({
  title,
  description,
  actionLabel,
  onAction
}: {
  title: string
  description?: string
  actionLabel?: string
  onAction?: () => void
}) {
  return (
    <Card className="text-center py-10">
      <div className="mx-auto mb-3 h-10 w-10 rounded-full bg-gray-100 grid place-items-center">
        <div className="h-5 w-5 rounded-full border-2 border-gray-300" />
      </div>
      <h3 className="text-base font-semibold">{title}</h3>
      {description && <p className="mt-1 text-sm text-gray-600">{description}</p>}
      {actionLabel && onAction && (
        <div className="mt-4">
          <Button onClick={onAction}>{actionLabel}</Button>
        </div>
      )}
    </Card>
  )
}

--- components/ui/Spinner.tsx ---
import React from 'react'
export default function Spinner({ size = 16 }: { size?: number }) {
  const s = `${size}px`
  return <span className="inline-block rounded-full border-2 border-gray-300 border-b-transparent animate-spin" style={{ width: s, height: s }} />
}

--- components/ui/Select.tsx ---
import React from 'react'
import { cn } from '@/lib/cn'

type Props = React.SelectHTMLAttributes<HTMLSelectElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Select({ label, hint, error, className, children, ...props }: Props) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <select
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      >
        {children}
      </select>
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}

--- components/ui/Textarea.tsx ---
import React from 'react'
import { cn } from '@/lib/cn'

type Props = React.TextareaHTMLAttributes<HTMLTextAreaElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Textarea({ label, hint, error, className, rows = 4, ...props }: Props) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <textarea
        rows={rows}
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      />
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}

--- components/ui/Input.tsx ---
import React from 'react'
import { cn } from '@/lib/cn'

export type InputProps = React.InputHTMLAttributes<HTMLInputElement> & {
  label?: string
  hint?: string
  error?: string
}

export default function Input({ label, hint, error, className, ...props }: InputProps) {
  return (
    <label className="block">
      {label && <span className="mb-1 block text-sm text-gray-700">{label}</span>}
      <input
        className={cn(
          'w-full rounded-md border border-[var(--border)] bg-white px-3 py-2 text-sm',
          'focus-visible:outline-none focus:ring-2 focus:ring-[var(--ring)]',
          error && 'border-[var(--danger)] focus:ring-red-200',
          className
        )}
        {...props}
      />
      {hint && !error && <span className="mt-1 block text-xs text-gray-500">{hint}</span>}
      {error && <span className="mt-1 block text-xs text-[var(--danger)]">{error}</span>}
    </label>
  )
}

--- components/ui/Skeleton.tsx ---
import React from 'react'
import { cn } from '@/lib/cn'

export default function Skeleton({ className }: { className?: string }) {
  return (
    <div
      className={cn('h-4 w-full rounded-md bg-gradient-to-r from-gray-200 via-gray-100 to-gray-200 bg-[length:200%_100%]', className)}
      style={{ animation: 'skeleton-shimmer 1.2s ease-in-out infinite' }}
    />
  )
}

--- components/ToasterLite.tsx ---
"use client";
import React from "react";

export function useToasts() {
  const [toasts, set] = React.useState<Array<{id:number; text:string; kind:'ok'|'err'}>>([]);
  const push = (text:string, kind:'ok'|'err'='ok')=>{
    const id = Date.now() + Math.random();
    set(t=>[...t,{id,text,kind}]);
    setTimeout(()=>set(t=>t.filter(x=>x.id!==id)), 3000);
  };
  return { toasts, push };
}

export default function ToasterLite({ toasts }:{ toasts: Array<{id:number; text:string; kind:'ok'|'err'}> }) {
  return (
    <div className="fixed top-2 right-2 space-y-2 z-50">
      {toasts.map(t=>(
        <div key={t.id} className={`px-3 py-2 rounded shadow text-sm ${t.kind==='ok'?'bg-green-600 text-white':'bg-red-600 text-white'}`}>
          {t.text}
        </div>
      ))}
    </div>
  );
}

--- components/AppShell.tsx ---
// components/AppShell.tsx
'use client'
import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useEffect, useState } from 'react'
import { getLang, type Lang, t } from '@/lib/i18n'

export default function AppShell({ children }: { children: React.ReactNode }) {
  const pathname = usePathname()
  const [lang, setLang] = useState<Lang>('sv')

  useEffect(() => { setLang(getLang()) }, [pathname])

const links = [
  { href: '/app/qa',       label: t(lang, 'nav.qa') },
    { href: '/app/upload', label: 'Upload' },
  { href: '/app/profiles', label: t(lang, 'nav.profiles') },
  { href: '/app/company',  label: t(lang, 'nav.company') },
  { href: '/app/kb',       label: t(lang, 'nav.kb') },
  { href: '/app/events',   label: t(lang, 'nav.events') },
  { href: '/app/geo',      label: t(lang, 'nav.geo') },
  { href: '/app/settings', label: t(lang, 'nav.settings') },
]

  return (
    <div className="flex min-h-screen">
      <aside className="w-56 border-r bg-gray-50 p-4">
        <h2 className="font-bold mb-4">{t(lang, 'app.title')}</h2>
        <nav className="flex flex-col gap-2">
          {links.map(l => (
            <Link
              key={l.href}
              href={l.href}
              className={`p-2 rounded ${pathname === l.href ? 'bg-blue-100 text-blue-600 font-medium' : 'hover:bg-gray-100'}`}
            >
              {l.label}
            </Link>
          ))}
        </nav>
      </aside>
      <main className="flex-1 p-6 max-w-[960px]">{children}</main>
    </div>
  )
}

--- components/GeoMapLeaflet.tsx ---
/* eslint-disable @typescript-eslint/no-explicit-any */
'use client'

import dynamic from 'next/dynamic'
import 'leaflet/dist/leaflet.css'
import type { CSSProperties } from 'react'

// Load react-leaflet pieces with SSR disabled (prevents Edge/SSR type issues)
const MapContainer: any = dynamic(
  () => import('react-leaflet').then(m => m.MapContainer),
  { ssr: false }
)
const TileLayer: any = dynamic(
  () => import('react-leaflet').then(m => m.TileLayer),
  { ssr: false }
)
const Marker: any = dynamic(
  () => import('react-leaflet').then(m => m.Marker),
  { ssr: false }
)
const Popup: any = dynamic(
  () => import('react-leaflet').then(m => m.Popup),
  { ssr: false }
)

type LatLon = { lat: number; lon: number }
type Poi = { lat: number; lon: number; name?: string }

export default function GeoMapLeaflet({
  center,
  pois = [],
  height = 360
}: {
  center: LatLon | null
  pois?: Poi[]
  height?: number
}) {
  const style: CSSProperties = { width: '100%', height }

  if (!center) {
    return (
      <div className="h-[360px] border rounded bg-slate-50 grid place-items-center text-slate-500">
        Ange en adress f√∂r att se kartan
      </div>
    )
  }

  // react-leaflet expects [lat, lng]
  const c: [number, number] = [center.lat, center.lon]

  return (
    <div className="w-full rounded-lg overflow-hidden border">
      <MapContainer
        center={c as any}
        zoom={15}
        style={style}
        scrollWheelZoom={true}
        attributionControl={true}
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution="&copy; OpenStreetMap"
        />
        {/* Address center marker */}
        <Marker position={c as any}>
          <Popup>Adressens mitt</Popup>
        </Marker>
        {/* POIs */}
        {pois.slice(0, 50).map((p, i) => (
          <Marker key={i} position={[p.lat, p.lon] as any}>
            {p.name ? <Popup>{p.name}</Popup> : null}
          </Marker>
        ))}
      </MapContainer>
    </div>
  )
}

--- components/AppNav.tsx ---
// components/AppNav.tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'

// tiny cn helper (no external imports needed)
function cn(...c: Array<string | false | null | undefined>) {
  return c.filter(Boolean).join(' ')
}

const nav = [
  { href: '/app/qa', label: 'Q&A' },
  { href: '/app/upload', label: 'Upload' },
  { href: '/app/geo', label: 'Geo' },
  { href: '/app/company', label: 'Company' },
  { href: '/app/profiles', label: 'Profiles' },
  { href: '/app/events', label: 'Events' },
  { href: '/app/kb', label: 'Knowledge Base' },
  { href: '/app/settings', label: 'Settings' },
]

export default function AppNav() {
  const pathname = usePathname()
  return (
    <nav className="flex flex-col space-y-1 text-sm">
      {nav.map((item) => (
        <Link
          key={item.href}
          href={item.href}
          className={cn(
            'rounded px-3 py-2 hover:bg-slate-100 transition',
            pathname.startsWith(item.href) && 'font-medium'
          )}
        >
          {item.label}
        </Link>
      ))}
    </nav>
  )
}

--- components/GeoElectricityInfo.tsx ---
"use client";
import React from "react";

type Center = { lat: number; lon: number };

export default function GeoElectricityInfo({
  address,
  center
}: {
  address?: string;
  center?: Center | null;
}) {
  const [state, setState] = React.useState<{
    loading: boolean;
    elomrade?: string;
    elnatName?: string;
    dataset?: boolean;
    err?: string;
  }>({ loading: false });

  React.useEffect(() => {
    let stop = false;

    async function run() {
      const hasCenter = !!(center && Number.isFinite(center.lat) && Number.isFinite(center.lon));
      const hasAddress = !!(address && address.trim());
      if (!hasCenter && !hasAddress) {
        setState({ loading: false });
        return;
      }
      setState(s => ({ ...s, loading: true, err: undefined }));
      try {
        const qs = hasCenter
          ? `lat=${encodeURIComponent(String(center!.lat))}&lon=${encodeURIComponent(String(center!.lon))}`
          : `address=${encodeURIComponent(address!.trim())}`;
        const r = await fetch(`/api/geo/electricity?${qs}`, { cache: "no-store" });
        const j = await r.json().catch(() => null);
        if (stop) return;
        if (!r.ok || !j?.ok) {
          setState({ loading: false, err: j?.detail || "Kunde inte h√§mta elinformation" });
          return;
        }
        // Debug (visible in browser console)
        console.log("[GeoElectricityInfo]", j);
        setState({
          loading: false,
          elomrade: j.elomrade,
          elnatName: j.elnat?.name || undefined,
          dataset: !!j.dataset_present
        });
      } catch (e: any) {
        if (!stop) setState({ loading: false, err: e?.message || "N√§tverksfel" });
      }
    }

    const t = setTimeout(run, 200); // small debounce
    return () => { stop = true; clearTimeout(t); };
  }, [address, center?.lat, center?.lon]);

  // UI
  return (
    <div className="mt-2">
      <div className="border rounded-md p-3 bg-white">
        <div className="text-sm font-medium mb-1">Elinformation</div>

        {state.loading && (
          <div className="text-sm text-slate-500">H√§mtar elinformation‚Ä¶</div>
        )}

        {state.err && (
          <div className="text-sm text-red-600">{state.err}</div>
        )}

        {!state.loading && !state.err && (
          <div className="text-sm text-slate-800">
            {state.elomrade && (
              <>Elomr√•de: <span className="font-semibold">{state.elomrade}</span></>
            )}
            {state.elnatName && (
              <> ‚Ä¢ Eln√§t: <span className="font-semibold">{state.elnatName}</span></>
            )}
            {!state.elnatName && state.dataset === false && (
              <div className="text-xs text-slate-600 mt-1">
                (Installera <code>data/elnat_areas.geojson</code> f√∂r lokalt eln√§t)
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
}

--- components/AppNav.backup.tsx ---
// components/AppNav.tsx
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/lib/utils' // if you already use a helper for conditional classNames

const nav = [
  { href: '/app/qa', label: 'Q&A' },
    { href: '/app/upload', label: 'Upload' },
    { href: '/app/upload', label: 'Upload' },
  // üÜï new Upload link (right after Q&A)
  { href: '/app/upload', label: 'Upload' },
  { href: '/app/company', label: 'Company' },
  { href: '/app/profiles', label: 'Profiles' },
  { href: '/app/events', label: 'Events' },
  { href: '/app/kb', label: 'Knowledge Base' },
  { href: '/app/settings', label: 'Settings' },
]

export default function AppNav() {
  const pathname = usePathname()
  return (
    <nav className="flex flex-col space-y-1 text-sm">
      {nav.map((item) => (
        <Link
          key={item.href}
          href={item.href}
          className={cn(
            'rounded px-3 py-2 hover:bg-slate-100 transition',
            pathname.startsWith(item.href)
              ? 'bg-[var(--brand-light)] text-[var(--brand-dark)] font-medium'
              : 'text-slate-700'
          )}
        >
          {item.label}
        </Link>
      ))}
    </nav>
  )
}

--- components/Modal.tsx ---
// components/Modal.tsx
'use client'
import { ReactNode, useEffect } from "react"

export default function Modal({
  title,
  children,
  onClose,
  onSubmit,
  primaryLabel = "Save",
  cancelLabel = "Cancel",
}:{
  title: string
  children: ReactNode
  onClose: () => void
  onSubmit: () => void
  primaryLabel?: string
  cancelLabel?: string
}){
  // ESC to close
  useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === "Escape") onClose()
    }
    document.addEventListener("keydown", onKey)
    return () => document.removeEventListener("keydown", onKey)
  }, [onClose])

  // Lock background scroll while modal is open
  useEffect(() => {
    const prev = document.body.style.overflow
    document.body.style.overflow = 'hidden'
    return () => { document.body.style.overflow = prev }
  }, [])

  // Click outside to close
  function onBackdrop(e: React.MouseEvent<HTMLDivElement>) {
    if (e.target === e.currentTarget) onClose()
  }

  return (
    <div
      className="fixed inset-0 z-50 grid place-items-center bg-black/40 p-4"
      onMouseDown={onBackdrop}
      role="dialog"
      aria-modal="true"
    >
      <div
        className="bg-white w-full max-w-xl rounded-2xl shadow-2xl outline-none flex flex-col max-h-[90vh]"
        onMouseDown={(e)=>e.stopPropagation()}
      >
        <div className="px-6 pt-5 pb-3 border-b shrink-0">
          <h2 className="text-lg font-semibold">{title}</h2>
        </div>

        {/* Scrollable body */}
        <div className="px-6 py-4 overflow-y-auto grow">
          {children}
        </div>

        <div className="px-6 pb-5 pt-3 border-t shrink-0 flex justify-end gap-2">
          <button
            onClick={onClose}
            className="px-4 py-2 rounded-md bg-slate-200 hover:bg-slate-300"
          >
            {cancelLabel}
          </button>
          <button
            onClick={onSubmit}
            className="px-4 py-2 rounded-md bg-[var(--brand)] text-white hover:opacity-90"
          >
            {primaryLabel}
          </button>
        </div>
      </div>
    </div>
  )
}

--- components/Toast.tsx ---
'use client'
import { useState } from 'react'
let showToastFn: (msg:string)=>void
export function ToastContainer(){
  const [msg,setMsg]=useState('')
  if(!showToastFn) showToastFn = setMsg
  return msg ? (
    <div className="fixed bottom-4 right-4 bg-black text-white px-4 py-2 rounded shadow">{msg}</div>
  ) : null
}
export function showToast(msg:string){
  if(showToastFn) showToastFn(msg)
  setTimeout(()=> showToastFn && showToastFn(''), 2000)
}

--- components/DemographicsCard.tsx ---
'use client';

type IncomeRow = { age: string; tkr: number };

export type DemoData = {
  year: number;
  incomeByAge: IncomeRow[];
  population?: number;
  densityPerKm2?: number;
  households1pShare?: number; // 0..1 (optional)
  households2pShare?: number; // 0..1 (optional)
};

export default function DemographicsCard({
  data,
  title,
}: {
  data: DemoData;
  title: string;
}) {
  return (
    <div className="border rounded p-3 bg-slate-50">
      <div className="text-sm text-slate-600">
        {title} ‚Äî {data.year}
      </div>
      <ul className="list-disc pl-5 text-sm">
        {typeof data.population === 'number' && (
          <li>Befolkning: {data.population.toLocaleString('sv-SE')}</li>
        )}
        {typeof data.densityPerKm2 === 'number' && (
          <li>T√§thet: {Math.round(data.densityPerKm2)} /km¬≤</li>
        )}
        {Array.isArray(data.incomeByAge) &&
          data.incomeByAge.map((r, i) => (
            <li key={i}>
              {r.age}: {r.tkr} tkr
            </li>
          ))}
        {typeof data.households1pShare === 'number' && (
          <li>Enpersonshush√•ll: {Math.round(data.households1pShare * 100)}%</li>
        )}
        {typeof data.households2pShare === 'number' && (
          <li>Tv√•personshush√•ll: {Math.round(data.households2pShare * 100)}%</li>
        )}
      </ul>
    </div>
  );
}

--- components/SiteImage.tsx ---
'use client'
import Image from 'next/image'
import { siteImageUrl } from '@/lib/siteImages'

type Props = {
  src: string            // path inside "site" bucket, e.g. "hero.jpg" or "features/one.png"
  alt: string
  className?: string
  priority?: boolean
}

/**
 * Responsive <Image/> that:
 * - fills its container width
 * - uses sizes hint so Next.js serves the right size for mobile/desktop
 */
export default function SiteImage({ src, alt, className, priority }: Props) {
  const url = siteImageUrl(src)
  return (
    <div className={className}>
      <Image
        src={url || '/placeholder.svg'}
        alt={alt}
        width={1600}
        height={900}
        priority={priority}
        style={{ width: '100%', height: 'auto' }}
        sizes="(max-width: 768px) 100vw, 50vw"
      />
    </div>
  )
}

--- components/MobileMenu.tsx ---
// components/MobileMenu.tsx
'use client'
import { useState } from 'react'
import Link from 'next/link'

export default function MobileMenu() {
  const [open, setOpen] = useState(false)
  return (
    <div className="md:hidden w-full">
      <div className="flex items-center justify-between">
        <button
          type="button"
          aria-label="Menu"
          aria-expanded={open}
          onClick={() => setOpen(v => !v)}
          className="px-3 py-2 rounded border"
        >
          ‚ò∞ Menu
        </button>

        {/* Log In / Sign Up stay visible (not in dropdown) */}
        <div className="flex items-center gap-2">
          <Link href="/auth" className="px-3 py-1 rounded border">Log In</Link>
          <Link href="/auth" className="px-3 py-1 rounded bg-black text-white">Sign Up</Link>
        </div>
      </div>

      {open && (
        <nav className="mt-2 grid gap-2 rounded border p-3 bg-white" onClick={() => setOpen(false)}>
          <Link href="/features" className="px-2 py-1 rounded hover:bg-slate-50">Features</Link>
          <Link href="/pricing"  className="px-2 py-1 rounded hover:bg-slate-50">Pricing</Link>
          <Link href="/contact"  className="px-2 py-1 rounded hover:bg-slate-50">Contact</Link>
        </nav>
      )}
    </div>
  )
}

--- lib/supabaseRoute.ts ---
// lib/supabaseRoute.ts
import { NextRequest, NextResponse } from 'next/server'
import { createServerClient, type CookieOptions } from '@supabase/ssr'

export function supabaseFromRequest(req: NextRequest) {
  // We return a NextResponse that callers can ignore if they don't need to mutate cookies
  const res = NextResponse.next()

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        // Read cookies from the incoming request
        getAll() {
          return req.cookies.getAll()
        },
        // Write cookies onto the response (Supabase may set/clear auth cookies)
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            // NextResponse.cookies.set(name, value, options)
            res.cookies.set(name, value, options as CookieOptions)
          })
        },
      },
    }
  )

  return { supabase, res }
}

--- lib/serverBaseUrl.ts ---
// lib/serverBaseUrl.ts
export function serverBaseUrl(req: Request) {
  const host = req.headers.get('x-forwarded-host') || req.headers.get('host') || 'localhost:3000'
  const proto = req.headers.get('x-forwarded-proto') || (host.startsWith('localhost') ? 'http' : 'https')
  return `${proto}://${host}`
}

--- lib/sbAdmin.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
// lib/sbAdmin.ts
export async function sbAdmin(path: string, init: RequestInit = {}) {
  const url = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const service = process.env.SUPABASE_SERVICE_KEY!
  const headers = {
    apikey: service,
    Authorization: `Bearer ${service}`,
    'Content-Type': 'application/json',
    ...(init.headers||{})
  }
  const r = await fetch(`${url}/rest/v1${path}`, { ...init, headers, cache:'no-store' })
  const ok = r.ok
  let data:any = null
  try { data = await r.json() } catch {}
  if (!ok) throw new Error(data?.message || `Supabase error: ${r.status}`)
  return data
}

--- lib/qaLogic.ts ---
/* eslint-disable @typescript-eslint/no-explicit-any */
type QAInput = {
  question: string
  goal?: string
  segment?: string
  channel?: string
  numbers?: string
  profileName?: string
  extras?: Record<string,string|number|boolean|undefined|null>
  lang?: 'sv'|'en'|string
}

type QARaw = {
  one_liner?: string
  why?: any
  ack?: string
  short_script?: string
  full_script?: string
  math?: string
  next_step?: string
}

const PREFERRED_MODELS = [
  process.env.OPENAI_MODEL || 'gpt-4o-mini'
]

// ---------- prompt builders ----------
function buildSystemPromptGeneric(activeProfileName: string, profileJson: any, userProfile: any) {
  const lang = (profileJson?.Language || userProfile?.language || 'Svenska') as string
  const tone = [profileJson?.Tone, userProfile?.preferred_tone].filter(Boolean).join('; ')
  const compliance = profileJson?.Compliance || ''
  const callback = profileJson?.CallbackWindows || ''
  const proof = profileJson?.Proof || ''

  return [
    `Du √§r en professionell s√§ljcoach. Svara alltid p√• ${lang}.`,
    `Stil/ton: ${tone || 'Varm, konkret, m√§nsklig. Korta, handlingsbara svar.'}`,
    compliance ? `Compliance: ${compliance}` : ``,
    proof ? `Bevis/Proof att anv√§nda n√§r relevant: ${proof}` : ``,
    callback ? `Ring-/m√∂testider att f√∂resl√• (om m√•l kr√§ver): ${callback}` : ``,
    `Returnera STRIKT JSON i f√§lten: one_liner, why, ack, short_script, full_script, math, next_step.`,
    `why ska vara i tredje person om kunden och kan vara sammanh√§ngande text.`,
    `short_script max 2 meningar. full_script max 90‚Äì120 ord.`
  ].filter(Boolean).join('\n')
}

function buildUserPromptGeneric(input: QAInput, kbBest: {text?: string, hit?: boolean}, profileJson: any, userProfile: any) {
  const parts:string[] = []
  if (kbBest?.text) parts.push('INTERNAL BEST PRACTICE (f√∂lj ramarna): ' + kbBest.text)

  if (Array.isArray(profileJson?.Goals) && profileJson.Goals.length)
    parts.push('Till√•tna m√•l: ' + profileJson.Goals.join(', '))
  if (profileJson?.PersonaHints)
    parts.push('Persona hints: ' + profileJson.PersonaHints)

  const up:string[] = []
  if (userProfile?.role) up.push('roll=' + userProfile.role)
  if (userProfile?.experience) up.push('erfarenhet=' + userProfile.experience)
  if (userProfile?.preferred_tone) up.push('tone_pref=' + userProfile.preferred_tone)
  if (userProfile?.language) up.push('spr√•k_pref=' + userProfile.language)
  if (up.length) parts.push('SPEAKER PROFILE: ' + up.join('; '))

  parts.push([
    'M√•l: ' + (input.goal || ''),
    'Signal: ' + (input.question || ''),
    'Segment: ' + (input.segment || ''),
    'Kanal: ' + (input.channel || ''),
    'Siffror: ' + (input.numbers || '')
  ].join(' | '))

  const extras = input.extras || {}
  Object.keys(extras).forEach(k => {
    const v = (extras as any)[k]
    if (v !== undefined && v !== null && String(v).trim() !== '') {
      parts.push(k + ': ' + String(v))
    }
  })

  const cb = profileJson?.CallbackWindows || ''
  if (cb && /(m√∂te|boka|intro|avst√§mning|uppf√∂ljning)/i.test(input.goal || '')) {
    parts.push('Om du f√∂resl√•r tider, anv√§nd tv√• exakta tider fr√•n: ' + cb)
  }
  return parts.join(' | ')
}

// ---------- shaping ----------
function coerceWhyObject(why: any) {
  const toStr = (x:any) => (x === undefined || x === null) ? '' : String(x).trim()
  let w:any = {}
  if (why && typeof why === 'object') w = why
  else if (why && typeof why === 'string') w = { qfocus: why }
  if (!toStr(w.qfocus))      w.qfocus      = 'Kunden vill f√∂rst√• nyttan och s√§nka risk f√∂re beslut.'
  if (!toStr(w.personal))    w.personal    = 'Personliga m√•l och begr√§nsningar styr beslutsvilja och tajming.'
  if (!toStr(w.biases))      w.biases      = 'Status quo och f√∂rlustaversion bromsar; tydlighet √∂kar trygghet.'
  if (!toStr(w.norms))       w.norms       = 'Verifierbarhet och skriftlig bekr√§ftelse v√§rderas.'
  if (!toStr(w.law))         w.law         = 'Transparens minskar upplevd risk (ej juridisk r√•dgivning).'
  if (!toStr(w.implication)) w.implication = 'Erbjud enkel n√§sta handling, kort och verifierbar.'
  return w
}

function enforceCaps(obj: QARaw) {
  const trimWords = (s:string, n:number) => (s || '').toString().split(/\s+/).slice(0, n).join(' ').trim()
  const limitChars = (s:string, n:number) => (s || '').toString().slice(0, n).trim()

  if (obj.one_liner) obj.one_liner = trimWords(obj.one_liner, 14)
  obj.why = coerceWhyObject(obj.why)
  ;['qfocus','personal','biases','norms','law','implication'].forEach(k => {
    obj.why[k] = limitChars(String(obj.why[k] || ''), 280)
  })
  if (obj.ack) obj.ack = limitChars(obj.ack, 140)
  if (obj.short_script) {
    const two = obj.short_script.split(/(?<=[.!?])\s+/).slice(0, 2)
    obj.short_script = two.join(' ')
  }
  if (obj.full_script) obj.full_script = limitChars(obj.full_script, 600)
  if (obj.math) obj.math = limitChars(obj.math.replace(/\n+/g, ' '), 200)
  if (obj.next_step) {
    const first = obj.next_step.split(/(?<=[.!?])\s+/)[0] || obj.next_step
    obj.next_step = limitChars(first, 240)
  }
  return obj
}

// --------- small helpers (stubbed) ----------
async function getActiveProfileJSON(profileName?: string) {
  // Hook into your real profile storage if you want.
  // For now return empty (non-breaking).
  return {}
}
async function getUserProfile() {
  // Hook into your Users table if you have one.
  return { language: 'Svenska', preferred_tone: '' }
}
async function kbFindBest(signal: string, profileName?: string) {
  // If you have a KB table / vector store, implement fuzzy search here.
  return { text: '', hit: false }
}

// --------- OpenAI call ----------
async function callOpenAIJSON(systemPrompt: string, userPrompt: string) {
  const key = process.env.OPENAI_API_KEY
  if (!key) throw new Error('Missing OPENAI_API_KEY')

  let lastErr: any
  for (const model of PREFERRED_MODELS) {
    try {
      const resp = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${key}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model,
          temperature: 0.25,
          response_format: { type: 'json_object' },
          messages: [
            { role: 'system', content: systemPrompt },
            { role: 'user', content: userPrompt }
          ]
        })
      })
      if (!resp.ok) throw new Error(`HTTP ${resp.status}: ${await resp.text()}`)
      const data = await resp.json()
      let content = data?.choices?.[0]?.message?.content || '{}'
      const match = content.match(/\{[\s\S]*\}$/)
      if (match) content = match[0]
      return JSON.parse(content) as QARaw
    } catch (e:any) { lastErr = e }
  }
  throw new Error('OpenAI call failed: ' + (lastErr?.message || String(lastErr)))
}

// --------- main entry ----------
export async function generateQAAnswer(input: QAInput) {
  const profileJson = await getActiveProfileJSON(input.profileName)
  const userProfile = await getUserProfile()
  const kb = await kbFindBest(input.question || '', input.profileName)

  const sys = buildSystemPromptGeneric(input.profileName || '', profileJson, userProfile)
  const usr = buildUserPromptGeneric(input, kb, profileJson, userProfile)

  let obj = await callOpenAIJSON(sys, usr)
  obj = enforceCaps(obj)

  return {
    obj,
    meta: { kb_used: !!kb?.hit, profile: input.profileName || '' }
  }
}

--- lib/cn.ts ---
export function cn(...classes: Array<string | false | null | undefined>) {
  return classes.filter(Boolean).join(' ')
}

--- lib/i18n.ts ---
// lib/i18n.ts
export type Lang = 'sv' | 'en'

const dict: Record<Lang, Record<string, string>> = {
  sv: {
    // App & nav
    'app.title': 'SalesMind',
    'nav.qa': 'Q&A',
    'nav.profiles': 'Profiler',
    'nav.company': 'F√∂retag',
    'nav.kb': 'Kunskapsbank',
    'nav.events': 'H√§ndelser',
    'nav.settings': 'Inst√§llningar',

    // Common
    'common.save': 'Spara',
    'common.cancel': 'Avbryt',
    'common.delete': 'Ta bort',
    'common.new': 'Ny',
    'common.none': '‚Äî ingen ‚Äî',
    'common.loading': 'Laddar ‚Ä¶',
    'common.error': 'N√•got gick fel',
    'common.ok': 'OK',

    // QA ‚Äî titles & labels
    'qa.title': 'Q&A',
    'qa.company': 'F√∂retag',
    'qa.profile': 'Profil',
    'qa.goal': 'M√•l',
    'qa.segment': 'Segment',
    'qa.channel': 'Kanal',
    'qa.numbers': 'Siffror',
    'qa.question': 'Fr√•ga / Signal',
    'qa.getAnswer': 'H√§mta svar',
    'qa.hint.enter': 'Enter: skicka ‚Ä¢ Shift+Enter: ny rad',

    // QA ‚Äî placeholders
    'qa.ph.company': 'V√§lj f√∂retag (valfritt)',
    'qa.ph.profile': 'V√§lj s√§ljprofil',
    'qa.ph.goal': 'T.ex. ‚ÄùBoka demo‚Äù eller ‚ÄùKvalificera‚Äù',
    'qa.ph.segment': 'T.ex. ‚ÄùSMB SaaS i Norden‚Äù',
    'qa.ph.channel': 'T.ex. ‚ÄùE-post‚Äù, ‚ÄùTelefon‚Äù, ‚ÄùLinkedIn‚Äù',
    'qa.ph.numbers': 'T.ex. ‚Äù3 m√∂ten/vecka‚Äù, ‚ÄùCTR 2,1%‚Äù',
    'qa.ph.question': 'Skriv din fr√•ga / signal ‚Ä¶ (Enter skickar, Shift+Enter ny rad)',

    // QA ‚Äî result blocks
    'qa.res.one_liner': 'One-liner',
    'qa.res.why': 'Varf√∂r',
    'qa.res.ack': 'Bekr√§fta',
    'qa.res.short_script': 'Kort manus',
    'qa.res.full_script': 'Fullt manus',
    'qa.res.math': 'Utr√§kning',
    'qa.res.next_step': 'N√§sta steg',

    // QA ‚Äî feedback
    'qa.fb.title': 'Feedback',
    'qa.fb.rating': 'Betyg (1‚Äì5)',
    'qa.fb.used': 'Anv√§ndes?',
    'qa.fb.tags': 'Taggar',
    'qa.fb.save': 'Spara feedback',
    'qa.fb.yes': 'Ja',
    'qa.fb.no': 'Nej',

    // QA ‚Äî location context (NYTT)
    'qa.loc.title': 'Platskontext',
    'qa.loc.segment': 'Segment',
    'qa.loc.nearby': 'I n√§rheten',
    'qa.loc.hooks': 'Krokar',
    'qa.loc.plan': 'Plan',
  },

  en: {
    // App & nav
    'app.title': 'SalesMind',
    'nav.qa': 'Q&A',
    'nav.profiles': 'Profiles',
    'nav.company': 'Company',
    'nav.kb': 'Knowledge Base',
    'nav.events': 'Events',
    'nav.settings': 'Settings',

    // Common
    'common.save': 'Save',
    'common.cancel': 'Cancel',
    'common.delete': 'Delete',
    'common.new': 'New',
    'common.none': '‚Äî none ‚Äî',
    'common.loading': 'Loading ‚Ä¶',
    'common.error': 'Something went wrong',
    'common.ok': 'OK',

    // QA ‚Äî titles & labels
    'qa.title': 'Q&A',
    'qa.company': 'Company',
    'qa.profile': 'Profile',
    'qa.goal': 'Goal',
    'qa.segment': 'Segment',
    'qa.channel': 'Channel',
    'qa.numbers': 'Numbers',
    'qa.question': 'Question / Signal',
    'qa.getAnswer': 'Get answer',
    'qa.hint.enter': 'Enter: submit ‚Ä¢ Shift+Enter: new line',

    // QA ‚Äî placeholders
    'qa.ph.company': 'Choose company (optional)',
    'qa.ph.profile': 'Choose sales profile',
    'qa.ph.goal': 'e.g. ‚ÄúBook demo‚Äù or ‚ÄúQualify‚Äù',
    'qa.ph.segment': 'e.g. ‚ÄúSMB SaaS in Nordics‚Äù',
    'qa.ph.channel': 'e.g. ‚ÄúEmail‚Äù, ‚ÄúPhone‚Äù, ‚ÄúLinkedIn‚Äù',
    'qa.ph.numbers': 'e.g. ‚Äú3 meetings/week‚Äù, ‚ÄúCTR 2.1%‚Äù',
    'qa.ph.question': 'Type your question / signal‚Ä¶ (Enter submits, Shift+Enter new line)',

    // QA ‚Äî result blocks
    'qa.res.one_liner': 'One-liner',
    'qa.res.why': 'Why',
    'qa.res.ack': 'Acknowledge',
    'qa.res.short_script': 'Short script',
    'qa.res.full_script': 'Full script',
    'qa.res.math': 'Math',
    'qa.res.next_step': 'Next step',

    // QA ‚Äî feedback
    'qa.fb.title': 'Feedback',
    'qa.fb.rating': 'Rating (1‚Äì5)',
    'qa.fb.used': 'Used?',
    'qa.fb.tags': 'Tags',
    'qa.fb.save': 'Save feedback',
    'qa.fb.yes': 'Yes',
    'qa.fb.no': 'No',

    // QA ‚Äî location context (NEW)
    'qa.loc.title': 'Location context',
    'qa.loc.segment': 'Segment',
    'qa.loc.nearby': 'Nearby',
    'qa.loc.hooks': 'Hooks',
    'qa.loc.plan': 'Plan',
  },
}

function readCookie(name: string, cookieStr?: string) {
  const source = typeof cookieStr === 'string'
    ? cookieStr
    : (typeof document !== 'undefined' ? document.cookie : '')
  if (!source) return null
  const match = source.split(';').map(s => s.trim()).find(s => s.startsWith(name + '='))
  return match ? decodeURIComponent(match.split('=').slice(1).join('=')) : null
}

export function getLang(cookieStr?: string): Lang {
  const v = readCookie('salesmind_lang', cookieStr)
  if (v === 'en' || v === 'sv') return v
  return 'sv'
}

export function setLangCookie(lang: Lang) {
  if (typeof document === 'undefined') return
  document.cookie = `salesmind_lang=${lang}; Path=/; Max-Age=31536000; SameSite=Lax`
}

export function t(lang: Lang, key: string): string {
  return dict[lang]?.[key] ?? key
}

--- lib/supabaseServer.ts ---
// lib/supabaseServer.ts
import { cookies } from 'next/headers'
import { createServerClient } from '@supabase/ssr'

export async function supabaseServer() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        // I server components kan vi inte skriva cookies ‚Äì l√•t middleware/APIs g√∂ra det
        set() {},
        remove() {},
      },
    }
  )
}

--- lib/scb.ts ---
export type PxQuery = {
  query: Array<{ code: string; selection: { filter: string; values: string[] } }>;
  response?: { format: 'JSON' | 'PX' };
};

export async function pxwebFetch(baseUrl: string, body: PxQuery) {
  // Example baseUrl:
  //  "https://api.scb.se/OV0104/v1/doris/sv/ssd/HE/HE0110/HE0110A/DispInkMedelKom√Ölder"
  // You control exact dataset path via env.
  const r = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...body,
      response: { format: 'JSON' },
    }),
    // Node fetch
    cache: 'no-store'
  });
  if (!r.ok) {
    const text = await r.text().catch(() => '');
    throw new Error(`SCB HTTP ${r.status}: ${text}`);
  }
  return r.json();
}

--- lib/kommuner.ts ---
import { KOMMUNER } from '../data/kommuner'

/** Map both Swedish and English names -> kommun code */
const nameToCode: Record<string, string> = {}
for (const k of KOMMUNER) {
  if (k.name_sv) nameToCode[k.name_sv] = k.code
  if (k.name_en) nameToCode[k.name_en] = k.code
}

/** Backward-compatible export name expected by your code */
export const KOMMUN_CODE_BY_NAME = nameToCode

/** Extra helpers if you need them later */
export const KOMMUN_BY_CODE = new Map(KOMMUNER.map(k => [k.code, k]))
export function kommunCodeFromName(input: string | undefined | null): string | undefined {
  if (!input) return
  const s = input.trim()
  if (/^\d{4}$/.test(s)) return s
  return nameToCode[s] || nameToCode[s.normalize('NFKC')]
}

export { KOMMUNER }

--- lib/siteImages.ts ---
// lib/siteImages.ts
// Build a public URL for files stored in the Supabase "site" bucket.
// Example: siteImageUrl('hero.jpg') -> https://.../storage/v1/object/public/site/hero.jpg

const base = process.env.NEXT_PUBLIC_SUPABASE_URL || '';

export function siteImageUrl(path: string) {
  const p = String(path || '').replace(/^\/+/, '');
  if (!base) return '';
  return `${base}/storage/v1/object/public/site/${p}`;
}

--- lib/utils.ts ---
export function cn(...classes: Array<string | false | null | undefined>) {
  return classes.filter(Boolean).join(' ')
}

--- lib/supabaseBrowser.ts ---
// lib/supabaseBrowser.ts
'use client'

import { createClient, type SupabaseClient } from '@supabase/supabase-js'

let _client: SupabaseClient | null = null

export function supabaseBrowser(): SupabaseClient {
  if (_client) return _client

  const url = process.env.NEXT_PUBLIC_SUPABASE_URL
  const key = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY

  if (!url || !key) {
    // G√∂r felet tydligt i b√•de dev och prod
    throw new Error(
      'Supabase env saknas: Kontrollera NEXT_PUBLIC_SUPABASE_URL och NEXT_PUBLIC_SUPABASE_ANON_KEY'
    )
  }

  _client = createClient(url, key, {
    auth: {
      persistSession: true,
      autoRefreshToken: true,
      detectSessionInUrl: true,
    },
  })
  return _client
}

--- lib/chunk.ts ---
// lib/chunk.ts
export function chunkText(text: string, maxChars = 1200): string[] {
  const parts:string[] = []
  let buf = ''
  for (const line of text.split(/\n+/)) {
    if ((buf + '\n' + line).length > maxChars) {
      if (buf.trim()) parts.push(buf.trim())
      buf = line
    } else {
      buf = buf ? buf + '\n' + line : line
    }
  }
  if (buf.trim()) parts.push(buf.trim())
  return parts
}

--- lib/baseUrl.ts ---
import type { NextRequest } from 'next/server'

export function getBaseUrl(req?: NextRequest) {
  // Vercel URL
  const vercel = process.env.VERCEL_URL
  if (vercel) return `https://${vercel}`
  // Explicit (useful for Codespaces or custom proxies)
  const explicit = process.env.NEXT_PUBLIC_BASE_URL
  if (explicit) return explicit.replace(/\/$/, '')
  // Derive from request headers in dev
  if (req) {
    const proto = req.headers.get('x-forwarded-proto') || 'http'
    const host  = req.headers.get('x-forwarded-host')  || req.headers.get('host') || 'localhost:3000'
    return `${proto}://${host}`
  }
  // Fallback
  return 'http://localhost:3000'
}

--- lib/embedding.ts ---
// lib/embedding.ts
export async function embedText(text: string): Promise<number[]> {
  const apiKey = process.env.OPENAI_API_KEY!
  if (!apiKey) throw new Error('OPENAI_API_KEY missing')
  const r = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${apiKey}`, 'Content-Type':'application/json' },
    body: JSON.stringify({ model: 'text-embedding-3-small', input: text })
  })
  const j = await r.json()
  if (!r.ok) throw new Error(j.error?.message || 'embedding failed')
  return j.data[0].embedding
}

--- scripts/build-kommuner.js ---
/**
 * Generate data/kommuner.ts from SCB codelists.
 * - Tries v2beta codelist first
 * - Falls back to PXWeb v1 table metadata (Region variable)
 * - Final output: export const KOMMUNER = [{ code, name_sv }]
 */
const fs = require('fs');
const path = require('path');
const https = require('https');

function fetchJSON(url, headers={}) {
  return new Promise((resolve, reject) => {
    const req = https.request(url, { method: 'GET', headers: { 'Accept': 'application/json', 'User-Agent': 'pxweb-client', ...headers } }, res => {
      let data = '';
      res.on('data', d => data += d);
      res.on('end', () => {
        const ct = res.headers['content-type'] || '';
        if (!ct.toLowerCase().includes('application/json')) {
          return reject(new Error(`Not JSON from ${url}. content-type=${ct}. preview=${data.slice(0,200)}`));
        }
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(new Error(`JSON parse error from ${url}: ${e.message}. preview=${data.slice(0,200)}`));
        }
      });
    });
    req.on('error', reject);
    req.end();
  });
}

async function tryV2Beta() {
  // Known codelist id for municipalities (kommun) without aggregates
  // SCB v2beta path pattern for codelists:
  //   /ov0104/v2beta/api/v2/codelists/<codelistId>/values?lang=sv
  const url = 'https://api.scb.se/ov0104/v2beta/api/v2/codelists/vs_RegionKommun07EjAggr/values?lang=sv';
  const j = await fetchJSON(url);
  // Expect { values: [{ code: '1280', text: 'Malm√∂' }, ...] } or similar
  const values = (j.values || j || []).map(v => {
    const code = v.code || v.id || v.value || '';
    const text = v.text || v.label || v.name || '';
    return { code, name_sv: text };
  }).filter(x => x.code && x.name_sv);
  if (!values.length) throw new Error('v2beta returned empty values');
  return values;
}

async function tryPXWebV1() {
  // PXWeb v1: read variables from the disposable income table, pick Region variable
  // Trailing slash matters
  const url = 'https://api.scb.se/OV0104/v1/doris/sv/ssd/START__HE__HE0110__HE0110G/Tab4bDispInkN/';
  const j = await fetchJSON(url);
  // Expect { variables: [ { code: 'Region', values: [...], valueTexts: [...] }, ... ] }
  const regionVar = (j.variables || []).find(v => v.code === 'Region');
  if (!regionVar) throw new Error('PXWeb v1: Region variable not found');
  const codes = regionVar.values || [];
  const names = regionVar.valueTexts || [];
  const out = [];
  for (let i = 0; i < Math.min(codes.length, names.length); i++) {
    out.push({ code: codes[i], name_sv: names[i] });
  }
  if (!out.length) throw new Error('PXWeb v1 produced 0 kommuner');
  // Filter out aggregates if any slipped in (codes are 4-digit for kommuner)
  return out.filter(k => /^\d{4}$/.test(k.code));
}

function writeFile(rows) {
  // Sort by code for consistency
  rows.sort((a,b)=> a.code.localeCompare(b.code));
  const content =
`// Auto-generated by scripts/build-kommuner.js
// Swedish municipalities (kommuner) ‚Äî code + Swedish name
export interface Kommun { code: string; name_sv: string; }

export const KOMMUNER: Kommun[] = ${JSON.stringify(rows, null, 2)};
`;
  const outDir = path.join(process.cwd(), 'data');
  const outFile = path.join(outDir, 'kommuner.ts');
  fs.mkdirSync(outDir, { recursive: true });
  fs.writeFileSync(outFile, content, 'utf8');
  console.log(`Wrote ${rows.length} kommuner -> ${path.relative(process.cwd(), outFile)}`);
}

(async () => {
  try {
    let rows = [];
    try {
      console.log('Trying SCB v2beta codelist‚Ä¶');
      rows = await tryV2Beta();
    } catch (e1) {
      console.warn('v2beta failed:', e1.message);
      console.log('Trying PXWeb v1 variables‚Ä¶');
      rows = await tryPXWebV1();
    }
    if (!rows.length) throw new Error('No kommuner fetched.');
    writeFile(rows);
  } catch (e) {
    console.error('Failed to build kommuner list:', e.message);
    // Fallback minimal list so app still runs; replace later
    const fallback = [
      { code: '0114', name_sv: 'Upplands V√§sby' },
      { code: '0180', name_sv: 'Stockholms stad' },
      { code: '1280', name_sv: 'Malm√∂' },
      { code: '1480', name_sv: 'G√∂teborg' },
      { code: '1980', name_sv: 'Uppsala' },
    ];
    writeFile(fallback);
    process.exitCode = 1;
  }
})();

--- scripts/fetch-kommuner-wikidata.js ---
/**
 * Fetch all Swedish municipalities (kommuner) from Wikidata with their Swedish names
 * and Swedish municipal code (kommunkod, property P525), then write data/kommuner.ts
 *
 * Output shape:
 *   export const KOMMUNER = [
 *     { code: "0114", name_sv: "Upplands V√§sby", name_en: "Upplands V√§sby" },
 *     ...
 *   ] as const;
 *
 * We include English label fallback (Wikidata has en labels for most).
 */

import fs from "node:fs";
import path from "node:path";

const SPARQL = `
SELECT ?code ?name_sv ?name_en WHERE {
  ?item wdt:P31 wd:Q15284 .        # instance of: municipality of Sweden
  ?item wdt:P525 ?code .           # Swedish municipal code
  OPTIONAL { ?item rdfs:label ?name_sv FILTER (lang(?name_sv) = "sv") }
  OPTIONAL { ?item rdfs:label ?name_en FILTER (lang(?name_en) = "en") }
}
ORDER BY ?code
`;

const ENDPOINT = "https://query.wikidata.org/sparql";
const HEADERS = {
  "Accept": "application/sparql-results+json",
  "User-Agent": "sales-mind-kommunkod-fetch/1.0 (contact: yourapp@example.com)"
};

async function main() {
  const url = new URL(ENDPOINT);
  url.searchParams.set("query", SPARQL);

  const resp = await fetch(url, { headers: HEADERS });
  if (!resp.ok) {
    const t = await resp.text().catch(() => "");
    throw new Error(`Wikidata SPARQL HTTP ${resp.status}: ${t.slice(0,200)}`);
  }
  const json = await resp.json();
  const rows = json?.results?.bindings || [];

  if (!Array.isArray(rows) || rows.length < 200) {
    throw new Error(`Unexpected result size: got ${rows.length} rows (expected ~290).`);
  }

  const items = rows.map(r => {
    const codeRaw = r.code?.value?.trim() || "";
    // Normalize to 4-digit zero-padded string (e.g. "114" -> "0114")
    const code = codeRaw.padStart(4, "0");
    const name_sv = (r.name_sv?.value || "").trim();
    const name_en = (r.name_en?.value || "").trim() || name_sv;
    return { code, name_sv, name_en };
  });

  // Deduplicate by code just in case
  const seen = new Set();
  const unique = items.filter(it => {
    if (seen.has(it.code)) return false;
    seen.add(it.code);
    return true;
  });

  // Sort by code ascending
  unique.sort((a, b) => a.code.localeCompare(b.code, "sv"));

  // Write TS file
  const outDir = path.resolve("data");
  const outFile = path.join(outDir, "kommuner.ts");
  await fs.promises.mkdir(outDir, { recursive: true });

  const ts = `// Auto-generated by scripts/fetch-kommuner-wikidata.js
// Source: Wikidata SPARQL (P525 kommunkod, Q15284 municipality of Sweden)
export const KOMMUNER = [
${unique.map(it => `  { code: "${it.code}", name_sv: ${JSON.stringify(it.name_sv)}, name_en: ${JSON.stringify(it.name_en)} }`).join(",\n")}
] as const;

export type Kommun = typeof KOMMUNER[number];
`;

  await fs.promises.writeFile(outFile, ts, "utf8");
  console.log(`Wrote ${unique.length} kommuner -> ${outFile}`);
}

main().catch(err => {
  console.error("Failed to fetch kommuner:", err.message);
  process.exit(1);
});

--- package.json ---
{
  "name": "sales-mind",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint --max-warnings=0 || true"
  },
  "dependencies": {
    "@react-google-maps/api": "^2.20.7",
    "@supabase/ssr": "^0.7.0",
    "@supabase/supabase-js": "^2.57.4",
    "clsx": "^2.1.1",
    "formidable": "^3.5.4",
    "leaflet": "^1.9.4",
    "next": "15.5.3",
    "openai": "^5.23.2",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-leaflet": "^5.0.0"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.5.3",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}

--- next.config.mjs ---
/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: { ignoreDuringBuilds: true },
  typescript: { ignoreBuildErrors: true },
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'scnypfijjepslmavbfkz.supabase.co',
        pathname: '/storage/v1/object/public/**',
      },
    ],
  },
};

export default nextConfig;

--- next.config.mjs.bak ---
/** @type {import('next').NextConfig} */
const supaUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || '';
let supaHost = '';
try { if (supaUrl) supaHost = new URL(supaUrl).hostname; } catch {}

const nextConfig = {
  images: {
    remotePatterns: supaHost ? [
      {
        protocol: 'https',
        hostname: supaHost,
        pathname: '/storage/v1/object/public/**',
      },
    ] : [],
  },
};

const withESLint = { eslint: { ignoreDuringBuilds: true } };
export default nextConfig;

--- next.config.ts ---
// next.config.ts
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  // typedRoutes flyttades fr√•n experimental
  typedRoutes: false,
  eslint: { ignoreDuringBuilds: true },
}

export default nextConfig

--- postcss.config.mjs ---
/** @type {import('postcss-load-config').Config} */
export default {
  plugins: {
    '@tailwindcss/postcss': {},
  },
}

--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

--- .eslintrc.json ---
{
  "root": true,
  "extends": ["next/core-web-vitals"],
  "rules": {
    "@typescript-eslint/no-explicit-any": "error"
  },
  "overrides": [
    {
      "files": ["app/api/**/*.{ts,tsx}", "lib/**/*.{ts,tsx}"],
      "rules": {
        "@typescript-eslint/no-explicit-any": "warn",
        "@typescript-eslint/no-require-imports": "off",
        "@typescript-eslint/ban-ts-comment": ["warn", { "ts-ignore": "allow-with-description" }]
      }
    },
    {
      "files": ["app/(site)/**/*.{ts,tsx}", "components/**/*.{ts,tsx}"],
      "rules": {
        "@next/next/no-img-element": "warn"
      }
    }
  ]
}

--- .env.local (REDACTED) ---
# Created by Vercel CLI
GOOGLE_MAPS_API_KEY=***REDACTED***
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=***REDACTED***
NEXT_PUBLIC_SUPABASE_ANON_KEY=***REDACTED***
NEXT_PUBLIC_SUPABASE_URL=***REDACTED***
OPENAI_API_KEY=***REDACTED***
SCB_AGE_CODE=***REDACTED***
SCB_DATASET_URL=***REDACTED***
SCB_HH_TYPE_CODE=***REDACTED***
SCB_HH_TYPE_KEEP=***REDACTED***
SCB_MEASURE_CODE=***REDACTED***
SCB_MEASURE_VALUE=***REDACTED***
SCB_REGION_CODE=***REDACTED***
SCB_TIME_CODE=***REDACTED***
SUPABASE_SERVICE_KEY=***REDACTED***
VERCEL_OIDC_TOKEN=***REDACTED***
NEXT_PUBLIC_ENABLE_GOOGLE_OIDC=***REDACTED***
NEXT_PUBLIC_SITE_URL=***REDACTED***
